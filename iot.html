<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="This is an Educational website based on iot,5g,machineLearning,artificial intelligence,iot modules">
    <meta name="keywords" content="iot,ml,python,ai,iot modules,5g,machineLearning,artificial intelligence">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="S.Sonu Patra">
    <link rel="stylesheet" href="css_design1.css">
    <link rel="stylesheet" href="css_design2.css">
    <link rel="stylesheet" href="collapsible.css">
</head>

<body>
    <div>
        <table id="header">
            <tr>
                <th>
                    <h1>IOT COMPONENTS AND MODULES</h1>
                </th>
            </tr>
            <tr>
                <th>
                    <div class="topnav" id="myTopnav">
                        <a href="index.html">Home</a>
                        <div class="dropdown">
                            <button class="dropbtn">Modules
                                            <i class="fa fa-caret-down"></i>
                                        </button>
                            <div class="dropdown-content">
                                <a href="commutools.html">
                                    <div align="left" class="font"><img src="1 (12).png" class="short">COMMUNICATION TOOLS
                                    </div>
                                </a>
                                <a href="drone.html">
                                    <div align="left" class="font"><img src="1 (5).png" class="short">DRONE COMPONENTS</div>
                                </a>
                                <a href="iot.html">
                                    <div align="left" class="font"><img src="1 (2).png" class="short">IOT MODULES</div>
                                </a>
                                <a href="boards.html">
                                    <div align="left" class="font"><img src="1 (1).png" class="short">MICROCONTROLLERS</div>
                                </a>
                            </div>
                        </div>
                        <div class="dropdown">
                            <button class="dropbtn">Books
                                            <i class="fa fa-caret-down"></i>
                                        </button>
                            <div class="dropdown-content">
                                <a href="python.html">
                                    <div align="left" class="font"><img src="1 (11).png" class="short">PYTHON</div>
                                </a>
                                <a href="ml.html">
                                    <div align="left" class="font"><img src="1 (3).png" class="short">ML</div>
                                </a>
                                <a href="firebase.html">
                                    <div align="left" class="font"><img src="1 (9).png" class="short">FIREBASE</div>
                                </a>
                                <a href="iotbook.html">
                                    <div align="left" class="font"><img src="1 (7).png" class="short">IOT</div>
                                </a>
                                <a href="drones.html">
                                    <div align="left" class="font"><img src="1 (10).png" class="short">DRONE</div>
                                </a>
                                <a href="ai.html">
                                    <div align="left" class="font"><img src="1 (8).png" class="short">AI</div>
                                </a>
                                <a href="5g.html">
                                    <div align="left" class="font"><img src="1 (6).png" class="short">5G IOT</div>
                                </a>
                            </div>
                        </div>
                        <a href="about.html">About</a>
                        <a href="javascript:void(0);" style="font-size:15px;" class="icon" onclick="myFunction()">&#9776;</a>
                    </div>
                </th>
            </tr>
        </table>
    </div>
    <div class="grid-container">
        <div class="item"><button class="effe" id="myBtn"><img class="image" src="smd module.jpg"></button><br>SMD RGB LED
            <div id="myModal" class="modal">
                <div class="modal-content">
                    <span class="close">&times;</span>
                    <button class="collapsible">
                        <h4>Description:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>Pinout for the Geekcreit common cathode Red, Green & Blue (RGB) LED module, from the Geekcreit 37 in 1 sensor module board set kit for Arduino.</li>
                                <li>In some kits this module may be called 3-color LED module.</li>
                                <li>This pinout is for the Geekcreit RGB LED module with a through-hole mounting LED that has four pins and current limiting resistors on the module.</li>
                                <li>The LED has a common cathode pin and can display red, green or blue depending on which anode pin power is connected to.</li>
                                <li>LDifferent colours can be obtained by switching more than one of the RGB colours on at the same time.</li>
                                <li>As can be seen in the circuit diagram for this module, the LED module has built-in current limiting resistors on each anode.
                                </li>
                                <li>This means that the module can be used directly with a 5V controller such as any 5V Arduino. The common cathode (-) of the module connects to GND. 5V applied to any of the anodes will then switch that colour on.</li>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn1"><img class="image" src="2.jpg"></button><br>Micro Servo with 3-pin JST Cable
            <div id="myModal1" class="modal">
                <div class="modal-content">
                    <span class="close1">&times;</span>
                    <img src="servo-pinout.png" class="collapsible_image" alt="It is a image."><br>
                    <button class="collapsible">
                        <h4>Description:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            The TowerPro SG90 9g Mini Servo is 180° rotation servo. It is a Digital Servo Motor which receives and processes PWM signal faster and better. It equips sophisticated internal circuitry that provides good torque, holding power, and faster updates in response
                            to external forces.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>TowerPro SG-90 Features:</h4>
                    </button>
                    <div class="content">
                        <h5>• Operating Voltage is +5V typically<br> • Torque: 2.5kg/cm<br> • Operating speed is 0.1s/60°<br> • Gear Type: Plastic<br> • Rotation : 0°-180°<br> • Weight of motor : 9gm<br> • Package includes gear horns and screws
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>SG-90 Servo Motor Equivalent:</h4>
                    </button>
                    <div class="content">
                        <h5>MG90S Metal Gear, MG995 High Torque Metal Gear, VTS-08A Analog Servo
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Selecting your Servo Motor:</h4>
                    </button>
                    <div class="content">
                        <h5>There are lots of servo motors available in the market and each one has its own speciality and applications.<br>The following two paragraphs will help you identify the right type of servo motor for your project/system.<br> Most
                            of the hobby Servo motors operates from 4.8V to 6.5V, the higher the voltage higher the torque we can achieve, but most commonly they are operated at +5V.<br>Almost all hobby servo motors can rotate only from 0° to 180° due
                            to their gear arrangement so make sure you project can live with the half circle if no, you can prefer for a 0° to 360° motor or modify the motor to make a full circle. The gears in the motors are easily subjected to wear and
                            tear, so if your application requires stronger and long running motors you can go with metal gears or just stick with normal plastic gear.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Specifications:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            Specs of a large servo motor:-<br>
                            <ul>
                                <li>Size 38 x 11.5 x 24mm (Include tabs) 28 x 12.7 x 27mm (Not include tabs)</li>
                                <li> Weight 17g (Not include a cable and a connector) 18g (Include a cable and a connector)</li>
                                <li>Speed 0.14sec/60degrees (4.8V) 0.12sec/60degrees (6.0V)</li>
                                <li>Torque 2.5kgf-cm (4.8V) 3.0kgf-cm (6.0V)</li>
                                <li>Voltage 4.8V-6.0V</li>
                                <li>Connector type JR type '(Yellow: Signal, Red: VCC, Brown:GND)'</li>
                            </ul>
                            Specs of a small servo motor:-<br>
                            <ul>
                                <li>Size 32 × 11.5 × 24mm (Include tabs) 23.5 × 11.5 × 24mm (Not include tabs)</li>
                                <li>Weight 8.5g (Not include a cable and a connector) 9.3g (Include a cable and a connector)</li>
                                <li>Speed 0.12sec/60degrees (4.8V) 0.10sec/60degrees (6.0V)</li>
                                <li>Torque 1.5kgf-cm (4.8V) 2.0kgf-cm (6.0V)</li>
                                <li>Voltage 4.8V-6.0V</li>
                                <li>Connector type JR type (Yellow: Signal, Red: VCC, Brown:GND)</li>
                            </ul>
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Applications:</h4>
                    </button>
                    <div class="content">
                        <h5>• Used as actuators in many robots like Biped Robot, Hexapod, robotic arm etc..<br> • Commonly used for steering system in RC toys<br> • Robots where position control is required without feedback<br> • Less weight hence used in
                            multi DOF robots like humanoid robots
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn2"><img class="image" src="3.jpg"></button><br>Assembled DC Motor + Stepper FeatherWing
            <div id="myModal2" class="modal">
                <div class="modal-content">
                    <span class="close2">&times;</span>
                    <img align="right" src="feather_schem.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A Feather board without ambition is a Feather board without FeatherWings! This is the DC Motor + Stepper FeatherWing which will let you use 2 x bi-polar stepper motors or 4 x brushed DC motorx (or 1 stepper and 2 DC motors). Using
                            our Feather Stacking Headers (http://adafru.it/2830) or Feather Female Headers (http://adafru.it/2886) you can connect a FeatherWing on top or bottom of your Feather board and let the board take flight!
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Motor FeatherWing Specs:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>4 full H-Bridges: the TB6612 chipset provides 1.2A per bridge with thermal shutdown protection, internal kickback protection diodes. Can run motors on 4.5VDC to 13.5VDC.</li>
                                <li> Up to 4 bi-directional DC motors with individual 12-bit speed selection (so, about 0.02% resolution)</li>
                                <li> Up to 2 stepper motors (unipolar or bipolar) with single coil, double coil, interleaved or micro-stepping.</li>
                                <li>Motors automatically disabled on power-up</li>
                                <li>Big 3.5mm terminal block connectors to easily hook up wires (18-26AWG) and power</li>
                                <li>Polarity protected 2-pin terminal block and jumper to connect external power, for separate logic/motor supplies</li>
                                <li>Completely stackable design: 5 address-select jumper pads means up to 32 stackable wings: that's 64 steppers or 128 DC motors! What on earth could you do with that many steppers? I have no idea but if you come up with something
                                    send us a photo because that would be a pretty glorious project.</li>
                            </ul>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn3"><img class="image" src="4.jpg"></button><br>PJRC Teensy 4.0 USB Development Board
            <div id="myModal3" class="modal">
                <div class="modal-content">
                    <span class="close3">&times;</span>
                    <img src="teensy40_pinout1.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>More Teensy 4.0 are in production now, likely to arrive in 1 week. Get your order in now to reserve your's from that batch, as they very well may sell out. We are currently are working through a backlog of orders. If you placed
                            an order before 5AM Friday, we will very likely be able to ship it by Tuesday.<br>I know waiting is painful, but please understand we're working to ship them as quickly as we can. If you are in Europe, look for Teensy 4.0 at
                            distributors. They will sell out quickly. We hope to get much more stock to distributors within the next few weeks.<br> Teensy 4.0 is the latest Teensy, offering the fastest microcontroller and powerful peripherals in the Teensy
                            1.4 by 0.7 inch form factor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• ARM Cortex-M7 at 600 MHz<br> • 1024K RAM (512K is tightly coupled)<br> • 2048K Flash (64K reserved for recovery & EEPROM emulation)<br> • 2 USB ports, both 480 MBit/sec<br> • 3 CAN Bus (1 with CAN FD)<br> • 2 I2S Digital Audio<br>                            • 1 S/PDIF Digital Audio<br> • 1 SDIO (4 bit) native SD<br> • 3 SPI, all with 16 word FIFO<br> • 3 I2C, all with 4 byte FIFO<br> • 7 Serial, all with 4 byte FIFO<br> • 32 general purpose DMA channels<br> • 31 PWM pins<br> •
                            40 digital pins, all interrrupt capable<br> • 14 analog pins, 2 ADCs on chip<br> • Cryptographic Acceleration<br> • Random Number Generator<br> • RTC for date/time<br> • Programmable FlexIO<br> • Pixel Processing Pipeline<br>                            • Peripheral cross triggering<br> • Power On/Off management
                        </h5>
                    </div>
                    <img src="teensy40_pinout2.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Power Consumption & Management:</h4>
                </button>
                    <div class="content">
                        <h5>When running at 600 MHz, Teensy 4.0 consumes approximately 100 mA current.<br> Teensy 4.0 provides support for dynamic clock scaling. Unlike traditional microcontrollers, where changing the clock speed causes wrong baud rates and
                            other issues, Teensy 4.0 hardware and Teensyduino's software support for Arduino timing functions are designed to allow dynamically speed changes.<br>Serial baud rates, audio streaming sample rates, and Arduino functions like
                            delay() and millis(), and Teensyduino's extensions like IntervalTimer and elapsedMillis, continue to work properly while the CPU changes speed.<br> Teensy 4.0 also provides a power shut off feature. By connecting a pushbutton
                            to the On/Off pin, the 3.3V power supply can be completely disabled by holding the button for 5 seconds, and turned back on by a brief button press.<br>If a coin cell is connected to VBAT, Teensy 4.0's RTC also continues to
                            keep track of date & time while the power is off.<br> Teensy 4.0 also can also be overclocked, well beyond 600 MHz!
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn4"><img class="image" src="5.jpg"></button><br>Small Alligator Clip to Female Jumper Wire
            <div id="myModal4" class="modal">
                <div class="modal-content">
                    <span class="close4">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>For bread-boarding with unusual non-header-friendly surfaces, these cables will be your best friends! No longer will you have long strands of alligator clips that are grabbing little wires. These compact jumper cables have a premium
                            male header on one end, and a grippy mini alligator clip on the other. Grab onto your Flora, Circuit Playground, micro:bit, Gemma, or even a banana, and plug it into a breadboard for prototyping joy! You get 12 pieces in 6
                            colors. • 12 piece set, color coded vinyl covered 1.25" alligator clips on one end, and male jumper wires on the other end • Contains two of each: black, red, white, green, blue, and yellow • 24 AWG wire
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>Bundle weight: 25g/0.89oz</li>
                                <li>Wire length end-to-end: 150mm / 6" ± 0.5"</li>
                            </ul>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn5"><img class="image" src="6.jpg"></button><br>Adafruit VCNL4040 Proximity and Lux Sensor
            <div id="myModal5" class="modal">
                <div class="modal-content">
                    <span class="close5">&times;</span>
                    <img src="vcnl4040-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Power Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• Vin - this is the power pin. Since the sensor chip uses 3 VDC, we have included a voltage regulator on board that will take 3-5VDC and safely convert it down. To power the board, give it the same power as the logic level of your
                            microcontroller - e.g. for a 5V micro like Arduino, use 5V<br> • 3Vo - this is the 3.3V output from the voltage regulator, you can grab up to 100mA from this if you like<br> • GND - common ground for power and logic
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>I2C Logic Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• SCL - this is the I2C clock pin, connect to your microcontroller's I2C clock line.<br> • SDA - this is the I2C data pin, connect to your microcontroller's I2C data line<br> • STEMMA QT - These connectors allow you to connectors
                            to dev boards with STEMMA QTconnectors or to other things with various associated accessories
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Other Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• INT -This is the interrupt pin. You can setup the VCNL4040 to pull this low when certain conditions are met such as proximity or lux level thresholds being crossed.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <li>#include
                                <Adafruit_VCNL4040.h>
                            </li>
                            <li>Adafruit_VCNL4040 vcnl4040 = Adafruit_VCNL4040();</li>
                            <li>void setup() {</li>
                            <li> Serial.begin(115200);</li>
                            <li> // Wait until serial port is opened</li>
                            <li> while (!Serial) { delay(1); }</li>
                            <li> Serial.println("Adafruit VCNL4040 Config demo");</li>
                            <li> if (!vcnl4040.begin()) {</li>
                            <li> Serial.println("Couldn't find VCNL4040 chip");</li>
                            <li> while (1);</li>
                            <li> }</li>
                            <li> Serial.println("Found VCNL4040 chip");</li>
                            <li> //vcnl4040.setProximityLEDCurrent(VCNL4040_LED_CURRENT_200MA);</li>
                            <li> Serial.print("Proximity LED current set to: ");</li>
                            <li> switch(vcnl4040.getProximityLEDCurrent()) {</li>
                            <li> case VCNL4040_LED_CURRENT_50MA: Serial.println("50 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_75MA: Serial.println("75 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_100MA: Serial.println("100 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_120MA: Serial.println("120 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_140MA: Serial.println("140 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_160MA: Serial.println("160 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_180MA: Serial.println("180 mA"); break;</li>
                            <li> case VCNL4040_LED_CURRENT_200MA: Serial.println("200 mA"); break;</li>
                            <li> }</li>
                            <li> //vcnl4040.setProximityLEDDutyCycle(VCNL4040_LED_DUTY_1_40);</li>
                            <li> Serial.print("Proximity LED duty cycle set to: ");</li>
                            <li> switch(vcnl4040.getProximityLEDDutyCycle()) {</li>
                            <li> case VCNL4040_LED_DUTY_1_40: Serial.println("1/40"); break;</li>
                            <li> case VCNL4040_LED_DUTY_1_80: Serial.println("1/80"); break;</li>
                            <li> case VCNL4040_LED_DUTY_1_160: Serial.println("1/160"); break;</li>
                            <li> case VCNL4040_LED_DUTY_1_320: Serial.println("1/320"); break;</li>
                            <li> }</li>
                            <li> //vcnl4040.setAmbientIntegrationTime(VCNL4040_AMBIENT_INTEGRATION_TIME_80MS);</li>
                            <li> Serial.print("Ambient light integration time set to: ");</li>
                            <li> switch(vcnl4040.getAmbientIntegrationTime()) {</li>
                            <li> case VCNL4040_AMBIENT_INTEGRATION_TIME_80MS: Serial.println("80 ms"); break;</li>
                            <li> case VCNL4040_AMBIENT_INTEGRATION_TIME_160MS: Serial.println("160 ms"); break;</li>
                            <li> case VCNL4040_AMBIENT_INTEGRATION_TIME_320MS: Serial.println("320 ms"); break;</li>
                            <li> case VCNL4040_AMBIENT_INTEGRATION_TIME_640MS: Serial.println("640 ms"); break;</li>
                            <li> }</li>
                            <li> //vcnl4040.setProximityIntegrationTime(VCNL4040_PROXIMITY_INTEGRATION_TIME_8T);</li>
                            <li> switch(vcnl4040.getProximityIntegrationTime()) {
                                <li> Serial.print("Proximity integration time set to: ");</li>
                            </li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_1T: Serial.println("1T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_1_5T: Serial.println("1.5T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_2T: Serial.println("2T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_2_5T: Serial.println("2.5T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_3T: Serial.println("3T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_3_5T: Serial.println("3.5T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_4T: Serial.println("4T"); break;</li>
                            <li> case VCNL4040_PROXIMITY_INTEGRATION_TIME_8T: Serial.println("8T"); break;</li>
                            <li> }</li>
                            <li> //vcnl4040.setProximityHighResolution(false);</li>
                            <li> Serial.print("Proximity measurement high resolution? ");</li>
                            <li> Serial.println(vcnl4040.getProximityHighResolution() ? "True" : "False");</li>
                            <li> Serial.println("");</li>
                            <li>}</li>
                            <li>void loop() {</li>
                            <li> Serial.print("Proximity:"); Serial.println(vcnl4040.getProximity());</li>
                            <li> Serial.print("Ambient light:"); Serial.println(vcnl4040.getLux());</li>
                            <li> Serial.print("Raw white light:"); Serial.println(vcnl4040.getWhiteLight());</li>
                            <li> Serial.println("");</li>
                            <li> delay(500);</li>
                            <li>}</li>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn6"><img class="image" src="7.jpg"></button><br>Adafruit DS3502 I2C Digital 10K Potentiometer Breakout
            <div id="myModal6" class="modal">
                <div class="modal-content">
                    <span class="close6">&times;</span>
                    <img src="DS3502-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Power Pins:</h4>
                </button>
                    <div class="content">
                        <h5>The sensor on the breakout requires between a 2.7V and 5.5V, and can be easily used with most microcontrollers from an Arduino to a Feather or something else.<br> • Vcc - this is the power pin. To power the board, give it the same
                            power as the logic level of your microcontroller - e.g. for a 5V micro like Arduino, use 5V<br> • GND - common ground for power and logic
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>I2C Logic Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• SCL - I2C clock pin, connect to your microcontrollers I2C clock line. The logic level is the same as Vcc and it has a 10K pullup already on it.<br> • SDA - I2C data pin, connect to your microcontrollers I2C data line. The logic
                            level is the same as Vcc. and it has a 10K pullup already on it.<br> • STEMMA QT - These connectors allow you to connectors to dev boards with STEMMA QTconnectors or to other things with various associated accessoriess
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Resistor Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• RL is the Low Terminal of the potentiometer, often connected to ground.<br> • RW is the wiper of the potentiometer. As the wiper value is adjusted via I2C, the resistance between RW and RL/RH changes<br> • RH is the High Terminal
                            of the potentiometer, often connected to your high voltage source.<br> • V+ is the wiper bias pin and is used to bias the gates of the MOSFETs that are responsible for changing the resistance between RW and RH or RL. If the
                            voltage at RH is higher than VCC, V+ must be at the same or higher voltage than RH. By default this is connected with a jumper to RH but you can cut the solder jumper and wire it directly
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Extra Pins</h4>
                    </button>
                    <div class="content">
                        <h5>
                            • A0 and A1 - These are the address select pins.<br> Since you can only have one device with a given address on an I2C bus, there must be a way to adjust the address if you want to put more than one DS3502 on a shared I2C bus.
                            The A0/A1 pins set the bottom two bits of the I2C address. There are pull-down resistors on the board so connect them to VDD, you can solder the back jumpers or wire them on a breadboard, to set the bits to '1'. They are read
                            on power up, so de-power and re-power to reset the address.<br> The default address is 0x28 and the address can be calculated by 'adding' the A0/A1 to the base of 0x28<br> A0 sets the lowest bit with a value of 1, and A1 sets
                            the middle bit with a value of 2. The final address is 0x28 + A1 + A0.<br> • So for example if only A0 is tied to VDD, the address is 0x28 + 1 = 0x29<br> • If only A1 is tied to VDD, the address is 0x28 + 2 = 0x2A<br> • If
                            A1 is tied to VDD and A0 is tied to VDD, the address is 0x28 + 2 + 1 = 0x2B.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Example Code</h4>
                    </button>
                    <div class="content">
                        <h5>1. #include
                            <Adafruit_DS3502.h><br> 2. <br> 3. Adafruit_DS3502 ds3502 = Adafruit_DS3502();<br> 4. /* For this example, make the following connections:<br> 5. * DS3502 RH to 5V<br> 6. * DS3502 RL to GND<br> 7. * DS3502 RW to the pin specified by WIPER_VALUE_PIN<br>                                8. */<br> 9. <br> 10. #define WIPER_VALUE_PIN A0<br> 11. <br> 12. void setup() {<br> 13. Serial.begin(115200);<br> 14. // Wait until serial port is opened<br> 15. while (!Serial) { delay(1); }<br> 16. <br> 17. Serial.println("Adafruit
                                DS3502 Test");<br> 18. <br> 19. if (!ds3502.begin()) {<br> 20. Serial.println("Couldn't find DS3502 chip");<br> 21. while (1);<br> 22. }<br> 23. Serial.println("Found DS3502 chip");<br> 24. }<br> 25. <br> 26. void loop()
                                {
                                <br> 27. Serial.print("Wiper voltage with wiper set to 0: ");<br> 28. ds3502.setWiper(0);<br> 29. float wiper_value = analogRead(WIPER_VALUE_PIN);<br> 30. wiper_value *= 5.0;<br> 31. wiper_value /= 1024;<br> 32. Serial.print(wiper_value);<br>                                33. Serial.println(" V");<br> 34. <br> 35. Serial.println();<br> 36. delay(1000);<br> 37. <br> 38. Serial.print("Wiper voltage with wiper set to 63: ");<br> 39. ds3502.setWiper(63);<br> 40. wiper_value = analogRead(WIPER_VALUE_PIN);<br>                                41. wiper_value *= 5.0;<br> 42. wiper_value /= 1024;<br> 43. Serial.print(wiper_value);<br> 44. Serial.println(" V");<br> 45. <br> 46. Serial.println();<br> 47. delay(1000);<br> 48. <br> 49. Serial.print("Wiper voltage
                                with wiper set to 127: ");<br> 50. ds3502.setWiper(127);<br> 51. wiper_value = analogRead(WIPER_VALUE_PIN);<br> 52. wiper_value *= 5.0;<br> 53. wiper_value /= 1024;<br> 54. Serial.print(wiper_value);<br> 55. Serial.println("
                                V");
                                <br> 56. <br> 57. Serial.println();<br> 58. delay(1000);<br> 59. }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn7"><img class="image" src="8.jpg"></button><br>8 Channel LoRa Gateway Kit comes with Raspberry Pi, LoRa and GPS
            <div id="myModal7" class="modal">
                <div class="modal-content">
                    <span class="close7">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>If you’re building a IoT project and need to send data back-and-forth, the WiFi module built into newer Pi’s should be fine for most cases.<br>But, what if you find WiFi does not have a long range you need? If you’re deploying
                            your project somewhere more remotely, without WiFi or a strong cellular network, like a rural area, you’ll need another option.<br>Something that can be deployed quickly with no overhead setup and that will transmit/receive
                            over a long distance. Enter LoRa (Long Range) Radio – a smart, long-range, wireless transmission technology that enables the future of IoT (Internet of Things) without Cellular fees.<br> This LoRa HAT from RAK Wireless is capable
                            of multi-channel, multi-node communication all running in a non-intimidating, hackable Raspberry Pi environment.<br>Unlike our basic LoRa gateway bonnet, this chipset can support all 8 channels, so it can handle multiple clients,
                            on different LoRa channels, without having to do any code tweaks.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Includes:</h4>
                </button>
                    <div class="content">
                        <h5>• Raspberry Pi 3 B+<br> • 5V 2.5A Switching Power Supply with 20AWG MicroUSB Cable<br> • 915MHz 8-Channel LoRa concentrator + GPS shield<br> • 16GB MicroSD card ready to pop into your Raspberry Pi<br> • Magnetic mount GPS/GNSS
                            antenna 1m with SMA connector<br> • 915 MHz LoRa compatible antenna (2dBi Gain / 50 Ω)<br> • Mounting kit with 4 x brass standoffs & 4 x washers<br> • Sleek and compact anodized enclosure (3 pieces): 68.3 mm x 92 mm x 53.5
                            mm
                            <br> • 8 x 10mm tall screws<br> • 4 x 4.75mm tall screws<br> • 4 x Rubber stoppers<br> Once you have your Internet-to-LoRa gateway set up with this kit, make LoRa nodes using our Feather line for easy deployment of sensor networks
                            that run on battery power. Don’t forge to only use 900 MHz LoRa modules to match up with this transceiver HAT’s frequency.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn8"><img class="image" src="9.jpg"></button><br>KittenBot IO:bit for micro:bit - Version 2.0
            <div id="myModal8" class="modal">
                <div class="modal-content">
                    <span class="close8">&times;</span>
                    <img src="kittenbot-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>This is a low-cost expansion board for Micro:bit, which isspecifically used for the IO ports of Micro:bit. It has taken all the IO resources on the Micro:bit, and also has a buzzer on the board. It is connected to the P0 pin through
                            the jumper cap. The P0 pin can be released using a jumper cap. The small size is very suitable for small projects using Micro:bit.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Small size, very suitable for DIY<br> • All IO ports are extracted<br> • On-board buzzer- you can directly use the music module in MakeCode to play music. At the same time, the 3.5mm audio connector on the board can be connected
                            to audio equipment; such as, headphones to have more creative endeavors.<br> • Two LEGO-compatible pin holes for easy assembly and integration<br> • The 3PIN interface is distinguished by yellow, red, and black. It is created
                            so that plugging it in the wrong way is difficult, and it is convenient to plug in the sensors.<br> • It imitates the 5PIN gold fingers on the Micro:bit. This is convenient for makers who like to use the alligator clips.<br>                            • Compared with IObit1.0, the biggest difference is that it can input and output 5V, support 5V sensor use, and increases the drive capacity (can drive multiple 9g small servos).<br> • Includes 1A self-recovery fuse<br> • Custom-designed
                            silk screen board
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Product parameters:</h4>
                </button>
                    <div class="content">
                        <h5>Length x width x height: 57mmx44mmx12mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical parameters:</h4>
                </button>
                    <div class="content">
                        <h5>
                            • Power supply mode: IobitV.2.0 supports USB5V power supply. This power supply mode requires pressing the blue power switch.<br> • Working voltage: 3V-5V (5V sensor module is not supported under 3V power supply)<br> • Output
                            current: 3V and 5V power interface with maximum output 1A<br> • Serial port extraction: serial port can map IO <br> • I2C port leads: pins 19 and 20 can only be used as I2C function pins. They cannot be read and written as
                            ordinary IO ports, because Micro:bit bottom is dead.<br> • Spi port leads; 14, 15 (IO port can be read and written).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Introduction to IObit hardware:</h4>
                </button>
                    <div class="content">
                        <h5>5V power:- Insert the USB power supply (5V 1A) as shown in Figure 1. Press the blue button at 2, and the red indicator light at 3 will light up. You can use the left 5V interface.<br> P0 buzzer:- Toggle switch to turn off the buzzer
                            function (see the silk screen on the back of the board for status)<br> 3Pin IO port leads:- All the pins in the Micro:bit have been taken out without any reservation (Note: there are no P17 and P18 on the Micro:bit, it’s not
                            that the IObit is not taken out)<br> Yellow corresponds to the different IO pins<br> Red corresponds to 3.3V/5V (with silkscreen)<br> Black corresponds to GND<br> 5PIN gold fingers:- The gold fingers of the Micro:bit are used
                            to draw 3v, gnd, P1, P2, and P3 respectively. This is for users who prefer to use alligator clips<br> 40P Micro:- bit horizontal socket<br> Compact size socket<br> Board mounting holes and fixing:-> The two outermost holes
                            are approximately 4.8 mm in diameterand are compatible with Lego friction pins with a spacing of 48mm.<br> 3.5mm audio interface:- You can plug in a 3.5mm jack audio device and play the sound of the P0 pin.
                        </h5>
                    </div>
                    <img src="kittenbot-pinout1.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>IObit programming use:</h4>
                </button>
                    <div class="content">
                        <h5>
                            If you haven’t gotten started with Micro:bit, first get started with Micro:bit, this is the operating premise.<br> Use music blocks directly in MakeCode to CQ0056.<br> P0 pin is<br> If you use P0, remember to turn the buzzer
                            toggle switch off (because the buzzer is combined with P0)<br> • When using the Micro:bit power supply, IObit IO port drive capability is very weak, IO port current is less than 200mA, please do not connect high current devices
                            (such as large servo MG995, DC motor), otherwise it will burn out the Micro:bit , you must fully understand before using what the device current conditions needed<br> • When using a 5V external power supply, you can drive multiple
                            small servos, but please note that the maximum current is 1A!<br> • If you use the high-low read function of the pin, you must set the pull-down on the pin. <br> • If P0 is used as a normal IO port, the buzzer toggle switch
                            must be turned off, otherwise the buzzer will sound or the IO read value will be abnormal.<br> • Use the shared pin with the Micro:bit dot matrix (such as 3, 4, 5, 6, 7, 8, 9, 10, 11), remember to disable the dot matrix screen
                            on the software, otherwise it will be a bit of a screen burst<br> • Do not use IO19, 20. 19 and 20 cannot be used as an IO port. Although the display on the MakeCode software can be used, it is actually not used! It can only
                            be used for I2C communication<br> • The USB port allows a maximum input current of 1A.<br> • Do not place it on a metal surface to avoid short circuit
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn9"><img class="image" src="10.jpg"></button><br>Electric Heating Pad
            <div id="myModal9" class="modal">
                <div class="modal-content">
                    <span class="close9">&times;</span>
                    <button class="collapsible">
                                <h4>Description:</h4>
                            </button>
                    <div class="content">
                        <h5>This is hot! Literally! Apply 5-12VDC and the stainless steel fibers in this heating fabric will warm up, creating a little heating pad. On one hand, it's just a gigantic resistor. On the other hand, it's flexible, light, and can
                            be wrapped around a project. Originally designed for portable wearable heating pads, this fabric can be used for wearables, weather balloons, diy-bio projects, thermal cycling for materials testing, etc. The temperature reached
                            varies with voltage. This piece is ~ 10cm long, so look in the spec sheets in the Technical Details tab for a table of voltage/current/temperature outputs.
                        </h5>
                    </div>
                    <button class="collapsible">
                                <h4>Technical Details:</h4>
                            </button>
                    <div class="content">
                        <h5>T• Dimensions: 110.65mm / 4.35" x 70.45mm / 2.77" x 1.54mm / 0.06"<br> • Wire Length: 35.8mm / 1.4"<br> • Weight: 2.53g<br> • Insulation: Polyimide film ('Kapton')<br> • Fabric made of Polyester filament and micro stainless steel
                            fiber
                            <br> • Power requirements: 5V DC up to 1A
                        </h5>
                    </div>
                    <button class="collapsible">
                                <h4>Design References:</h4>
                            </button>
                    <div class="content">
                        <h5>Testing conditions:<br> (1)The width of the Ultra Heating Fabric is 5 cm<br> (2)The diameter of metal-polymer composite conductive yarn is about 0.27 mm<br> (3)The pitch of the conductive yarn in the Fabric is about 5 mm
                            <br> (4)The input voltage to the Fabric is 5, 7.4, 9, 12 Voltage, respectively.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn10"><img class="image" src="11.jpg"></button><br>Adafruit Feather nRF52840 Express
            <div id="myModal10" class="modal">
                <div class="modal-content">
                    <span class="close10">&times;</span>
                    <button class="collapsible">
                    <h4>Special Notes:</h4>
                </button>
                    <div class="content">
                        <h5>The following pins have some restrictions that need to be taken into account when using them:<br> • D2/NFC2: The D2 pin is uses the same pad as one-half of the NFC antenna pins. By default, the nRF52840 Feather ships with these
                            pins configured for GPIO mode, which is done by writing a value to the UICR flash config memory. If you wish to use NFC, you will need to erase the UICR memory which requires erasing the entire chip, and you will need a Segger
                            J-Link to reflash the bootloader and firmware.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Power Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• 3V: This pin is connected to the output of the on board 3.3V regulator. It can be used to supply 3.3V power to external sensors, breakouts or Feather Wings.<br> • LIPO Input (Bat): This is the voltage supply off the optional
                            LIPO cell that can be connected via the JST PH connector. It is nominally ~3.5-4.2V.<br> • VREG Enable (En): This pin can be set to GND to disable the 3.3V output from the on board voltage regulator. By default it is set high
                            via a pullup resistor.<br> • USB Power (USB): This is the voltage supply off USB connector, nominally 4.5-5.2V.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Analog Inputs:</h4>
                </button>
                    <div class="content">
                        <h5>The 6 available analog inputs (A0 .. A5) can be configured to generate 8, 10 or 12-bit data (or 14-bits with over-sampling), at speeds up to 200kHz (depending on the bit-width of the values generated), based on either an internal
                            0.6V reference or the external supply.<br> The following default values are used:<br> • Default voltage range: 0-3.6V (uses the internal 0.6V reference with 1/6 gain)<br> • Default resolution: 12-bit (0..4096)<br> • Default
                            mV per lsb (assuming 3.6V and 12-bit resolution): 1 LSB = 0.87890625 mV<br> An additional two ADC pins are available but pre-connected to provide specific functionality:<br> • AREF (A7 / P0.31), which can be used as an optional
                            external analog reference. This pin can be accessed in code via PIN_AREF or A7. If using an external AREF, this must be less than or equal to VDD, which is usually 3.3V!<br> • VDIV (A6 / P0.29): This pin is hard wired to a
                            voltage-divider on the LIPO battery input, allowing you to safely measure the LIPO battery level on your device. If possible, you should avoid using this pin as an input because you will lose the ability to read the battery
                            voltage. You can use it as an output just make sure to switch the pin to analog input when you want to do the battery read, then back to output when toggling pins.<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PWM Outputs:</h4>
                </button>
                    <div class="content">
                        <h5>Any GPIO pin can be configured as a PWM output, using the dedicated PWM block. Three PWM modules can provide up to 12 PWM channels with individual frequency control in groups of up to four channels.
                        </h5>
                    </div>
                    <img src="nrf52840-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>I2C Pins:</h4>
                </button>
                    <div class="content">
                        <h5>I2C pins on the nRF52840 require external pullup resistors to function, which are not present on the Adafruit nRF52840 Feather by default. You will need to supply external pullups to use these. All Adafruit I2C breakouts have appropriate
                            pullups on them already, so this normally won't be an issue for you.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>User/DFU Switch:</h4>
                </button>
                    <div class="content">
                        <h5>A tactile switch is provided for use in your projects, which is connected to P1.02 and is accessible in code as D7. Holding this button down coming out of a board reset will also force the device to enter and remain in USB bootloader
                            mode, which can be useful if you lock your board up with bad application code!
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>SWD Connector:</h4>
                </button>
                    <div class="content">
                        <h5>For advanced debugging or to reprogram your nRF52840 Feather Express, a 2*5 pin 0.05" standard SWD header is populated on the boards. This allows you to use something like a Segger J-Link and a 1.27mm SWD cable to connect from
                            your PC to the nRF52840.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Basic LEDs:</h4>
                </button>
                    <div class="content">
                        <h5>There are three basic LEDs available on the nRF52840 Feather Express:<br> • D3 is a general-purpose RED LED that can be used for blinky, or other purposes. When running in bootloader mode it is used under the control of the bootloader
                            as a status indicator, with a rapid blinky pattern indicating that the board is currently in DFU bootloader mode. This LED is on D3 (or P1.15). Programmatically you can access this LED as LED_RED.<br> • CONN can be used as
                            a general-purpose BLUE LED, but is generally controlled by the examples to indicate connection status for BLE. This LED is on P1.10. Programmatically you can access this LED as LED_BLUE.<br> • CHG indicates that the on-board
                            LIPO charger is currently charging the connected LIPO battery cell, using USB as a power supply.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn11"><img class="image" src="12.jpg"></button><br>Stacking Headers for Feather
            <div id="myModal11" class="modal">
                <div class="modal-content">
                    <span class="close11">&times;</span>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>These two Female Stacking Headers alone are, well, lonely. But pair them with any of our Feather boards and you're in business! What do they do? They stack. Put the headers through your Feather and then you can not only plug them
                            into a solderless breadboard, but you could attach circuitry on top as well Note: Comes with one 12-pin and one 16-pin header, Feathers not included.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn12"><img class="image" src="13.jpg"></button><br>Header Kit for Feather
            <div id="myModal12" class="modal">
                <div class="modal-content">
                    <span class="close12">&times;</span>
                    <button class="collapsible">
                    <h4>Header Kit for Feather - 12-pin and 16-pin:</h4>
                </button>
                    <div class="content">
                        <h5>These two Female Headers alone are, well, lonely. But pair them with any of our Feather boards and you're in business! What do they do? They get soldered on either side of the Feather board.<br>Now you can plug in FeatherWings
                            to add more capability to your portable project. Unlike our Feather Stacking Headers, they aren't designed to 'stack', but they're more compact. Note: Comes with one 12-pin and one 16-pin header, Feathers not included.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn13"><img class="image" src="joystick.jpg"></button><br>Joystick Module
            <div id="myModal13" class="modal">
                <div class="modal-content">
                    <span class="close13">&times;</span>
                    <img src="Joystick-Module-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Gnd</th>
                                    <th>Ground terminal of Module</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>+5v</th>
                                    <th>Positive supply terminal of Module</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>VRx</th>
                                    <th>Voltage Proportional to X axis</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>VRy</th>
                                    <th>Voltage Proportional to Y axis</th>
                                </tr>
                                <tr>
                                    <th>5</th>
                                    <th>SW</th>
                                    <th>Switch</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Two independent Potentiometer: one for each axis ( X and Y)<br> • Auto return to center position<br> • Low weight<br> • Cup-type Knob<br> • Compatible to interface with Arduino or with most microcontrollers
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage: 5V<br> • Internal Potentiometer value: 10k<br> • 2.54mm pin interface leads<br> • Dimensions: 1.57 in x 1.02 in x 1.26 in (4.0 cm x 2.6 cm x 3.2 cm)<br> • Operating temperature: 0 to 70 °C
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Internal Structure:</h4>
                </button>
                    <div class="content">
                        <h5>The below image is the internal diagram of a Joystick Module. It consists of two Potentiometer, each for one axis (X and Y). Both 10k potentiometer are independent to move in their particular direction. SW (Switch) pin is connected
                            to a push button internally.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where Joysticks Are Used?:</h4>
                </button>
                    <div class="content">
                        <h5>When we listen the word “Joystick” we think of Game controllers. If we talk about Electronics there are many useful application of Joystick. These type of module are mostly used in Arduino based DIY projects and Robot Control.
                            As we know, the module gives analog output so it can be used for feeding the analog input based on direction or movement. It can also be connected to a movable camera to control its movement.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use Joystick?:</h4>
                </button>
                    <div class="content">
                        <h5>We can use a Joystick Module with Arduino, Raspberry Pi and any other Micro-controllers. We just have to connect the axis Pins VRx and VRy to the ADC Pins of the micro-controller. If you want to use the switch then connect it to
                            the digital Pin of the Micro-controller. Follow the below block diagram to connect Joystick Module with Microcontroller.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Application:</h4>
                </button>
                    <div class="content">
                        <h5>• Camera Pan/Tilt Control<br> • Game Input/Control<br> • Robot Control<br> • Analog Input of Parameters<br> • Widely use in DIY projects
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn14"><img class="image" src="dht-11.jpg"></button><br>DHT11
            <div id="myModal14" class="modal">
                <div class="modal-content">
                    <span class="close14">&times;</span>
                    <img src="DHT11–Temperature-Sensor-Pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Identification and Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>Power supply 3.5V to 5.5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Data</th>
                                    <th>Outputs both Temperature and Humidity through serial Data</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>NC</th>
                                    <th>No Connection and hence not used</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Ground</th>
                                    <th>Connected to the ground of the circuit</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>Power supply 3.5V to 5.5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Data</th>
                                    <th>Outputs both Temperature and Humidity through serial Data</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Ground</th>
                                    <th>Connected to the ground of the circuit</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>DHT11 Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage: 3.5V to 5.5V<br> • Operating current: 0.3mA (measuring) 60uA (standby)<br> • Output: Serial data<br> • Temperature Range: 0°C to 50°C<br> • Humidity Range: 20% to 90%<br> • Resolution: Temperature and Humidity
                            both are 16-bit<br> • Accuracy: ±1°C and ±1%<br> Note: The DHT11 datasheet can be found at the bottom of the page.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>DHT11 Equivalent Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>DHT22, AM2302, SHT71
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Other Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>Thermocouple, TMP100, LM75, DS18820, SHT15, LM35DZ, TPA81, D6T
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Difference between DHT11 Sensor and module:</h4>
                </button>
                    <div class="content">
                        <h5>The DHT11 sensor can either be purchased as a sensor or as a module.<br>Either way, the performance of the sensor is same. The sensor will come as a 4-pin package out of which only three pins will be used whereas the module will
                            come with three pins as shown above.<br> The only difference between the sensor and module is that the module will have a filtering capacitor and pull-up resistor inbuilt, and for the sensor, you have to use them externally
                            if required.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use DHT11:</h4>
                </button>
                    <div class="content">
                        <h5>The DHT11 is a commonly used Temperature and humidity sensor. The sensor comes with a dedicated NTC to measure temperature and an 8-bit microcontroller to output the values of temperature and humidity as serial data.<br>The sensor
                            is also factory calibrated and hence easy to interface with other microcontrollers.<br> The sensor can measure temperature from 0°C to 50°C and humidity from 20% to 90% with an accuracy of ±1°C and ±1%. So if you are looking
                            to measure in this range then this sensor might be the right choice for you.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use DHT11 Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The DHT11 Sensor is factory calibrated and outputs serial data and hence it is highly easy to set it up. The connection diagram for this sensor is shown below.<br> As you can see the data pin is connected to an I/O pin of the MCU
                            and a 5K pull-up resistor is used. This data pin outputs the value of both temperature and humidity as serial data. If you are trying to interface DHT11 with Arduino then there are ready-made libraries for it which will give
                            you a quick start.<br> If you are trying to interface it with some other MCU then the datasheet given below will come in handy. The output given out by the data pin will be in the order of 8bit humidity integer data + 8bit
                            the Humidity decimal data +8 bit temperature integer data + 8bit fractional temperature data +8 bit parity bit.<br>To request the DHT11 module to send these data the I/O pin has to be momentarily made low and then held high
                            as shown in the timing diagram below.<br> The duration of each host signal is explained in the DHT11 datasheet, with neat steps and illustrative timing diagrams.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Measure temperature and humidity<br> • Local Weather station<br> • Automatic climate control<br> • Environment monitoring
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn15"><img class="image" src="dht-22.jpg"></button><br>DHT22
            <div id="myModal15" class="modal">
                <div class="modal-content">
                    <span class="close15">&times;</span>
                    <img src="DHT22-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Identification and Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For DHT22 Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>Power supply 3.5V to 5.5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Data</th>
                                    <th>Outputs both Temperature and Humidity through serial Data</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>NC</th>
                                    <th>No Connection and hence not used</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Ground</th>
                                    <th>Connected to the ground of the circuit</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For DHT22 Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>Power supply 3.5V to 5.5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Data</th>
                                    <th>Outputs both Temperature and Humidity through serial Data</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Ground</th>
                                    <th>Connected to the ground of the circuit</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>DHT22 Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage: 3.5V to 5.5V<br> • Operating current: 0.3mA (measuring) 60uA (standby)<br> • Output: Serial data<br> • Temperature Range: -40°C to 80°C<br> • Humidity Range: 0% to 100%<br> • Resolution: Temperature and Humidity
                            both are 16-bit<br> • Accuracy: ±0.5°C and ±1%<br> Note: The DHT22 datasheet can be found at the bottom of the page
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>DHT22 Equivalent Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>DHT11, AM2302, SHT71
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Other Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>
                            Thermocouple, TMP100, LM75, DS18820, SHT15, LM35DZ, TPA81, D6T
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Difference between DHT22 Sensor and Module:</h4>
                </button>
                    <div class="content">
                        <h5>
                            The DHT22 sensor is the successor of the DHT11 module, it can either be purchased as a sensor or as a module. Either way the performance of the sensor is same. The sensor will come as a 4-pin package out of which only three pin will be used whereas the
                            module will come with just three pins as shown in the DHT22 pinout above.<br> The only difference between the sensor and module is that the module will have a filtering capacitor and pull-up resistor
                            inbuilt, and for the sensor you have to use them externally if required.<br> The module is slightly costly than the DHT11, but it has a higher measuring range and slightly better accuracy .
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where DHT22 Sensor is Used:</h4>
                </button>
                    <div class="content">
                        <h5>
                            The DHT22 is a commonly used Temperature and humidity sensor. The sensor comes with a dedicated NTC to measure temperature and an 8-bit microcontroller to output the values of temperature and humidity as serial data.<br>The
                            sensor is also factory calibrated and hence easy to interface with other microcontrollers.<br> The sensor can measure temperature from -40°C to 80°C and humidity from 0% to 100% with an accuracy of ±1°C and ±1%. So if you are
                            looking to measure in this range then this sensor might be the right choice for you.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use DHT22 Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>
                            The DHT22 Sensor is factory calibrated and outputs serial data and hence it is highly easy to set it up. The connection diagram for this sensor is shown below.<br> As you can see the data pin is connected to an I/O pin of the
                            MCU and a 5K pull up resistor is used.<br>This data pin outputs the value of both temperature and humidity as serial data. If you are trying to interface DHT22 with Arduino Uno then there are ready made libraries for it which
                            will give you a quick start.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>
                            • Measure temperature and humidity<br> • Local Weather station<br> • Automatic climate control<br> • Environment monitoring
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn16"><img class="image" src="relay.jpg"></button><br>5v Relay Module
            <div id="myModal16" class="modal">
                <div class="modal-content">
                    <span class="close16">&times;</span>
                    <img src="relay-1-channel.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino is a microcontroller based prototyping board that runs on small DC power. A Relay is a device that helps microcontrollers (or microcontroller based boards) like Arduino to switch on or off different household appliances
                            like motors, lights, water heaters, television and fans etc.<br> Today, Arduino is being used for a wide range of applications like controlling LEDs, monitoring temperature, logging data and turning on motors etc.<br>Another
                            important task that can be accomplished by the Arduino is controlling a 5V Relay to operate high voltage AC appliances and devices.<br> Arduino family of microcontrollers, like UNO, Nano and Mega etc. can be programmed to control
                            a simple 5V relay i.e. switch it on or off on the event of pushing a button, reading the value of temperature from a thermistor or just by setting up a predefined timer.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Required Components to connect relay with arduino:</h4>
                </button>
                    <div class="content">
                        <h5>• Arduino UNO (or any other Arduino board)<br> • 5V Relay<br> • 1N4007 Diode<br> • BC547 – NPN Transistor<br> • Red LED (can be used as a Power ON LED)<br> • Green LED (can be used as a Relay ON LED)<br> • 2 x 1K Ohm Resistors
                            (1/4 W – for Red and Green LEDs)<br> • Lamp<br> • Wires for connecting DC Voltage components<br> • Wires for connecting AC Mains and lamp
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code:</h4>
                </button>
                    <div class="content">
                        <h5> const int relay=8;<br> const int Ainput=A0;<br> int ldrValue = 0;<br> int range = 0;<br> void setup()<br> {
                            <br> pinMode(relay,OUTPUT);
                            <br> digitalWrite(relay,HIGH); // My Relay is an active LOW Relay.<br> Serial.begin(9600);
                            <br> }
                            <br> void loop()<br> {
                            <br> ldrValue = analogRead(Ainput);<br> range = map(ldrValue, 0, 1023, 0, 255);<br> Serial.println(range);
                            <br> if(range>125)
                            <br> digitalWrite(relay,LOW);
                            <br> else
                            <br> digitalWrite(relay,HIGH);
                            <br> }
                        </h5>
                    </div>
                    <img src="5V-Relay.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Advantages and Disadvantages:</h4>
                </button>
                    <div class="content">
                        <h5>
                            Advantages:-<br>The main and important advantage of connecting a 5V relay with Arduino is that it can be powered by Arduino itself.<br> Disadvantages:-
                            <br>A transistor based relay might not be ideal for long time use as there will always be noise in the relay coil. A suitable option will be using additional isolation like an opto-isolator or completely eliminating the electromechanical
                            relay and replacing it with solid state relay.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>
                            • Interfacing a 5V Relay with Arduino opens up the door to a huge number of applications. Although the main task of the relay is to control a load, how that relay is being operated by the Arduino makes it an interesting project.<br>                            • Some of the techniques and methods using which we can control the relay are: Bluetooth, Infrared (IR) remote, RF Transmitter – Receiver Pair or even using Internet.<br> • Arduino based Home Automation requires the combination
                            of Arduino and many relay module (depending on the number of loads).
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn17"><img class="image" src="ultrasonic-sensor.jpg"></button><br>Ultrasonic Sensor HC-SR04
            <div id="myModal17" class="modal">
                <div class="modal-content">
                    <span class="close17">&times;</span>
                    <img src="Ultrasonic-sensor-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Ultrasonic Sensor Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>The Vcc pin powers the sensor, typically with +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Trigger</th>
                                    <th>Trigger pin is an Input pin. This pin has to be kept high for 10us to initialize measurement by sending US wave.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Echo</th>
                                    <th>Echo pin is an Output pin. This pin goes high for a period of time which will be equal to the time taken for the US wave to return back to the sensor.</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Ground</th>
                                    <th>This pin is connected to the Ground of the system.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>HC-SR04 Sensor Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating voltage: +5V<br> • Theoretical Measuring Distance: 2cm to 450cm<br> • Practical Measuring Distance: 2cm to 80cm<br> • Accuracy: 3mm<br> • Measuring angle covered: less than 15°<br> • Operating Current: less than 15mA<br>                            • Operating Frequency: 40Hz
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Equivalent distance measuring Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>US transmitter Receiver pair, IR sensor module, IR sensor pair, IR Analog distance sensor,
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>HC-SR04 Ultrasonic Sensor - Working:</h4>
                </button>
                    <div class="content">
                        <h5>As shown above the HC-SR04 Ultrasonic (US) sensor is a 4 pin module, whose pin names are Vcc, Trigger, Echo and Ground respectively. This sensor is a very popular sensor used in many applications where measuring distance or sensing
                            objects are required. The module has two eyes like projects in the front which forms the Ultrasonic transmitter and Receiver. The sensor works with the simple high school formula that Distance = Speed × Time.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Used to avoid and detect obstacles with robots like biped robot, obstacle avoider robot, path finding robot etc.<br> • Used to measure the distance within a wide range of 2cm to 400cm<br> • Can be used to map the objects surrounding
                            the sensor by rotating it<br> • Depth of certain places like wells, pits etc can be measured since the waves can penetrate through water
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn18"><img class="image" src="metal-touch-sensor.jpg"></button><br>KY-036 Metal-touch sensor module
            <div id="myModal18" class="modal">
                <div class="modal-content">
                    <span class="close18">&times;</span>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>Outputs a signal if the metal pike of the Sensor was touched. You can adjust the sensitivity of the sensor with the controller.<br> Digital Out: At the moment of contact detection, a signal will be outputted.<br> Analog Out: Direct
                            measuring value of the sensor unit.<br> LED1: Shows that the sensor is supplied with voltage <br> LED2: Shows that the sensor detects a magnetic field
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Functionality of the sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The sensor has 3 main components on its circuit board. First, the sensor unit at the front of the module which measures the area physically and sends an analog signal to the second unit, the amplifier.<br>The amplifier amplifies
                            the signal, according to the resistant value of the potentiometer, and sends the signal to the analog output of the module.<br> The third component is a comparator which switches the digital out and the LED if the signal falls
                            under a specific value. <br> You can control the sensitivity by adjusting the potentiometer.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code:</h4>
                </button>
                    <div class="content">
                        <h5>// Declaration and initialization of the input pin<br> int Analog_Eingang = A0; // X-axis-signal<br> int Digital_Eingang = 3; // Button<br> void setup ()<br> {
                            <br> pinMode (Analog_Eingang, INPUT);<br> pinMode (Digital_Eingang, INPUT);<br> Serial.begin (9600); // Serial output with 9600 bps<br> }
                            <br> // The program reads the current value of the input pins<br> // and outputs it via serial out <br> void loop ()<br> {
                            <br> float Analog;<br> int Digital;<br> // Current value will be read and converted to the voltage<br> Analog = analogRead (Analog_Eingang) * (5.0 / 1023.0);<br> Digital = digitalRead (Digital_Eingang);<br> // and outputted
                            here
                            <br> Serial.print ("Analog voltage value:");<br>Serial.print (Analog, 4);<br>Serial.print ("V, ");<br> Serial.print ("Extreme value:");<br> if(Digital==1)
                            <br> {
                            <br> Serial.println (" reached");<br> }
                            <br> else
                            <br> {
                            <br> Serial.println (" not reached yet");<br> }
                            <br> Serial.println ("----------------------------------------------------------------");<br> delay (200);<br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>digital Signal = [Pin 3]<br> +V = [Pin 5V]<br> GND = [Pin GND]<br> analog Signal = [Pin 0]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections Raspberry Pi:</h4>
                </button>
                    <div class="content">
                        <h5>Sensor<br> digital Signal = GPIO 24 [Pin 18 (RPi)]<br> +V = 3,3V [Pin 1 (RPi)]<br> GND = GND [Pin 06 (RPi)]<br> analog Signal = Analog 0 [Pin A0 (ADS1115 - KY-053)]<br> ADS1115 - KY-053:<br> VDD = 3,3V [Pin 01]<br> GND = GND [Pin
                            09]
                            <br> SCL = GPIO03 / SCL [Pin 05]<br> SDA = GPIO02 / SDA [Pin 03]<br> A0 = look above [Sensor: analog signal]
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn19"><img class="image" src="flame-sensor.jpg"></button><br>IR Flame Sensor Module
            <div id="myModal19" class="modal">
                <div class="modal-content">
                    <span class="close19">&times;</span>
                    <img src="Arduino-Flame-Sensor.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A flame sensor module that consists of a flame sensor (IR receiver), resistor, capacitor, potentiometer, and comparator LM393 in an integrated circuit.<br>It can detect infrared light with a wavelength ranging from 700nm to 1000nm.The
                            far-infrared flame probe converts the light detected in the form of infrared light into current changes.<br>Sensitivity is adjusted through the onboard variable resistor with a detection angle of 60 degrees.<br> Working voltage
                            is between 3.3v and 5.2v DC, with a digital output to indicate the presence of a signal. Sensing is conditioned by an LM393 comparator.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>// Flame Sensor Module<br> int LED = 13; // Use the onboard Uno LED<br> int isFlamePin = 7; // This is our input pin<br> int isFlame = HIGH; // HIGH MEANS NO FLAME<br> void setup() {<br> pinMode(LED, OUTPUT);<br> pinMode(isFlamePin,
                            INPUT);
                            <br> Serial.begin(9600);
                            <br> }
                            <br> void loop() {<br> isFlame = digitalRead(isFlamePin);<br> if (isFlame== LOW)<br> {
                            <br> Serial.println("FLAME, FLAME, FLAME");<br> digitalWrite(LED, HIGH);<br> }
                            <br> else
                            <br> {
                            <br> Serial.println("no flame");<br> digitalWrite(LED, LOW);<br> }
                            <br> }
                            <br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Verify Operation of the Flame Detector Module and Adjust Sensitivity:</h4>
                </button>
                    <div class="content">
                        <h5>Open the Serial Monitor on your Arduino program.Move a flame in and out of the viewing angle of the sensor.You should see an output that looks something like the picture below.<br>You should also see the red LED illuminate on your
                            module and you should see also see the module LED connected to pin 13 of your Arduino light up.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Components Required to connect with arduino:</h4>
                </button>
                    <div class="content">
                        <h5>• Arduino UNO<br> • Flame Sensor<br> • 2N2222 NPN Transistor (or BC548)<br> • 5V Buzzer<br> • 1N4007 PN Junction Diode<br> • 1KΩ Resistor<br> • Connecting Wires<br> • Mini Breadboard<br> • Power Supply
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn20"><img class="image" src="rgb-led.jpg"></button><br>RGB 3 Color LED Module
            <div id="myModal20" class="modal">
                <div class="modal-content">
                    <span class="close20">&times;</span>
                    <img src="rgb-3color led.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>RGB LED module consists of a plug-in full color LED made by R, G, B three pin PWM voltage input can be adjusted Section three primary colors (red / blue / green) strength in order to achieve full color mixing effect. Control of
                            the module with the Arduino can be achieved Cool lighting effects.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5> the use of plug-in full-color LED<br>  RGB trichromatic limiting resistor to prevent burnout<br>  through the PWM adjusting three primary colors can be mixed to obtain different colors<br>  with a variety of single-chip interface<br>                             the working voltage: 5V<br>  LED drive mode: common cathode driver
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Schematic:</h4>
                </button>
                    <div class="content">
                        <h5> Arduino pin 11 --> Pin R module<br>  Arduino pin 10 --> Pin G module<br>  Arduino pin 9 --> Pin B module<br>  Arduino pin GND --> Pin - module
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>//KY016 3-color LED module<br> int redpin = 11; // select the pin for the red LED<br> int bluepin = 10; // select the pin for the blue LED<br> int greenpin = 9 ;// select the pin for the green LED<br> int val;<br> void setup ()
                            {
                            <br> pinMode (redpin, OUTPUT);<br> pinMode (bluepin, OUTPUT);<br> pinMode (greenpin, OUTPUT);<br> Serial.begin (9600);<br> }
                            <br> void loop ()<br> {
                            <br> for (val = 255; val> 0; val --)<br> {
                            <br> analogWrite (11, val);<br> analogWrite (10, 255-val);<br> analogWrite (9, 128-val);<br> delay (10);<br> Serial.println (val, DEC);<br> }
                            <br> for (val = 0; val
                            < 255; val ++)<br>
                                {<br> analogWrite (11, val);<br> analogWrite (10, 255-val);<br> analogWrite (9, 128-val);<br> delay (10);<br> Serial.println (val, DEC);<br> }
                                <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn21"><img class="image" src="leds.jpg"></button><br>LEDS
            <div id="myModal21" class="modal">
                <div class="modal-content">
                    <span class="close21">&times;</span>
                    <button class="collapsible">
                    <h4>3mm LED Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>LEDs are available in a variety of sizes and shapes including the 3mm LED. We carry a wide assortment of the most common models of 3mm, 5mm, 8mm and 10mm models.<br> The size refers to the outside diameter of the LED. 3mm LEDs
                            are the smallest and used in tight-fitting applications, while 8mm and 10mm models are used where you want to get out as much light as possible.<br> Super bright 3mm LEDs are extremely bright good for use in your projects,
                            illuminations, headlamps, spotlights, car lighting, models.<br> 3mm LEDs can be used anywhere where you need low power, high-intensity reliable lighting or indication. They go easily into a breadboard and will add that extra
                            zing to your project.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>5mm LED Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>LEDs are available in a variety of sizes and shapes including the 5mm LED. We carry a wide assortment of the most common models of 3mm, 5mm, 8mm and 10mm models.<br> The size refers to the outside diameter of the LED, with the
                            5mm LED being the industry standard as the most common LED model.<br>3mm LEDs are the smallest and used in tight-fitting applications, while 8mm and 10mm models are used where you want to get out as much light as possible.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection:</h4>
                </button>
                    <div class="content">
                        <h5>The longer lead indicates the anode, the lead frame arrangement and “cathode flat” on the case flange may be reversed for some LEDs, always use the longer lead as the anode or test the devices first.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn22"><img class="image" src="rgb-led-strip.jpg"></button><br>RGB LED Strips
            <div id="myModal22" class="modal">
                <div class="modal-content">
                    <span class="close22">&times;</span>
                    <img src="NeoPixel-LED-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The NeoPixel LEDs are RGB LED lights with a built driver IC that makes these lights addressable and programmable.<br>The idea was originally coined by Adafruit and since then there are many types of Neo pixels of varying sizes
                            and shapes available in the market.<br>In this article we will focus only on the strip type flexible Neo Pixels which are commonly available and most used. The picture and pinouts of a NeoPixel LED is shown above.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>NeoPixel Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This powers the LED with 5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Data</th>
                                    <th>This is the Data in pin which is provided with PWM signal</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Ground</th>
                                    <th>Connected to the ground of the circuit.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>NeoPixel LED Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Individually addressable and programmable RGB LEDs<br> • Flexible and available in different form factors<br> • Operating voltage: 3.3V to 5V<br> • Power consumption: 60mA per LED at full brightness<br> • Communication: PWM through
                            data pin<br> • Driver IC: WS2812<br> • Available in many different packages and form factors
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Types of Neo Pixels:</h4>
                </button>
                    <div class="content">
                        <h5>RGB and RGBW strip type, Ring type, SMD type, Through hole type, Matrices, Arduino/Pi shield type, stick type, Jewel type and wearable type.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use Neo Pixels?:</h4>
                </button>
                    <div class="content">
                        <h5>The Neo pixels are small in size with less circuitry and almost no messy wires since the driver IC is embedded into each LED.<br>Each LED has a minimum of RGB light and hence they can be combined to get almost any colour of your
                            choice. This makes it a very good choice for wearable electronics and other decorative lights.<br> Each LED on this strip can be individually addressed and programmed, meaning each LED can be set to glow in a different colour.<br>Also
                            you can add as many leds in series as you like at control all of them with a single controller. I personally have seen LED strips having upto 200+ LEDS, the only constrain is the power and RAM of your controller.<br>If you
                            are using a controller like Arduino, then Adafruit has a library readily available using which these LED can be easily programmed.<br>So if you are looking for easy to use programmable LED light then NeoPixels are what you
                            are looking for.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Wearable electronics<br> • Linear clock<br> • Mood Lamp<br> • Digital Posters<br> • Electronic/Digital advertisements
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn23"><img class="image" src="line-following-sensor.jpg"></button><br>TCRT5000 Tracking Line Follower Sensor
            <div id="myModal23" class="modal">
                <div class="modal-content">
                    <span class="close23">&times;</span>
                    <img src="tcrt5000.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>The TCRT5000 and TCRT5000L are reflective sensors which include an infrared emitter and phototransistor in a leaded package which blocks visible light. The package includes two mounting clips. TCRT5000L is the long lead version.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features & Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Active InfraRed (IR) reflection sensor. • Purpose: o Can be used for detection of distance to a nearby object o Can also be used to sense the difference between light and dark colours and hence be used in vehicular robotic competition
                            where one has to follow a line/grid on the floor. • Power supply: 3.3V to 5VDC • Supply Current:
                            < 9mA (when the onboard SMD LED is off) • Output: Open collector output capable of sinking upto 20mA of current - Active Low Logic • Connector: 4 Pin 0.1 inch pitch header for power & digital output (Vcc, Gnd, DO, AO) • AO is the analog output • The digital
                                output (DO) is like an alarm which goes on when the distance to the object or light reflected off the object reaches a specific value. • Adjustment: Activation threshold can be adjusted via the onboard multi-turn potentiometer
                                • PCB Dimensions: 32mm x 14mm (not including the protruding connector) • Height of components: upto 10 mm on component side. The sensor is mounted on back side. • Mounting hole: Single of 1/8 inch diameter </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn24"><img class="image" src="LINEAR-HALL-SENSOR22.jpg"></button><br>Linear Magnetic Hall Sensor
            <div id="myModal24" class="modal">
                <div class="modal-content">
                    <span class="close24">&times;</span>
                    <img src="ky024.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-024 Linear magnetic Hall sensor reacts in the presence of a magnetic field.<br>It has a potentiometer to adjust the sensitivity of the sensor and it provides both analog and digital outputs.<br> The digital output acts as
                            a switch that will turn on/off when a magnet is near, similar to the KY-003. On the other hand, the analog output can measure the polarity and relative strength of the magnetic field.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-024 module consists of a 49E Linear Hall-Effect Sensor, a LM393 Dual Differential Comparator, a potentiomenter, two leds and six resistors. It's compatible with popular electronics platforms like Arduino, Raspberry Pi, Esp8266
                            and Teensy. Operating Voltage 2.7V to 6.5V<br> Sensitivity 1.0 mV/G min., 1.4 mV/G typ., 1.75 mV/G max.<br> Board Dimensions 1.5cm x 3.6cm [0.6in x 1.4in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int led = 13 ; // LED on arduino<br> int digitalPin = 3; // linear Hall magnetic sensor digital interface<br> int analogPin = A0; // linear Hall magnetic sensor analog interface<br> int digitalVal ; // digital readings<br> int
                            analogVal; // analog readings<br> void setup ()<br> {
                            <br> pinMode (led, OUTPUT);<br> pinMode (digitalPin, INPUT);<br> //pinMode(analogPin, INPUT);<br> Serial.begin(9600);
                            <br> }
                            <br> void loop ()<br> {
                            <br> // Read the digital interface<br> digitalVal = digitalRead(digitalPin) ;<br> if (digitalVal == HIGH) // When magnetic field is present, Arduino LED is on<br> {
                            <br> digitalWrite (led, HIGH);<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite (led, LOW);<br> }
                            <br> // Read the analog interface<br> analogVal = analogRead(analogPin);<br> Serial.println(analogVal); // print analog value<br> delay(100);
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn25"><img class="image" src="rotary-encoder.jpg"></button><br>Rotary Encoder Module
            <div id="myModal25" class="modal">
                <div class="modal-content">
                    <span class="close25">&times;</span>
                    <img src="Rotary-Encoder-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>ROTORY ENCODER is a device used for knowing the axial movement and its direction. Although they are available in various types here we are going to discuss about simple contact type encoder module. Here we are going to use M274
                            ROTARY ENCODER MODULE.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>ROTARY ENCODER module is five pin device as shown in the M274 pinout. In them four pins are compulsory for using the module.
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>GND</th>
                                    <th>Connected to GROUND</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Vcc</th>
                                    <th>Connected to +5V</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>SW</th>
                                    <th>Output of internal button</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>DT</th>
                                    <th>Contact A output or DATA</th>
                                </tr>
                                <tr>
                                    <th>5</th>
                                    <th>CLK</th>
                                    <th>Contact B output or CLOCK</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features and Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• 360º free rotation.<br> • 20 steps or cycles per revolution<br> • Incremental type encoder<br> • Can work on low voltages<br> • Maximum operating temperature: 0°C to + 80°C<br> • Easy interface<br> • Long life.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Security systems.<br> • Motors<br> • Robotic arms<br> • Vending machines.<br> • Industrial machines.<br> • Engineering systems.<br> • Measuring instruments.<br> • Hobby projects.<br> • Systems where systematic change INPUT device
                            is needed like CROs, signal generator etc.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn26"><img class="image" src="active-buzzer.jpg"></button><br>Active Buzzer Module
            <div id="myModal26" class="modal">
                <div class="modal-content">
                    <span class="close26">&times;</span>
                    <img src="active-buzzer-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is a small buzzer module which operates around the audible 2 kHz frequency range. It is an active buzzer, which means that it produces sound by itself, without needing an external frequency generator.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Product Name:3.3 to 5V Active Buzzer Alarm Module Sensor<br> Transistor drive module uses 8550<br> With fixed bolt hole- easy installation- 2.6mm aperture.<br> Operating voltage 3.3V-5V<br> PCB Dimensions: 34.28 mm (L) * 13.29
                            mm (W) * 11.5 mm (H)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features(Active buzzer):</h4>
                </button>
                    <div class="content">
                        <h5>1.An active buzzer with a concussion internal source- so long as it will be called an energized<br> 2. Program easy to control- SCM can let a high-low sound- while passive buzzer did not.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Module interface specification (3-wire):</h4>
                </button>
                    <div class="content">
                        <h5>
                             + External 3.3V-5V voltage (can be directly connected with the 5v and 3.3v MCU MCU)<br>  – External GND out external microcontroller IO port
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn27"><img class="image" src="magic-light-cup.jpg"></button><br>Magic Cup Light Module
            <div id="myModal27" class="modal">
                <div class="modal-content">
                    <span class="close27">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino KY-027 Magic Light Cup Module is a set of two boards, each one has a led and a mercury tilt switch. Using PWM to drive the LEDs on each module you can achieve the effect of light being "magically" transferred from one module
                            to the other when tilting them.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-027 is a pair of modules, each one consist of a mercury switch, a led and a 10 kΩ resistor. Each board have a pins to control the switch, LED, power and ground.<br> Operating Voltage 3.3V to 5.5V<br> Board Dimensions 1.5cm
                            x 3.6cm [0.6in x 1.4in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Arduino KY-027 Connection Diagram:</h4>
                </button>
                    <div class="content">
                        <h5>KY-027 (A) Arduino<br> G GND<br> + 5v<br> S 8<br> L 9<br> KY-027 (B) Arduino<br> G GND<br> + 5v<br> S 7<br> L 6
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int ledPinA = 9;<br> int switchPinA = 8;<br> int switchStateA = 0;<br> int ledPinB = 6;<br> int switchPinB = 7;<br> int switchStateB = 0;<br> int brightness = 0;<br> void setup() <br> {
                            <br> pinMode(ledPinA, OUTPUT);<br> pinMode(ledPinB, OUTPUT);<br> pinMode(switchPinA, INPUT);<br> pinMode(switchPinB, INPUT);<br> }
                            <br> void loop()<br> {
                            <br> switchStateA = digitalRead(switchPinA);<br> if (switchStateA == HIGH && brightness != 255)<br> { <br> brightness ++;<br> } <br> switchStateB = digitalRead(switchPinB);<br> if (switchStateB == HIGH && brightness != 0)<br>                            { <br> brightness --;<br> } <br> analogWrite(ledPinA, brightness); // A slow fade out<br> analogWrite(ledPinB, 255 - brightness); // B slow bright up<br> delay(20);
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn28"><img class="image" src="buzzer.jpg"></button><br>Small Passive Buzzer Module
            <div id="myModal28" class="modal">
                <div class="modal-content">
                    <span class="close28">&times;</span>
                    <img src="passive-buzzer-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This buzzer module is passive because it does not have any internal electronics to generate a sound or tone.<br> External electronics or a microcontroller based device, such as an Arduino, is needed to make the device produce a
                            sound.
                            <br> Because the device is passive, it acts more like a tiny loudspeaker than a buzzer.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Voltage: 3.3 - 5V<br> • With fixed bolt hole: 3mm for easy installation<br> • Module adopts 9012 transistor drive<br> • No oscillation source, need square wave (frequency 2K-5K ) to drive<br> • Sound frequency control, you can
                            make a “do re mi fa sol la si” effect
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Dimensions:</h4>
                </button>
                    <div class="content">
                        <h5>• Board: 33x13.2x10<br> • Pitch of pins: 0.1"/2.54mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection:</h4>
                </button>
                    <div class="content">
                        <h5>• VCC --> 3.3 - 5V<br> • GND --> GND<br> • I/O --> Digital Pin
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5> Passive internal shocks without source- so if you can not make it with a DC signal tweet. Must be a square wave 2K ~ 5K to drive it<br>  Sound frequency control- you can make a “more than a meter hair Suola” effect.<br>  In
                            some special cases- you can reuse a control and LED mouth
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int buzzer = 8 ;<br> void setup ()<br> {
                            <br> pinMode (buzzer, OUTPUT) ;<br> }
                            <br> void loop ()<br> {
                            <br> unsigned char i, j ;<br> while (1)<br> {
                            <br> for (i = 0; i
                            < 80; i++) // When a frequency sound<br>
                                {<br> digitalWrite (buzzer, HIGH) ; //send tone<br> delay (1) ;<br> digitalWrite (buzzer, LOW) ; //no tone<br> delay (1) ;<br> }
                                <br> for (i = 0; i
                                < 100; i++)<br>
                                    {<br> digitalWrite (buzzer, HIGH) ;<br> delay (2) ;<br> digitalWrite (buzzer, LOW) ;<br> delay (2) ;<br> }
                                    <br> }
                                    <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn29"><img class="image" src="digital-temperature.jpg"></button><br>KY-028 Digital Temperature Sensor Module
            <div id="myModal29" class="modal">
                <div class="modal-content">
                    <span class="close29">&times;</span>
                    <img src="ky-028.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Digital Temperature Sensor KY-028 for Arduino, it measures temperature changes based on the thermistor resistance. This module has both digital and analog outputs, there's a potentiometer to adjusts the detection threshold on the
                            digital interface.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-028 consist of a of a NTC thermistor, a LM393 dual differential comparator a 3296W trimmer potentiometer, six resistors and two indicator LEDs. The board features an analog and a digital output. Operating Voltage 3.3V to
                            5.5V
                            <br> Temperature measurement range -55°C to 125°C [-67°F to 257°F]<br> Measurement Accuracy ±0.5°C<br> Board Dimensions 15mm x 36mm [0.6in x 1.4in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>KY-028 Connection Diagram:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the board's analog output (A0) to pin A0 on the Arduino and the digital output (D0) to pin 3. Connect the power line (+) and ground (G) to 5V and GND respectively. KY-028 Arduino<br> A0 A0<br> G GND<br> + 5V<br> D0 2
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int led = 13; // define the LED pin<br> int digitalPin = 2; // KY-028 digital interface<br> int analogPin = A0; // KY-028 analog interface<br> int digitalVal; // digital readings<br> int analogVal; //analog readings<br> void setup()<br>                            {
                            <br> pinMode(led, OUTPUT);<br> pinMode(digitalPin, INPUT);<br> //pinMode(analogPin, OUTPUT);<br> Serial.begin(9600);
                            <br> }
                            <br> void loop()<br> {
                            <br> // Read the digital interface<br> digitalVal = digitalRead(digitalPin);<br> if(digitalVal == HIGH) // if temperature threshold reached<br> {
                            <br> digitalWrite(led, HIGH); // turn ON Arduino's LED<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite(led, LOW); // turn OFF Arduino's LED<br> }
                            <br> // Read the analog interface<br> analogVal = analogRead(analogPin);<br> Serial.println(analogVal); // print analog value to serial<br> delay(100);
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn30"><img class="image" src="Broken-light.jpg"></button><br>Broken Light Module
            <div id="myModal30" class="modal">
                <div class="modal-content">
                    <span class="close30">&times;</span>
                    <img src="broken-module.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Foto-onderbrekingsmodule triggert een signaal wanneer licht tussen de opening van de sensor is geblokkeerd.<br> Foto onderbrekingsmodule bestaat uit een optische emitter / detector aan de voorkant en twee weerstanden (1 kΩ en 33
                            Ω) aan de achterkant.<br>De sensor gebruikt een lichtstraal tussen de emitter en een detector om te controleren of het pad tussen beide wordt geblokkeerd door een ondoorzichtig object.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Voltage 5V<br> • Afmetingen: 19 mm x 15 mm x 8 mm<br> • Gewicht:3 gram<br> Aansluiting t.b.v. voorbeeldsketch:<br> • - (links) GND<br> • + (midden) 5V<br> • S (rechts) Pin 3
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn31"><img class="image" src="digital-temperature-sensor.jpg"></button><br>The Temperature Sensor Module
            <div id="myModal31" class="modal">
                <div class="modal-content">
                    <span class="close31">&times;</span>
                    <img src="Arduino_KY-001.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is DS18B20 digital temperature sensor module for Arduino -55°C~125°C<br> Digital signal output<br> Detect ambient air temperature<br> Compatible with Arduino DIY project<br> Main chip: 18B20 temperature sensor<br> Material:
                            PCB
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Resolution adjustment range :9-12<br> With mounting holes for easy installation, Aperture: 2.5<br> Temperature measuring range: -55 ~ +125 ℃<br> Temperature measurement accuracy: 0.5 ℃<br> Working voltage: DC 5V<br> Size: 28mm
                            x 12mm x 10mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Raspberry pi 2:</h4>
                </button>
                    <div class="content">
                        <h5>note about raspberry test: both 5v and 3.3v setup as described around the links below are working. when i was testing with my finger to elevate temperature, the ds18B20 stop working after few measure.<br>It seems to be dead and
                            not viewable from the pi. After waiting a little bit, i powered off and on the pi and the sensor start to answer again. It's perhaps it is a cheap module and the elevation speed too fast ?.<br> 1. the tuto that works for me
                            (very simple and working well !): raspberry pi 2 detailed setup and python script with DS18B20 and raspberry pi 2<br> 2. Raspberry pi tutorial and details about KY001 can be found here: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/temperature/<br>                            3. in french (1): another link in french<br> 4. in french (2)step by step setup in french
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Preparation:</h4>
                </button>
                    <div class="content">
                        <h5> Arduino controller × 1<br>  DS18B20 Temperature Sensor Module × 1<br>  USB data cable × 1<br>  download and install the OneWire libary
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connecting:</h4>
                </button>
                    <div class="content">
                        <h5> Pin - = connect to Arduino GND<br>  Pin (middel) = connect to arduino +5V<br>  Pin S = Signal, in this example connect to Arduino Digital port 10<br> When everything is properly connected, there is a led on the module that
                            blinks when the sensor is read.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>#include OneWire.h
                            <br> // DS18S20 Temperature chip i/o<br> OneWire ds(10); // on pin 10<br> void setup(void) {<br> // initialize inputs/outputs<br> // start serial port<br> Serial.begin(9600);
                            <br> }
                            <br> void loop(void) {<br> //For conversion of raw data to C<br> int HighByte, LowByte, TReading, SignBit, Tc_100, Whole, Fract;<br> byte i;<br> byte present = 0;<br> byte data[12];<br> byte addr[8];<br> if ( !ds.search(addr))
                            {
                            <br> Serial.print("No more addresses.\n");<br> ds.reset_search();
                            <br> return;
                            <br> }
                            <br> Serial.print("R=");
                            <br> for( i = 0; i
                            < 8; i++) {<br>
                                Serial.print(addr[i], HEX);<br> Serial.print(" ");<br> }
                                <br> if ( OneWire::crc8( addr, 7) != addr[7]) {<br> Serial.print("CRC is not valid!\n");<br> return;
                                <br> }
                                <br> if ( addr[0] == 0x10) {<br> Serial.print("Device is a DS18S20 family device.\n");<br> }
                                <br> else if ( addr[0] == 0x28) {<br> Serial.print("Device is a DS18B20 family device.\n");<br> }
                                <br> else {<br> Serial.print("Device family is not recognized: 0x");<br> Serial.println(addr[0],HEX);
                                <br> return;
                                <br> }
                                <br> ds.reset();
                                <br> ds.select(addr);
                                <br> ds.write(0x44,1); // start conversion, with parasite power on at the end<br> delay(1000); // maybe 750ms is enough, maybe not<br> // we might do a ds.depower() here, but the reset will take care of it.<br> present
                                = ds.reset();<br> ds.select(addr);
                                <br> ds.write(0xBE); // Read Scratchpad<br> Serial.print("P=");
                                <br> Serial.print(present,HEX);
                                <br> Serial.print(" ");<br> for ( i = 0; i
                                < 9; i++) { // we need 9 bytes<br>
                                    data[i] = ds.read();<br> Serial.print(data[i], HEX);<br> Serial.print(" ");<br> }
                                    <br> Serial.print(" CRC=");<br> Serial.print( OneWire::crc8( data, 8), HEX);<br> Serial.println();
                                    <br> //Conversion of raw data to C<br> LowByte = data[0];<br> HighByte = data[1];<br> TReading = (HighByte
                                    << 8) + LowByte;<br>
                                        SignBit = TReading & 0x8000; // test most sig bit<br> if (SignBit) // negative<br> {
                                        <br> TReading = (TReading ^ 0xffff) + 1; // 2's comp<br> }
                                        <br> Tc_100 = (6 * TReading) + TReading / 4; // multiply by (100 * 0.0625) or 6.25<br> Whole = Tc_100 / 100; // separate off the whole and fractional portions<br> Fract = Tc_100 % 100;<br> if (SignBit) // If its
                                        negative
                                        <br> {
                                        <br> Serial.print("-");
                                        <br> }
                                        <br> Serial.print(Whole);
                                        <br> Serial.print(".");
                                        <br> if (Fract
                                        < 10)<br>
                                            {<br> Serial.print("0");
                                            <br> }
                                            <br> Serial.print(Fract);
                                            <br> Serial.print("\n");
                                            <br> //End conversion to C<br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn32"><img class="image" src="double-colour-led.jpg"></button><br>Double Color LED Module
            <div id="myModal32" class="modal">
                <div class="modal-content">
                    <span class="close32">&times;</span>
                    <img src="Arduino_KY-011.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>LED module which provides a red and a green LED. These LEDs are connected with a common cathode. Resistors are needed for different input voltages.<br> Vf [typ]= 2,0-2,5V<br> If= 20mA<br> Pre-resistors:
                            <br> Rf (3,3V) [Green]= 120Ω<br> Rf (3,3V) [Red]= 120Ω<br> [for example using ARM CPU-Core based microcontroller like Raspbarry Pi]<br> Rf (5V) [Green] = 220Ω<br> Rf (5V) [Red] = 220Ω<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>LED Green = [Pin 10]<br> LED Red = [Pin 11]<br> Sensor GND = [Pin GND]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>KY-011 Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>This module consist of a common cathode 3mm red/green LED and a 0Ω resistor, Since operating voltage is 2.0v ~2.5v you'll need to use limiting resistors to prevent burnout when connecting to the Arduino.<br> Operating Voltage 2.0v
                            ~ 2.5v<br> Using Current 10mA<br> Diameter 3mm<br> Package Type Diffusion<br> Color Red + Green<br> Beam Angle 150<br> Wavelength 571nm + 644nm<br> Luminosity Intensity (MCD) 20-40; 40-80
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>The following Arduino sketch will gradually alternate between red and green color.<br> int redpin = 11; // pin for red signal<br> int greenpin = 10; // pin for green signal<br> int val;<br> void setup() {<br> pinMode(redpin, OUTPUT);<br>                            pinMode(greenpin, OUTPUT);<br> }
                            <br> void loop() {<br> for(val = 255; val > 0; val--) {<br> analogWrite(redpin, val); //dim red<br> analogWrite(greenpin, 255 - val); // brighten green<br> delay(15);
                            <br> }
                            <br> for(val = 0; val
                            < 255; val++) {<br>
                                analogWrite(redpin, val); //brighten red<br> analogWrite(greenpin, 255 - val); //dim green<br> delay(15);
                                <br> }
                                <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code example Raspberry Pi:</h4>
                </button>
                    <div class="content">
                        <h5>Code example ON/OFF<br> # Needed modules will be imported and configured.<br> import RPi.GPIO as GPIO<br> import time<br> GPIO.setmode(GPIO.BCM)
                            <br> # Output pin declaration for the LEDs.<br> LED_Red = 5<br> LED_Green = 4<br> GPIO.setup(LED_Red, GPIO.OUT, initial= GPIO.LOW)<br> GPIO.setup(LED_Green, GPIO.OUT, initial= GPIO.LOW)<br> print "LED-Test [press ctrl+c to
                            end the test]"<br> # Main program loop<br> try:
                            <br> while True:<br> print("LED Red will be on for 3 seconds")<br> GPIO.output(LED_Red,GPIO.HIGH) #LED will be switched on<br> GPIO.output(LED_Green,GPIO.LOW) #LED will be switched off<br> time.sleep(3) # Waitmode for 3 seconds<br>                            print("LED Green will be on for 3 seconds")<br> GPIO.output(LED_Red,GPIO.LOW) #LED will be switched off<br> GPIO.output(LED_Green,GPIO.HIGH) #LED will be switched on<br> time.sleep(3) #Waitmode for another 3 seconds in which
                            the LEDs are shifted<br> # Scavenging work after the end of the program<br> except KeyboardInterrupt:<br> GPIO.cleanup()
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections Raspberry Pi:</h4>
                </button>
                    <div class="content">
                        <h5>LED Green = GPIO4 [Pin 16]<br> LED Red = GPIO5 [Pin 18]<br> Sensor GND = GND [Pin 6]
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn33"><img class="image" src="mercury-medallion.png"></button><br>Mercury Medallion Module
            <div id="myModal33" class="modal">
                <div class="modal-content">
                    <span class="close33">&times;</span>
                    <img src="mercury-medallion-pin.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino KY-017 mercury tilt switch module, it uses a small mercury ball that completes the circuit when you tilt the module.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>This module consists of a mercury switch, a 680Ω resistor and a LED that will light up when tilt is detected. The mercury ball will open/close the circuit when the module is rotated.<br> Operating Voltage 3.3V to 5.5V
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>KY-017 Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the Power line (middle) and ground (-) to +5 and GND respectively. Connect signal (S) to pin 3 on the Arduino.<br> KY-017 Arduino<br> S Pin 3<br> middle +5V<br> - GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int led_pin = 13; // Define the LED interface<br> int switch_pin = 3; // Definition of mercury tilt switch sensor interface<br> int val; // Defines a numeric variable<br> void setup()<br> {
                            <br> pinMode(led_pin, OUTPUT);<br> pinMode(switch_pin, INPUT);<br> }
                            <br> void loop()<br> {
                            <br> val = digitalRead(switch_pin); // check mercury switch state<br> if(val == HIGH)<br> {
                            <br> digitalWrite(led_pin, HIGH);<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite(led_pin, LOW);<br> }
                            <br> } Mercury switch module and a digital interface, built-in 13 LED build a simple circuit to produce tilt warning lamp 13 comes with digital interfaces of the LED, the mercury tilt switch sensor interface to access digital
                            3, when the tilt switch sensor senses a key signal, LED lights, otherwise off.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Schematic:</h4>
                </button>
                    <div class="content">
                        <h5> Arduino GND --> Pin - of module<br>  Arduino 5+ --> Pin middel of module<br>  Arduino 3 --> pin S of module
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn34"><img class="image" src="hall-magnetic.jpg"></button><br>Hall Magnetic Sensor Module
            <div id="myModal34" class="modal">
                <div class="modal-content">
                    <span class="close34">&times;</span>
                    <img src="hall-mag.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>KEYES KY-003 Arduino Hall Magnetic Sensor Module is a switch that will turn on/off in the presence of a magnetic field.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-003 Hall Magnetic Sensor consists of a 3144EUA-S sensitive Hall-effect switch for high-temperature operation, a 680Ω resistor and a LED. Compatible with popular electronics platforms like Arduino and Raspberry Pi.<br> Operating
                            Voltage 4.5V to 24V<br> Operating Temperature Range -40°C to 85°C [-x°F to x°F]<br> Dimensions 18.5mm x 15mm [0.728in x 0.591in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the Power line (middle) and ground (-) to +5 and GND respectively. Connect signal (s) to pin 3 on the Arduino.<br> KY-003 Arduino<br> S Pin 3<br> Middle +5V<br> - GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int led = 13;//LED pin<br> int sensor = 3; //sensor pin<br> int val; //numeric variable<br> void setup()<br> {
                            <br> pinMode(led, OUTPUT); //set LED pin as output<br> pinMode(sensor, INPUT); //set sensor pin as input<br> }
                            <br> void loop()<br> {
                            <br> val = digitalRead(sensor); //Read the sensor<br> if(val == LOW) //when magnetic field is detected, turn led on<br> {
                            <br> digitalWrite(Led, HIGH);<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite(Led, LOW);<br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn35"><img class="image" src="reed-module.jpg"></button><br>Mini Reed Module
            <div id="myModal35" class="modal">
                <div class="modal-content">
                    <span class="close35">&times;</span>
                    <img src="ky-021mini.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino magnetic reed switch module Keyes KY-021. A reed switch is a magnetic sensor that is normally open and gets closed when exposed to a magnetic field.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-021 Mini Magnetic Reed Switch Module consists of a 10kΩ resistor and a small reed switch actuated by a magnetic field, commonly used in mechanical systems as proximity sensors. Compatible with popular electronic platforms
                            like Arduino, Teensy and ESP8266.<br> Operating Voltage 3.3V to 5v<br> Output Type Digital
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>KY-021 Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the module's Power line (middle) and ground (-) to +5 and GND respectively. Connect signal (S) to pin 2 on the Arduino.<br> KY-021 Arduino<br> S 2<br> Middle +5V<br> - GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        < <h5>int led = 13; // LED pin<br> int reelSwitch = 2; // magnetic senso rpin<br> int switchState; // variable to store reel switch value<br> void setup()<br> {
                            <br> pinMode (led, OUTPUT);<br> pinMode (reelSwitch, INPUT);<br> }
                            <br> void loop()<br> {
                            <br> switchState = digitalRead(reelSwitch); // read the value of digital interface 2 and assign it to switchState<br> if (switchState == HIGH) // when the magnetic sensor detect a signal, LED is flashing<br> {
                            <br> digitalWrite(led, HIGH);<br> }
                            <br> else <br> {
                            <br> digitalWrite(led, LOW);<br> }
                            <br> }
                            </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn36"><img class="image" src="tilt-switch-module.jpg"></button><br>Tilt Switch Module
            <div id="myModal36" class="modal">
                <div class="modal-content">
                    <span class="close36">&times;</span>
                    <img src="KY-020tilt-switch.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>KY-020 Arduino tilt switch sensor module. Closes the circuit when it is tilted to the side as long as it is moved with enough force and degree of inclination to activate the ball switch inside.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The KY-020 consists of a 10kΩ resistor and a metallic ball switch with bidirectional conduction that will open/close the circuit depending on its tilt degree. It does not measure tilt angle.<br> Operating Voltage 3.3V to 5v<br>                            Output Type Digital
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>KY-020 Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the module's Power line (middle) and ground (-) to +5 and GND respectively. Connect signal (S) to pin 2 on the Arduino.<br> KY-020 Arduino<br> S 2<br> middle +5V<br> - GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>The following sketch will turn on the LED on pin 13 of the Arduino when the module detects a change in inclination degree. Tilt the KY-020 to turn the LED on/off.<br> int tiltPin = 2; // pin number for tilt switch signal <br> int
                            ledPin = 13; // pin number of LED <br> int tiltState = 0; // variable for reading the tilt switch status<br> void setup() { <br> pinMode(ledPin, OUTPUT); // set the LED pin as output<br> pinMode(tiltPin, INPUT); // set the
                            tilt switch pin as input<br> }
                            <br> void loop(){<br> // get the tilt switch state<br> tiltState = digitalRead(tiltPin);<br> // check if tilt switch is tilted.<br> if (tiltState == HIGH) {<br> digitalWrite(ledPin, HIGH);<br> } <br> else {<br> digitalWrite(ledPin,
                            LOW);
                            <br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn37"><img class="image" src="button-switch-module.jpg"></button><br>Button switch module(KY-004)
            <div id="myModal37" class="modal">
                <div class="modal-content">
                    <span class="close37">&times;</span>
                    <img src="ky004.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino Key Switch Module Keyes KY-004 is a push button that will output a high signal when pressed.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The module consists of a FZ1713 tactile push button switch and a resistor. Compatible with popular electronics platforms like Arduino, Raspberry Pi and Esp8266.<br> Rating 50mA 12VC<br> Environment temperature -25°C to 105°C [
                            -13°F to 221°F]<br> Electrically Life 100,000 cycles<br> Operating Force 180/230(±20gf)<br> Dimensions 18.5mm x 15mm [0.728in x 0.591in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Connect the power line (middle) and ground to +5V and GND respectively. Connect signal (S) to pin 3 on the arduino.<br> KY-004 Arduino<br> S Pin 3<br> Middle +5V<br> - GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>The following sketch will turn on Arduino's pin 13 LED when the button on KY-004 is pressed.<br> int led = 13; //Define the LED pin<br> int buttonpin = 3; //Define the push button pin<br> int val; //Define a numeric variable<br>                            void setup()<br> {
                            <br> pinMode(led,OUTPUT);
                            <br> pinMode(buttonpin,INPUT);
                            <br> }
                            <br> void loop()<br> {
                            <br> val = digitalRead(buttonpin); // check the state of the button<br> if(val==HIGH) // if button is pressed, turn LED on<br> {
                            <br> digitalWrite(led,HIGH);
                            <br> }
                            <br> else
                            <br> {
                            <br> digitalWrite(led,LOW);
                            <br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn38"><img class="image" src="vibration_switch.jpg"></button><br>Vibration switch module
            <div id="myModal38" class="modal">
                <div class="modal-content">
                    <span class="close38">&times;</span>
                    <img src="ky002.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This vibration detector switch is OFF in the resting state, when the external force to touch and to achieve a proper vibration meet the appropriate speed or from the (partial) heart, conductive pin will momentarily enable conduction
                            (ON) status, make changes in electric property, and disappear when the external force electric property open (OFF) state is restored.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5> The Vibration module is connect to pin 10 of the Arduino<br>  Omnidirectional, any Angle can trigger job<br>  Component model:SW-18015P
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connecting to the Arduino:</h4>
                </button>
                    <div class="content">
                        <h5> Pin - = GND, connect to GND of the Arduino<br>  Pin (middel pin) +5 v, connect to Arduino +5<br>  Pin S signal, connect to Arduino pin 10<br> When there is vibration the Arduino LED on pin 13 flashes.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example code:</h4>
                </button>
                    <div class="content">
                        <h5>int Led = 13 ;// define LED Interface<br> int Shock = 10; // define the vibration sensor interface<br> int val; // define numeric variables val<br> void setup ()<br> {
                            <br> pinMode (Led, OUTPUT) ; // define LED as output interface<br> pinMode (Shock, INPUT) ; // output interface defines vibration sensor<br> }
                            <br> void loop ()<br> {
                            <br> val = digitalRead (Shock) ; // read digital interface is assigned a value of 3 val<br> if (val == HIGH) // When the shock sensor detects a signal, LED flashes<br> {
                            <br> digitalWrite (Led, LOW);<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite (Led, HIGH);<br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn39"><img class="image" src="Knock-Sensor.jpg"></button><br>The knock sensor module
            <div id="myModal39" class="modal">
                <div class="modal-content">
                    <span class="close39">&times;</span>
                    <img src="KY-031-Knock-Sensor-Pin-Outs.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                        <h4>Descriptions:</h4>
                    </button>
                    <div class="content">
                        <h5>The knock sensor, detects the knocks and the taps. It can work like a switch. The sensor sends data momentarily to the board. To keep the LED on, the button state change codes should be used. So the sensor will work as a switch.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Connections:</h4>
                    </button>
                    <div class="content">
                        <h5>LED + = [Pin 13]<br> LED - = [Pin GND]<br> Sensor signal = [Pin 10]<br> Sensor +V = [Pin 5V]<br> Sensor - = [Pin GND]
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Example Code:</h4>
                    </button>
                    <div class="content">
                        <h5>int Led = 13 ; // define LED Interface<br> int Shock = 3 // define the percussion Sensor Interface<br> int val ; // define numeric variables val<br> void setup ()<br> {
                            <br> pinMode (Led, OUTPUT) ; // define LED as output interface<br> pinMode (Shock, INPUT) ; // define knock sensor output interface<br> }
                            <br> void loop ()<br> {
                            <br> val = digitalRead (Shock) ; // read digital interface is assigned a value of 3 val<br> if (val == HIGH) // When the percussion when the sensor detects a signal, LED flashes<br> {
                            <br> digitalWrite (Led, LOW);<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite (Led, HIGH);<br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn40"><img class="image" src="microphone.jpg"></button><br>The microphone sound sensor module
            <div id="myModal40" class="modal">
                <div class="modal-content">
                    <span class="close40">&times;</span>
                    <img src="Arduino-Sound-Detection-Sensor-Pin-Outs.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>Can detect the intensity of the sound environment, use note: the sound sensor can identify the presence of sound<br> (according to the principle of vibration) or a particular frequency of sound does not recognize the volume of
                            the sound.<br> Sensitivity adjustable digital potentiometer to adjust (blue)<br> working voltage 3.3-5V<br> Output form: digital switch output (0 and 1)<br> Has a fixed bolt hole, convenient installation<br> Small board PCB
                            size: 3.2 cmx1.7 cm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Module wiring:</h4>
                </button>
                    <div class="content">
                        <h5>VCC voltage is 3.3 V to 5 V converter (which can be directly connected to 3.3 V or 5 V single-chip microcontroller)<br> GND external to GND<br> OUT of small plate switch output interface (0 and 1)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Instructions:</h4>
                </button>
                    <div class="content">
                        <h5>Sound module is the most sensitive to the environment sound intensity, commonly used to detect the intensity of the sound of the surroundings.<br> When module in the intensity of the sound environment can not reach set threshold,
                            the OUT will output high level, when the intensity of the sound from the outside environment more than set threshold, the module OUT output low level.<br> Small digital output board OUT can be directly to the microcontroller,
                            through single chip microcomputer to detect the high and low level, thus to detect sound environment.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn41"><img class="image" src="mq2.jpg"></button><br>MQ-2
            <div id="myModal41" class="modal">
                <div class="modal-content">
                    <span class="close41">&times;</span>
                    <img src="MQ2-Gas-Sensor-Module-Pinout.jpg " class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage is +5V<br> • Can be used to Measure or detect LPG, Alcohol, Propane, Hydrogen, CO and even methane<br> • Analog output voltage: 0V to 5V<br> • Digital Output Voltage: 0V or 5V (TTL Logic)<br> • Preheat duration
                            20 seconds<br> • Can be used as a Digital or analog sensor<br> • The Sensitivity of Digital pin can be varied using the potentiometer
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use MQ-2 Gas sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ-2 Gas sensor can detect or measure gasses like LPG, Alcohol, Propane, Hydrogen, CO and even methane.<br>The module version of this sensor comes with a Digital Pin which makes this sensor to operate even without a microcontroller
                            and that comes in handy when you are only trying to detect one particular gas.<br>When it comes to measuring the gas in ppm the analog pin has to be used, the analog pin also TTL driven and works on 5V and hence can be used
                            with most common microcontrollers.<br> So if you are looking for a sensor to detect or measure gasses like LPG, Alcohol, Propane, Hydrogen, CO and even methane with or without a microcontroller then this sensor might be the
                            right choice for you.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use MQ-2 Sensors to detect gas:</h4>
                </button>
                    <div class="content">
                        <h5>Using an MQ sensor it detects a gas is very easy. You can either use the digital pin or the analog pin to accomplish this.<br>Simply power the module with 5V and you should notice the power LED on the module to glow and when no
                            gas it detected the output LED will remain turned off meaning the digital output pin will be 0V.<br>Remember that these sensors have to be kept on for pre-heating time (mentioned in features above) before you can actually work
                            with it.<br>Now, introduce the sensor to the gas you want to detect and you should see the output LED to go high along with the digital pin, if not use the potentiometer until the output gets high. Now every time your sensor
                            gets introduced to this gas at this particular concentration the digital pin will go high (5V) else will remain low (0V).<br> You can also use the analog pin to achieve the same thing. Read the analog values (0-5V) using a
                            microcontroller, this value will be directly proportional to the concentration of the gas to which the sensor detects.<br>You can experiment with this values and check how the sensor reacts to different concentration of gas
                            and develop your program accordingly.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Detects or measure Gases like LPG, Alcohol, Propane, Hydrogen, CO and even methane<br> • Air quality monitor<br> • Gas leak alarm<br> • Safety standard maintenance<br> • Maintaining environment standards in hospitals
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn42"><img class="image" src="mq3.png"></button><br>MQ-3
            <div id="myModal42" class="modal">
                <div class="modal-content">
                    <span class="close42">&times;</span>
                    <img src="MQ3-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Description:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications</h4>
                </button>
                    <div class="content">
                        <h5>• Power requirements: 5 VDC @ ~165 mA (heater on) / ~60 mA (heater off)<br> • Current Consumption: 150mA<br> • DO output: TTL digital 0 and 1 ( 0.1 and 5V)<br> • AO output: 0.1- 0.3 V (relative to pollution), the maximum concentration
                            of a voltage of about 4V<br> • Detecting Concentration: 0.05-10mg/L Alcohol<br> • Interface: 1 TTL compatible input (HSW), 1 TTL compatible output (ALR)<br> • Heater consumption: less than 750mW<br> • Operating temperature:
                            14 to 122 °F (-10 to 50°C)<br> • Load resistance: 200kΩ<br> • Sensitivity S: Rs(in air)/Rs(0.4mg/L Alcohol)≥5<br> • Sensing Resistance Rs: 2KΩ-20KΩ(in 0.4mg/l alcohol)<br> • Dimensions: 32 x 22 x 16 mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Sensor Type - Semiconductor<br> • Easy SIP header interface<br> • Compatible with most of the microcontrollers<br> • Low-power standby mode<br> • Requires heater voltage<br> • Good sensitivity to alcohol gas<br> • Fast response
                            and High sensitivity<br> • Long life and low cost<br> • Requires simple Drive circuit
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>MQ-3 Equivalent Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>
                            MQ-2, MQ214 (detection of Methane), MQ303A.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Description</h4>
                </button>
                    <div class="content">
                        <h5>MQ-3 module is suitable for detecting Alcohol, Benzine, CH4, Hexane, LPG, CO.<br>Sensitive material of MQ-3 gas sensor is SnO2, which with lower conductivity in clean air. When the target alcohol gas exist, the sensor’s conductivity
                            is more higher along with the gas concentration rising.<br>MQ-3 gas sensor has high sensitity to Alcohol, and has good resistance to disturb of gasoline, smoke and vapor.<br> This sensor provides an analog resistive output
                            based on alcohol concentration. When the alcohol gas exist, the sensor’s conductivity gets higher along with the gas concentration rising.<br> There is a resistance across an A and B inside the sensor which varies on detection
                            of alcohol. More the alcohol, the lower the resistance. The alcohol is measured by measuring this resistance.<br>The sensor and load resistor form a voltage divider, and the lower the sensor resistance, the higher the voltage
                            reading will be.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Gas level over-limit alarm<br> • Breathalyser<br> • Portable alcohol detector<br> • Stand-alone/background sensing device<br> • Environmental monitoring equipment
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn43"><img class="image" src="mq4.jpg"></button><br>MQ-4
            <div id="myModal43" class="modal">
                <div class="modal-content">
                    <span class="close43">&times;</span>
                    <img src="mqw4-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Good sensitivity to Combustible gas in wide range<br> • High sensitivity to CH4, Natural gas.<br> • Small sensitivity to alcohol, smoke.<br> • Fast response Stable and long life<br> • Simple drive circuit
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Sensor Type Semiconductor<br> • Power requirements: VCC - 5V±0.1<br> • DO output: TTL digital 0 and 1 (0.1 and 5V)<br> • AO output: 0.1-0 .3 V (relative to pollution), the maximum concentration of a voltage of about 4V<br> •
                            Detection Gas: Natural gas/Methane<br> • Detection Concentration: 200-10000ppm (Natural gas / Methane)<br> • Interface: 1 TTL compatible input (HSW), 1 TTL compatible output (ALR)<br> • Heater consumption: less than 750mw<br>                            • Operating temperature: 14 to 122 °F (-10 to 50°C)<br> • RH Related humidity less than 95%Rh<br> • O2 Oxygen concentration is 21% (standard condition) - Oxygen concentration can affect sensitivity<br> • Load resistance: 20KΩ<br>                            • Sensing Resistance Rs: 10KΩ- 60KΩ (1000ppm CH4)<br> • Preheat time:Over 24 hour<br> • Standard Encapsulation Bakelite, Metal cap
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>MQ-4 Equivalent Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>MQ-214 (Methane, Natural Gas Detection), MQ306A (LPG Detection), MQ-5 (Natural gas, LPG), MQ306A (LPG detection), MQ-2
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>MQ-4 Gas Sensor Brief Detail:</h4>
                </button>
                    <div class="content">
                        <h5>Structure and configuration of MQ-4 gas sensor is shown in above figure (Configuration A or B), sensor composed by micro AL2O3 ceramic tube, Tin Dioxide (SnO2) sensitive layer, measuring electrode and heater are fixed into a crust
                            made by plastic and stainless steel net. The heater provides necessary work conditions for work of sensitive components.<br>The enveloped MQ-4 have 6 pin ,4 of them are used to fetch signals, and other 2 are used for providing
                            heating current.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use MQ-4 Sensor Module?:</h4>
                </button>
                    <div class="content">
                        <h5>The connections of MQ4 Gas Sensor Module are very simple. They are made as follows:<br> • VCC to 5V<br> • GND to GND<br> • AO to AnalogO<br> • DO to DigitalO<br> Using a MQ sensor and detecting the gas is quite easy. You can either
                            use the digital pin or the analog pin to accomplish this. Simply power the module with 5V and you should notice the power LED on the module to glow and when no gas is detected the output LED will remain turned off meaning the
                            digital output pin will be 0V.<br> Remember that these sensors have to be kept on for pre-heating time (mentioned in features above) before you can actually work with it. Now, introduce the sensor to the gas and you should
                            see the output LED to go high along with the digital pin. Now every time your sensor gets introduced to this gas at this particular concentration the digital pin will go high (5V) else will remain low (0V).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Used in gas leakage detecting equipment for homes and industry. They are suitable for detecting of CH4 and CNG.<br> • Industrial Combustible gas detector<br> • Portable gas detectors<br>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn44"><img class="image" src="mq5.jpg"></button><br>MQ-5
            <div id="myModal44" class="modal">
                <div class="modal-content">
                    <span class="close44">&times;</span>
                    <img src="mq5-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ5 Gas Sensor module is useful for gas leakage detecting. It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. The sensitivity can be adjusted using the on-board potentiometer, and you'd use this sensor
                            by reading the analog pin to which it is connected. Please use these sensors only in controlled experiments! Combustible gases and fumes are very dangerous! Here are details for some MQ gas sensor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>• Working voltage: 5V<br> • Working Current: 150mA<br> • DO: TTL output<br> • AO: Analog output, it will be higher with more such gas.<br> • Preheat time: Over 20s
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn45"><img class="image" src="mq-6.jpg"></button><br>MQ-6
            <div id="myModal45" class="modal">
                <div class="modal-content">
                    <span class="close45">&times;</span>
                    <img src="MQ-6-Gas-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage is +5V<br> • Can be used to detect LPG or Butane gas<br> • Analog output voltage: 0V to 5V<br> • Digital Output Voltage: 0V or 5V (TTL Logic)<br> • Preheat duration 20 seconds<br> • Can be used as a Digital
                            or analog sensor<br> • The Sensitivity of Digital pin can be varied using the potentiometer
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>MQ6 Equivalent Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>MQ-2, MQ-5,AQ-2, MQ-306A, AQ-3
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use MQ-6 Sensors to Detect gas? :</h4>
                </button>
                    <div class="content">
                        <h5>Using a MQ sensor it detect a gas is very easy. You can either use the digital pin or the analog pin to accomplish this.<br>Simply power the module with 5V and you should notice the power LED on the module to glow and when no gas
                            it detected the output LED will remain turned off meaning the digital output pin will be 0V. Remember that these sensors have to be kept on for pre-heating time (mentioned in features above) before you can actually work with
                            it.
                            <br>Now, introduce the sensor to the gas you want to detect and you should see the output LED to go high along with the digital pin, if not use the potentiometer until the output gets high. Now every time your sensor gets introduced
                            to this gas at this particular concentration the digital pin will go high (5V) else will remain low (0V).<br> You can also use the analog pin to achieve the same thing.<br>Read the analog values (0-5V) using a microcontroller,
                            this value will be directly proportional to the concentration of the gas to which the sensor detects.<br>You can experiment with this values and check how the sensor reacts to different concentration of gas and develop your
                            program accordingly.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Detect or measure Gases like LPG, and butane<br> • Air quality monitor<br> • Gas leak alarm<br> • Safety standard maintenance<br> • Maintaining environment standards in hospitals
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn46"><img class="image" src="mq-7.jpg"></button><br>MQ-7
            <div id="myModal46" class="modal">
                <div class="modal-content">
                    <span class="close46">&times;</span>
                    <img src="mq7-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>A carbon monoxide detector for the Arduino-based DIY security system. The carbon monoxide detector is a semiconductor gas sensor tuned to detect carbon monoxide.<br>It is in the same family of devices as the smoke detector sensor,
                            measuring the change in surface conductivity of tin dioxide in the presence of carbon monoxide. This sensor has a high sensitivity and fast response time. The sensor's output is an analog resistance.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Detection Zone:10 to 1000ppmm.<br> • Characteristic Gas:100ppmm co.<br> • Sensitive Resistance:2K to 20K in 100ppm co.<br> • Sensitivity: ≥3%.<br> • Response Time: ≤1s.<br> • Recovery Time: ≤30s.<br> • Heating Resistance:31Â±3.<br>                            • Heating Current: ≤180mA.<br> • Heating Voltage:5.0VÂ±0.2V /1.5Â±0.1V.<br> • Heating Power: about 350mW.<br> • Conditions: Ambient Temperature:-20C~+50C.<br> • Humidity: ≤95%RH.<br> • Oxygen Content:21%<br> • Size: 3.5cm X
                            2.2cm - 1.4inch x 0.9inch.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ-7 carbon monoxide sensor module allows for the sensing of CO concentrations in the air. This module can detect CO gas concentrations from anywhere between 20 and 2000ppm.<br> The sensor is highly sensitive and has a quick
                            response time. It uses analogue resistance as an output and is extremely easy to connect with the use of Arduino.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn47"><img class="image" src="mq-8.jpg"></button><br>MQ-8
            <div id="myModal47" class="modal">
                <div class="modal-content">
                    <span class="close47">&times;</span>
                    <img src="MQ-8-hydrogen-gas-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>This is a simple-to-use hydrogen gas sensor, suitable for sensing hydrogen concentrations in the air. The MQ-8 can detect hydrogen gas concentrations anywhere from 100-10000ppm. This sensor has a high sensitivity and fast response
                            time.
                            <br>The sensor’s output is an analog resistance. The drive circuit is very simple; all you need to do is power the heater coil with 5V, add a load resistance, and connect the output to an ADC.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Power supply needs: 5V<br> • Interface type: Analog, Digital<br> • High sensitivity to Hydrogen (H2)<br> • Small sensitivity to alcohol, LPG,cooking fumes<br> • Stable and long life<br> • Size: 32x20mm<br> • Circuit voltage:
                            5V±0.1
                            <br> • Heating voltage: 5V±0.1<br> • Load resistance: 10KΩ<br> • Heater resistance: 31±5%<br> • Heating consumption: less than800mW<br> • Using Temperature: -10°C-50°C<br> • Storage Temperature: -20°C-70°C<br> • Related humidity:
                            less than 95%Rh<br> • Oxygen concentration: 21%(standard condition)Oxygen concentration can affect sensitivity
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>1. With a signal output instructions.<br> 2. Dual signal output (TTL level output and analog output)<br> 3. TTL output valid signal for low level. (when the low output electric signal lights at 4. ordinary times, can be directly
                            pick up SCM)<br> 4. Analog 0 ~ 5 v voltage, the higher the concentration, the higher the voltage.<br> 5. High sensitivity to hydrogen<br> 6. Can be resistant to ethanol steam, LPG (petroleum), smoke interference<br> 7. Has
                            a long service life and reliable stability<br> 8. Quick response recovery features
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn48"><img class="image" src="mq-9.jpg"></button><br>MQ-9
            <div id="myModal48" class="modal">
                <div class="modal-content">
                    <span class="close48">&times;</span>
                    <img src="mq-9-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions</h4>
                </button>
                    <div class="content">
                        <h5>This is MQ-9 Carbon Monoxide, Methane, and LPG Gas Sensor Module can be used to sense Carbon Monoxide and Methane Gas.<br>Sensitive material of MQ-9 gas sensor is SnO2, which with lower conductivity in clean air.<br> It makes detection
                            by the method of cycle high and low temperature, and detect CO when the low temperature (heated by 1.5V).<br>The sensor’s conductivity is higher along with the gas concentration rising.<br> When high temperature (heated by
                            5.0V), it detects Methane, Propane etc. combustible gas and cleans the other gases adsorbed under low temperature.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Wire Connections:</h4>
                </button>
                    <div class="content">
                        <h5>VCC – Positive pole (5V)<br> GND – Negative pole<br> DO – TTL switch signal output<br> AO – Analog signal output
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>1. The domestic gas leakage detector<br> 2. Industrial gas detector<br> 3. Portable gas detector
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>1. Good sensitivity to CO/Combustible Gas<br> 2. High sensitivity to Methane, Propane, and CO<br> 3. Long life and low cost<br> 4. Simple drive circuit
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Model MQ-9<br> Operating Voltage(VDC) 5<br> Current Consumption (mA) 150<br> Do output TTL digital 0 and 1 (0.1 and 5V)<br> Ao output 0.1-0.3V (relatively clean)<br> Dimensions in mm (LxWxH) 32x22x20<br> Weight (gm) 5<br> Shipment
                            Weight 0.095 kg<br> Shipment Dimensions 5 x 5 x 4 cm
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id=myBtn49><img class="image" src="mq131.jpg"></button><br>MQ131
            <div id="myModal49" class="modal">
                <div class="modal-content">
                    <span class="close49">&times;</span>
                    <img src="mq-131-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Sensitive material of MQ131 gas sensor is O3 SnO2, which with lower conductivity in clean air. When Ozone gas exists. The sensor’s conductivity is more higher along with the gas concentration rising. Please use simple electrocircuit,
                            Convert change of conductivity to correspond output signal of gas concentration. MQ131 gas sensor has high sensitity to Ozone, also sensitive to O3 CL2, NO2, etc.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Feature:</h4>
                </button>
                    <div class="content">
                        <h5>• with the signal light indicates the output;<br> • the dual signal output (analog output, and TTL-level output);<br> • TTL output valid signal is low; (low output signal light, can be accessed by the microcontroller IO port)<br>                            • the analog output increases with the concentration, the higher the voltage the higher the concentration;<br> • the ozone gas with high sensitivity (detection concentration range 10PPB-2PPM Ozone)<br> • with a long life and
                            reliable stability;<br> • Fast response characteristics;<br> • with mounting holes to facilitate fixed installation;
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Model No.-MQ-131<br> Sensor-Type Semiconductor<br> Standard Encapsulation-Stainless steel<br> Detection Gas-Ozone<br> Concentration-10PPB-2PPM Ozone<br> Circuit:-
                            <br> Loop Voltage-Vc-≤24V DC<br> Heater Voltage-VH-5.0V±0.2V AC or DC<br> Load Resistance-RL-Adjustable<br> Character:-
                            <br> Heater Resistance-RH-31Ω±3Ω Room Temp<br> Heater consumption-PH-≤900mW<br> Sensing Resistance-Rs-50KΩ-500KΩ(in 50ppm O3)<br> Sensitivity-S-Rs(in air)/Rs(in 50ppm O3)≥3<br> Slope-α-≤0.6 (R50ppm/R10ppm O3)<br> Condition:-
                            <br> Tem. Humidity-20℃±2℃; 65%±5%RH<br> Standard test circuit-Vc:5.0V±0.1V<br> VH: 5.0V±0.1V<br> Preheat time -Over 48 hours
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn50"><img class="image" src="Mq-135.jpg"></button><br>MQ135
            <div id="myModal50" class="modal">
                <div class="modal-content">
                    <span class="close50">&times;</span>
                    <img src="MQ135-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Wide detecting scope<br> • Fast response and High sensitivity<br> • Stable and long life<br> • Operating Voltage is +5V<br> • Detect/Measure NH3, NOx, alcohol, Benzene, smoke, CO2, etc.<br> • Analog output voltage: 0V to 5V<br>                            • Digital output voltage: 0V or 5V (TTL Logic)<br> • Preheat duration 20 seconds<br> • Can be used as a Digital or analog sensor<br> • The Sensitivity of Digital pin can be varied using the potentiometer
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use MQ-135 Gas sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ-135 Gas sensors are used in air quality control equipments and are suitable for detecting or measuring of NH3, NOx, Alcohol, Benzene, Smoke, CO2.<br>The MQ-135 sensor module comes with a Digital Pin which makes this sensor
                            to operate even without a microcontroller and that comes in handy when you are only trying to detect one particular gas.<br>If you need to measure the gases in PPM the analog pin need to be used. The analog pin is TTL driven
                            and works on 5V and so can be used with most common microcontrollers.<br> If you are looking for a sensor to detect or measure common air quality gases such as CO2, Smoke, NH3, NOx, Alcohol, Benzene then this sensor might be
                            the right choice for you.<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use MQ-135 Sensors to detect gases:</h4>
                </button>
                    <div class="content">
                        <h5>You can either use the digital pin or the analog pin to do this. Simply power the module with 5V and you should notice the power LED on the module to glow and when no gas it detected the output LED will remain turned off meaning
                            the digital output pin will be 0V.<br>Remember that these sensors have to be kept on for pre-heating time (mentioned in features above) before you can actually work with it. Now, introduce the sensor to the gas you want to
                            detect and you should see the output LED to go high along with the digital pin, if not use the potentiometer until the output gets high.<br>Now every time your sensor gets introduced to this gas at this particular concentration
                            the digital pin will go high (5V) else will remain low (0V).<br> You can also use the analog pin to achieve the same thing. Read the analog values (0-5V) using a microcontroller, this value will be directly proportional to
                            the concentration of the gas to which the sensor detects.<br>You can experiment with this values and check how the sensor reacts to different concentration of gas and develop your program accordingly.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>
                            • Used to detect leakage/excess of gases like Ammonia, nitrogen oxide, alcohols, aromatic compounds, sulfide and smoke.<br> • Air quality monitors.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn51"><img class="image" src="mq136.jpg"></button><br>MQ136
            <div id="myModal51" class="modal">
                <div class="modal-content">
                    <span class="close51">&times;</span>
                    <img src="mq136-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>MQ136 Gas Sensor can be used to monitor the concentration Hydrogen Sulfide gas. This Module simplifies using the MQ-136 gas sensor by providing digital as well as analog output which can be interfaced to Microcontrollers, Arduino
                            and Raspberry pi.<br> Senitive material of MQ136 gas sensor is SnO2, which with lower conductivity in clean air.<br>When the target Hydrogen sulfide gas exist, the sensor’s conductivity is higher along with the Hydrogen sulfide
                            concentration rising. Please use simple electric circuit, Convert change of conductivity to correspond output signal of gas concentration.<br>MQ136 gas sensor has high sensitivity to Hydrogen sulfide, Low sensitivity for other
                            combustible gas. It is with low cost and suitable for different application.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Good sensitivity to Hydrogen sulfide<br> • Long life and low cost<br> • Simple drive circuit
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Domestic Hydrogen sulfide detector<br> • Industrial Hydrogen sulfide detector<br> • Portable Hydrogen sulfide detector
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Model No: MQ136<br> • Sensor Type:Semiconductor<br> • Standard Encapsulation:Bakelite (Black Bakelite)<br> • Detection Gas:Hydrogen sulfide<br> • Concentration:1-200ppm (Hydrogen sulfide)<br> • Heater Voltage (VH):5.0V±0.2V AC
                            or DC<br> • Load Resistance(RL):Adjustable<br> • Character Heater Resistance(RH): 31O±3O(Room Tem.)<br> • Sensing Resistance(Rs):2KO-20KO(in 50ppm SO2)<br> • Preheat time:Over 48 hours
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn52"><img class="image" src="mq-137.jpg"></button><br>MQ137
            <div id="myModal52" class="modal">
                <div class="modal-content">
                    <span class="close52">&times;</span>
                    <img src="MQ-137-Gas-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Module</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Vcc</th>
                                    <th>This pin powers the module, typically the operating voltage is +5V</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Ground</th>
                                    <th>Used to connect the module to system ground</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Digital Out</th>
                                    <th>You can also use this sensor to get digital output from this pin, by setting a threshold value using the potentiometer</th>
                                </tr>
                                <tr>
                                    <th>4</th>
                                    <th>Analog Out</th>
                                    <th>This pin outputs 0-5V analog voltage based on the intensity of the gas</th>
                                </tr>
                                <tr>
                                    <th colspan="3">For Sensor</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>H -Pins</th>
                                    <th>Out of the two H pins, one pin is connected to supply and the other to ground</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>A-Pins</th>
                                    <th>The A pins and B pins are interchangeable. These pins will be tied to the Supply voltage.</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>B-Pins</th>
                                    <th>The A pins and B pins are interchangeable.One pin will act as output while the other will be pulled to ground.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage is +5V<br> • Can be used to Measure Ammonia, Carbon monoxide<br> • Analog output voltage: 0V to 5V<br> • Digital Output Voltage: 0V or 5V (TTL Logic)<br> • Preheat duration over 24 hours<br> • Can be used as
                            a Digital or analog sensor<br> • The Sensitivity of Digital pin can be varied using the potentiometer
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Equivalent Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>MQ-135, CJMCU-4541
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Selecting between Sensor type and module type:</h4>
                </button>
                    <div class="content">
                        <h5>When it comes to measuring or detecting a particular Gas the MQ series Gas sensors are the most commonly used ones. These sensors can either be purchased as a module or as just the sensor alone.<br>If you are trying to only detect
                            (not measuring ppm) the presence of a gas then you can buy it as a module since it comes with an op-amp comparator and a digital out pin.<br>But if you planning to measure the ppm of a gas it is recommend to buy the sensor
                            alone (without module).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to Use MQ-137 Gas sensor?:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ-137 Gas sensor can detect or measure gasses like Ammonia (NH3) and Carbon Mono-oxide (CO). The module version of this sensor comes with a Digital Pin which makes this sensor to operate even without a microcontroller and
                            that comes in handy when you are only trying to detect one particular gas.<br>When it comes to measuring the gas in ppm the analog pin has to be used, the analog pin is also TTL driven and works on 5V and hence can be used
                            with most common microcontrollers.<br> So if you are looking for a sensor to detect or measure Ammonia or CO with or without a microcontroller then this sensor might be the right choice for you.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use MQ-137 Sensors to detect gas :</h4>
                </button>
                    <div class="content">
                        <h5>Using a MQ sensor to detect a gas is very easy. You can either use the digital pin or the analog pin to accomplish this.<br>Simply power the module with 5V and you should notice the power LED on the module to glow and when no gas
                            it detected the output LED will remain turned off meaning the digital output pin will be 0V. Remember that these sensors have to be kept on for pre-heating time (mentioned in features above) before you can actually work with
                            it.
                            <br>Now, introduce the sensor to the gas you want to detect and you should see the output LED to go high along with the digital pin, if not use the potentiometer until the output gets high.<br>Now every time your sensor gets
                            introduced to this gas at this particular concentration the digital pin will go high (5V) else will remain low (0V).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Detect or measure Gases like NH3 or CO<br> • Air quality monitor<br> • Gas leak alarm<br> • Safety standard maintenance
                            <<br>
                                • Maintaining environment standards in hospitals
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn53"><img class="image" src="mq138.jpg"></button><br>MQ138
            <div id="myModal53" class="modal">
                <div class="modal-content">
                    <span class="close53">&times;</span>
                    <img src="mq138-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>MQ138 Gas Sensor can be used to monitor the concentration formaldehyde gasses.<br>This Module simplifies using the MQ-138 gas sensor by providing digital as well as analog output which can be interfaced to Microcontrollers, Arduino
                            and Raspberry pi.<br> For the family, the environment of the volatile compounds detection devices, suitable aldehydes, alcohols, ketones, aromatic compounds detected, the gas sensor test concentration range:<br> • 1 to 100
                            ppm benzene<br> • Toluene 10 to 100 ppm<br> • Methanol 5 to 100 ppm<br> • Alcohol 30 to 300 ppm<br> • Acetone 10 to 300 ppm<br> • Formaldehyde 1 to 10 ppm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Characteristics:</h4>
                </button>
                    <div class="content">
                        <h5>• With the signal output LED indication.<br> • 2-way signal output (analog output, and TTL-level output).<br> • TTL output valid signal is low; (low output signal light, which can be accessed microcontroller IO port).<br> • Analog
                            output increases with the concentration, the higher the voltage the higher the concentration.<br> • Aldehydes, alcohols, ketones, aromatic compounds with high sensitivity.<br> • With a long life and reliable stability.<br>                            • Fast response characteristics.<br> • With mounting holes for easy permanent installation.<br> • The probe can plug design for easy testing.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>used for the detection of most of the volatile gases such as:</h4>
                </button>
                    <div class="content">
                        <h5>• Aaldehydes<br> • Alcohols<br> • Ketones<br> • Aromatic compounds
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Module with MQ138 gas sensor and circuitry to enable easy plug and use, just connect power and the module is ready to interface with microcontroller.<br> • Working voltage: DC 5V<br> • Comes with power and digital signal LED
                            indicator
                            <br> • 2-way signal output (analog output, and TTL-level output)<br> • TTL output valid signal is low; (low output signal light, which can be accessed microcontroller IO port)<br> • Analog output increases with the concentration,
                            the higher the voltage the higher the concentration Aldehydes, alcohols, ketones, aromatic compounds with high sensitivity<br> • With a long life and reliable stability<br> • Fast response characteristics<br> • With mounting
                            holes for easy permanent installation<br> • Main chip: LM393, formaldehyde-sensing probe<br> • Size: 35mm x 20mm x 28mm<br> • Weight: 14 g
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Application:</h4>
                </button>
                    <div class="content">
                        <h5>• For home, volatiles environment detection means, be suitable for detection of aldehydes, alcohols, ketones, aromatic compounds, gas sensitive element concentration ranges:<br> o Benzene 1 to 100ppm<br> o Toluene 10 to 100ppm<br>                            o Methanol 5 to 100ppm<br> o Alcohol 30 to 300ppm<br> o Formaldehyde 1 to 10ppm<br> o Acetone 10 to 300ppm
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn54"><img class="image" src="mq214.jpg"></button><br>MQ214
            <div id="myModal54" class="modal">
                <div class="modal-content">
                    <span class="close54">&times;</span>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>MQ - 214 is a Methane (CH4) gas sensor detects the concentrations of methane in the air and outputs its reading as an analog voltage.<br> • 1. Wide detecting scope<br> • 2. Fast response and High sensitivity<br> • 3. Stable and
                            long life<br> • 4. Simple drive circuit<br> They are used in gas leakage detecting equipment in family and industry, are suitable for detecting of methane LPG, i-butane, propane
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage: 4.5V to 5V DC.<br> • High sensitivity to Methane Gas.<br> • Suitable for LPG, LNG, iso-butane, propane, H2.<br> • Interface type: Analog.<br> • Long life and low cost.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn55"><img class="image" src="mq303a.jpg"></button><br>MQ303A
            <div id="myModal55" class="modal">
                <div class="modal-content">
                    <span class="close55">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>MQ303A is a semiconductor sensor for Alcohol detection. It has very good sensitivity and fast response to alcohol, suitable for portable alcohol detector.<br> MQ303A is a semiconductor sensor for Alcohol detection. It has very
                            good sensitivity and fast response to alcohol, suitable for portable alcohol detector.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• High sensitivity<br> • Fast response and resume<br> • long life and low cost<br> • Mini size
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn56"><img class="image" src="mq-306.jpg"></button><br>MQ306A
            <div id="myModal56" class="modal">
                <div class="modal-content">
                    <span class="close56">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>MQ - 306 is a flammable gas sensor detects the concentrations of combustible gas in the air and outputs its reading as an analog voltage.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating Voltage: 4.5V to 5V DC.<br> • High sensitivity to flammable gasses<br> • Suitable for LPG, LNG, iso-butane, propane, H2<br> • Interface type: Analog<br> • Long life and low cost
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Package Content:</h4>
                </button>
                    <div class="content">
                        <h5>MQ - 306 Flammable Gas sensor
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Application:</h4>
                </button>
                    <div class="content">
                        <h5>• Household Gas leakage detection<br> • Portable Gas Detector
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Precaution:</h4>
                </button>
                    <div class="content">
                        <h5>The gasses detected by these gas sensors can be deadly in high concentrations. Always be careful to perform gas tests in well ventilated areas.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn57"><img class="image" src="MQ307A.jpg"></button><br>MQ307A
            <div id="myModal57" class="modal">
                <div class="modal-content">
                    <span class="close57">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The MQ307A is a tin dioxide semiconductor gas sensor which has an excellent performance in CO detection.<br>Using a mini-bead type sensing element with a periodic temperature change operation method, high sensitivity, selectively,
                            small effect from humidity and other remarkable characteristics have been achieved. The MQ307A realizes the development of reliable CO detection devices.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Structure:</h4>
                </button>
                    <div class="content">
                        <h5>Gas sensitive semiconductor material is a mini bead type and a heater coil and electrode wire are embedded in the element. The sensing element is installed in the metal housing which uses double stainless steel mesh (100mesh) in
                            the path of gas flow.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn58"><img class="image" src="mq309a.jpg"></button><br>MQ309A
            <div id="myModal58" class="modal">
                <div class="modal-content">
                    <span class="close58">&times;</span>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>MQ309A is a tin dioxide semiconductor gas sensor which has excellent performance in detecting both CO and Methane. It is miniature sensor adopt changing working temperature periodically to detect with high sensitivity and selectivity,
                            the humidity has little influence on it.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>Gas sensor sensitivity material is a mini bead, a heater coil and electrode wire are embedded in the element，this element is installed in the in the metal housing which uses double stainless steel mesh(100mesh) with anti-explosion
                            function.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn59"><img class="image" src="lm34.png"></button><br>LM34
            <div id="myModal59" class="modal">
                <div class="modal-content">
                    <span class="close59">&times;</span>
                    <img src="LM34-temperature-sensor-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>How to Build a LM34 Temperature Sensor Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>In this project, we will demonstrate how to build temperature sensor circuit using a LM34 sensor.<br> As a temperature sensor, the circuit will read the temperature of the surrounding environment and relay this temperature to us
                            back in degrees fahrenheit.<br> The difference between an LM34 and a LM35 temperature sensor is the LM34 sensor gives out the temperature in degrees fahrenheit, while the LM35 sensor gives out the temperature in degrees celsius.<br>                            The IC we will use to measure the temperature in this circuit is the LM34 IC. We will integrate this with the arduino to measure the temperature.<br> The arduino will then read this measured value from the LM34 and translate
                            into degrees fahrenheit and celsius, which we will be able to read from the computer from the arduino serial monitor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Components Needed:</h4>
                </button>
                    <div class="content">
                        <h5>• Arduino Board<br> • LM34 Temperature Sensor IC<br> • Computer<br> • USB with type A and B connectors<br> We can use any type of arduino board.<br> The LM34 is a low voltage IC which uses approximately +5VDC of power. This is
                            ideal because the arduino's power pin gives out 5V of power. The IC has just 3 pins, 2 for the power supply and one for the analog output.<br> The output pin provides an analog voltage output that is linearly proportional to
                            the fahrenheit temperature. Pin 2 gives an output of 1 millivolt per 0.1°F (10mV per degree). So to get the degree value in fahrenheit, all that must be done is to take the voltage output and divide it by 10- this give out
                            the value degrees in fahrenheit.<br> So, for example, if the output pin, pin 2, gives out a value of 785mV (0.785V), this is equivalent to a temperature of 78.5°C.<br> We can then easily convert this fahrenheit value into celsius
                            by plugging in the appropriate conversion equation. All we must do is write this code and upload it to the arduino to convert this fahrenheit temperature into celsius. The code is shown below.<br> Below is the pinout of the
                            LM34 IC:-<br> Pin 1 receives positive DC voltage in order for the IC to work. This, again, is voltage approximately 5 volts. Pin 3 is the ground, so it receives the ground or negative terminal of the DC power supply. And Pin
                            2 is the output of the IC, outputting an analog voltage in porportion to the temperature it measures.<br> This is the datasheet of the LM34 IC: LM34 Temperature Sensor Datasheet.<br> The arduino, with suitable code, can then
                            interpret this measured analog voltage and output to us the temperature in degrees celsius and fahrenheit.<br> Also to do this project we need a USB cable with a Type A connector on one end and a Type B connector on the other
                            end. This is so that we can hook our arduino to a computer and send it code that it can run to display to us the temperature.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Temperature Sensor Circuit Connections:</h4>
                </button>
                    <div class="content">
                        <h5>circuit connections are:<br> Pin 1 of the LM34 goes into +5V of the arduino<br> Pin 2 of the LM34 goes into analog pin A0 of the arduino<br> Pin 3 of the LM34 goes into ground (GND) of the arduino<br> Now that we have this circuit
                            setup, we now connect the USB cable from the arduino to the computer. The type B side of the connector goes into the arduino and the type A side into the USB port of the computer. Now the computer is connected to the arduino.
                            We can now write code in the processing software to give instructions to the arduino.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>//initializes/defines the output pin of the LM34 temperature sensor<br> int outputpin= 0;<br> //this sets the ground pin to LOW and the input voltage pin to high<br> void setup()<br> {
                            <br> Serial.begin(9600);
                            <br> }
                            <br> //main loop<br> void loop()<br> {
                            <br> int rawvoltage= analogRead(outputpin);<br> float millivolts= (rawvoltage/1024.0) * 5000;<br> float fahrenheit= millivolts/10;<br> Serial.print(fahrenheit);
                            <br> Serial.println(" degrees Fahrenheit, ");<br> float celsius= (fahrenheit - 32) * (5.0/9.0);<br> Serial.print (celsius);<br> Serial.println(" degrees Celsius");<br> delay(1000);
                            <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Code Description:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            The code will now be explained. Before we can get a celsius reading of the temperature, the analog output voltage must first be read.<br>This will be the raw value divided by 1024 times 5000. It is divided by 1024 because a
                            span of 1024 occupies 5V.<br>We get the ratio of the raw value to the full span of 1024 and then multiply it by 5000 to get the millivolt value. Since the output pin can give out a maximum of 5 volts (1024), 1024 represents
                            the possible range it can give out.<br>The raw voltage over this 1024 (value) therefore represents the ratio of how much power the output pin is outputting against this full range. Once we have this ratio, we then multiply
                            it by 5000 to give the millivolt value. This is because there is 5000 millvolts in 5 volts.<br> Once this analog voltage in millivolts is calculated, we then can find the temperature in celsius by the equation: ((fahrenheit
                            - 32) * 5/9).<br> At the end of this program, we put a delay of 3000ms to take the temperature reading every 3 seconds. You can adjust this value to meet your personal preference or program needs.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn60"><img class="image" src="lm335.jpg"></button><br>LM335
            <div id="myModal60" class="modal">
                <div class="modal-content">
                    <span class="close60">&times;</span>
                    <img src="lm335-pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>How to Build a LM335 Temperature Sensor Circuit:</h4>
                </button>
                    <div class="content">
                        <h5> In this project, we will demonstrate how to build temperature sensor circuit using a LM335 sensor.<br> As a temperature sensor, the circuit will read the temperature of the surrounding environment and relay this temperature to
                            us back in degrees Kelvin.<br> The difference between an LM335 and LM34 and LM35 temperature sensors is the LM335 sensor gives out the temperature in degrees Kelvin, while the LM35 sensor gives out the temperature in degrees
                            Celsius and the LM34 sensor gives out the temperature in degrees Fahrenheit. All 3 are calibrated different to output the millivolt voltage reading in proportional to these different units of measurement.<br> The LM335 sensor
                            outputs 10mV/°K. So if the LM335 is giving an output reading of 2.943 (which is 2943mV), then this is equivalent to a temperature of 294.3° Kelvin. All you have to do is take the output reading and divide it by 10 in order
                            to get the temperature output reading. This output reading of 294.3° kelvin is equivalent to 70°F and 21.11°C.<br> The IC we will use to measure the temperature in this circuit is the LM335 IC. We will integrate this with the
                            arduino to measure the temperature. The arduino will then read this measured value from the LM335 and translate into degrees kelvin, fahrenheit and celsius, which we will be able to read from the computer from the arduino serial
                            monitor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Components Needed:</h4>
                </button>
                    <div class="content">
                        <h5>• Arduino Board<br> • LM335 Temperature Sensor IC<br> • Computer<br> • USB with type A and B connectors<br> We can use any type of arduino board.<br> The LM335 is a low voltage IC which uses approximately +5VDC of power. This is
                            ideal because the arduino's power pin gives out 5V of power. The IC has just 3 pins, 2 for the power supply and one for the analog output.<br> The output pin provides an analog voltage output that is linearly proportional to
                            the fahrenheit temperature. Pin 2 gives an output of 1 millivolt per 0.1°F (10mV per degree). So to get the degree value in fahrenheit, all that must be done is to take the voltage output and divide it by 10- this give out
                            the value degrees in fahrenheit.<br> So, for example, if the output pin, pin 2, gives out a value of 785mV (0.785V), this is equivalent to a temperature of 78.5°K.<br> We can then easily convert this value into fahrehnheit
                            and celsius by plugging in the appropriate conversion equations.<br> All we must do is write this code and upload it to the arduino to convert this kelvin temperature into fahrenheit and celsius. The code is shown below.<br>                            Pin 1 is the Adjustable Pin (Adj). This allows us to calibrate the temperature sensor if we want a more precise temperature readout. It isn't required. Pin 2 is the output pin. We attach this pin to analog pin A0 of the arduino
                            board. We then take a 2KΩ resistor and connect that to the 5V terminal of the arduino. Pin 3 is the ground pin and connects to the ground (GND) terminal of the arduino.<br> This is the datasheet of the LM335 IC: LM335 Temperature
                            Sensor IC Datasheet.<br> The arduino, with suitable code, can then interpret this measured analog voltage and output to us the temperature in degrees Kelvin, Celsius, and Fahrenheit.<br> Also to do this project we need a USB
                            cable with a Type A connector on one end and a Type B connector on the other end. This is so that we can hook our arduino to a computer and send it code that it can run to display to us the temperature.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Temperature Sensor Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>So you circuit connections are:<br> Pin 1 of the LM335 is unconnected<br> Pin 2 of the LM335 goes into analog pin A0 of the arduino<br> Pin 3 of the LM335 goes into ground (GND) of the arduino<br> Now that we have this circuit
                            setup, we now connect the USB cable from the arduino to the computer. The type B side of the connector goes into the arduino and the type A side into the USB port of the computer. Now the computer is connected to the arduino.
                            We can now write code in the processing software to give instructions to the arduino.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>//initializes/defines the output pin of the LM335 temperature sensor<br> int outputPin= 0;<br> //this sets the ground pin to LOW and the input voltage pin to high<br> void setup()<br> {
                            <br> Serial.begin(9600);
                            <br> }
                            <br> //main loop<br> void loop()<br> {
                            <br> int rawvoltage= analogRead(outputPin);<br> float millivolts= (rawvoltage/1024.0) * 5000;<br> float kelvin= (millivolts/10);<br> Serial.print(kelvin);
                            <br> Serial.println(" degrees Kelvin");<br> float celsius= kelvin - 273.15;<br> Serial.print(celsius);
                            <br> Serial.println(" degrees Celsius");<br> float fahrenheit= ((celsius * 9)/5 +32);<br> Serial.print(fahrenheit);
                            <br> Serial.println(" degrees Fahrenheit");<br> delay(3000);
                            <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code Decsription:</h4>
                </button>
                    <div class="content">
                        <h5>
                            The code will now be explained. Before we can get a Kevlin reading of the temperature, the analog output voltage must first be read. This will be the raw value divided by 1024 times 5000. <br>It is divided by 1024 because a
                            span of 1024 occupies 5V. We get the ratio of the raw value to the full span o1024 and then multiply it by 5000 to get the millivolt value. Since the output pin can give out a maximum of 5 volts (1024), 1024 represents the
                            full possible range it can give out.<br>The raw voltage over this 1024 (value) therefore represents the ratio of how much power the output pin is outputting against this full range. Once we have this ratio, we then multiply
                            it by 5000 to give the millivolt value.<br>This is because there is 5000 millvolts in 5 volts. Once this analog voltage in millivolts is calculated, we then can find the temperature in kelvin by the equation: (millivolts/10).<br>                            To get the equivalent temperature in Celsius, we subtract the Kelvin value by 273.15. Once we obtain this Celsius value, we can convert into Fahrenheit with the following equation: ((celsius * 9)/5 +32).<br> At the end of this
                            program, we put a delay of 3000ms to take the temperature reading every 3 seconds. You can adjust this value to meet your personal preference or program needs.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn61"><img class="image" src="lm35.jpg"></button><br>LM35DZ
            <div id="myModal61" class="modal">
                <div class="modal-content">
                    <span class="close61">&times;</span>
                    <img src="LM35-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>How to Build a LM35dz Temperature Sensor Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>In this project, we will demonstrate how to build temperature sensor circuit using a LM35 sensor.<br> As a temperature sensor, the circuit will read the temperature of the surrounding environment and relay thi temperature to us
                            back in degrees celsius.<br> The IC we will use to measure the temperature is the LM35 IC. We will integrate this with the arduino to measure the temperature.
                            <br> The arduino will then read this measured value from the LM35 and translate into degrees fahrenheit and celsius, which we will be able to read from the computer from the arduino serial monitor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Components Needed to Build the LM35 Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>• Arduino Board<br> • LM35 Temperature Sensor IC<br> • Computer<br> • USB with type A and B connectors<br> We can use any type of arduino board.<br> The LM35 is a low voltage IC which uses approximately +5VDC of power. This is
                            ideal because the arduino's power pin gives out 5V of power. The IC has just 3 pins, 2 for the power supply and one for the analog output.<br> The output pin provides an analog voltage output that is linearly proportional to
                            the celsius (centigrade) temperature. Pin 2 gives an output of 1 millivolt per 0.1°C (10mV per degree). oSo to get the degree value in celsius, all that must be done is to take the voltage output and divide it by 10- this give
                            out the value degrees in celsius.<br> So, for example, if the output pin, pin 2, gives out a value of 315mV (0.315V), this is equivalent to a temperature of 31.5°C.<br> We can then easily convert this celsius value into fahrenheit
                            by plugging in the appropriate conversion equation. All we must do is write this code and upload it to the arduino to convert this celsius temperature into fahrenheit. The code is shown below.<br> Below is the pinout of the
                            LM35 IC:<br> Pin 1 receives positive DC voltage in order for the IC to work. This, again, is voltage approximately 5 volts. Pin 3 is the ground, so it receives the ground or negative terminal of the DC power supply. And Pin
                            2 is the output of the IC, outputting an analog voltage in porportion to the temperature it measures.<br> This is the datasheet of the LM35 IC: LM35 Temperature Sensor IC Datasheet.<br> The arduino, with suitable code, can
                            then interpret this measured analog voltage and output to us the temperature in degrees celsius and fahrenheit.<br> Also to do this project we need a USB cable with a Type A connector on one end and a Type B connector on the
                            other end. This is so that we can hook our arduino to a computer and send it code that it can run to display to us the temperature.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Temperature Sensor Circuit Schematic:</h4>
                </button>
                    <div class="content">
                        <h5>So you circuit connections are:<br> Pin 1 of the LM35 goes into +5V of the arduino<br> Pin 2 of the LM35 goes into analog pin A0 of the arduino<br> Pin 3 of the LM35 goes into ground (GND) of the arduino<br> Now that we have this
                            circuit setup, we now connect the USB cable from the arduino to the computer. The type B side of the connector goes into the arduino and the type A side into the USB port of the computer. Now the computer is connected to the
                            arduino. We can now write code in the processing software to give instructions to the arduino.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code for Temperature Sensor Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>//initializes/defines the output pin of the LM35 temperature sensor<br> int outputpin= 0;<br> //this sets the ground pin to LOW and the input voltage pin to high<br> void setup()<br> {
                            <br> Serial.begin(9600);
                            <br> }
                            <br> //main loop<br> void loop()<br> {
                            <br> int rawvoltage= analogRead(outputpin);<br> float millivolts= (rawvoltage/1024.0) * 5000;<br> float celsius= millivolts/10;<br> Serial.print(celsius);
                            <br> Serial.print(" degrees Celsius, ");<br> Serial.print((celsius * 9)/5 + 32);<br> Serial.println(" degrees Fahrenheit");<br> delay(1000);
                            <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>
                            The code will now be explained. Before we can get a celsius reading of the temperature, the analog output voltage must first be read. This will be the raw value divided by 1024 times 5000. It is divided by 1024 because a span of 1024 occupies 5V.<br>We
                            get the ratio of the raw value to the full span of 1024 and then multiply it by 5000 to get the millivolt value. Since the output pin can give out a maximum of 5 volts (1024), 1024 represents the possible range it can give
                            out.
                            <br>The raw voltage over this 1024 (value) therefore represents the ratio of how much power the output pin is outputting against this full range. Once we have this ratio, we then multiply it by 5000 to give the millivolt value.
                            This is because there is 5000 millvolts in 5 volts.<br> Once this analog voltage in millivolts is calculated, we then can find the temperature in fahrenheit by the equation: ((celsius * 9)/5 + 32).<br> At the end of this program,
                            we put a delay of 5000ms to take the temperature reading every 5 seconds. You can adjust this value to meet your personal preference or program needs.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn62"><img class="image" src="bmp180.jpg"></button><br>BMP180
            <div id="myModal62" class="modal">
                <div class="modal-content">
                    <span class="close62">&times;</span>
                    <img src="BMP180-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>BMP180 is one of sensor of BMP XXX series. They are all designed to measure Barometric Pressure or Atmospheric pressure.<br>BMP180 is a high precision sensor designed for consumer applications. Barometric Pressure is nothing but
                            weight of air applied on everything. The air has weight and wherever there is air its pressure is felt.<br>BMP180 sensorsenses that pressure and provides that information in digital output. Also the temperature affects the
                            pressure and so we need temperature compensated pressure reading. To compensate, the BM180 also has good temperature sensor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>BMP180 is available in two modules. One is Five pin module and other is Four pin module. With Five pin module we have additional +3.3V pin which is absent in four pin module. Other than that the functioning is same.<br> Pin Name------Description<br>                            VCC------Connected to +5V<br> GND------Connected to ground.<br> SDA------Serial Data pin (I2C interface)<br> SCL------Serial Clock pin (I2C interface)<br> 3.3V------If +5V is not present. Can power module by connecting +3.3V
                            to this pin.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Can measure temperature and altitude.<br> • Pressure range: 300 to 1100hPa<br> • High relative accuracy of ±0.12hPa<br> • Can work on low voltages<br> • 3.4Mhz I2C interface<br> • Low power consumption (3uA)<br> • Pressure conversion
                            time: 5msec<br> • Potable size
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Operating voltage of BMP180: 1.3V – 3.6V<br> • Input voltage of BMP180MODULE: 3.3V to 5.5V<br> • Peak current : 1000uA<br> • Consumes 0.1uA standby<br> • Maximum voltage at SDA , SCL : VCC + 0.3V<br> • Operating temperature:
                            -40ºC to +80ºC
                        </h5>
                    </div>
                    <img src="Arduino-Barometric-arduino.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Equivalent Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>BMP280, BMP085, etc</h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to Use BMP180 MODULE:</h4>
                </button>
                    <div class="content">
                        <h5>There are many reasons why BMP180 is preferred over other modules, here are a few reasons:-<br> Case1: Where you want accurate atmospheric pressure. Over many modules present in market, BMP180 measures barometric pressure more
                            accurately.
                            <br> Case2: Where power consumption is issue. BMP180 MODULE consumes very less power to function. So this module can be used on systems which work on battery like smart watches and mobile phones.<br> Case3: Where high speed
                            communication is of need. BMP180 MODULE capable of communicating with high speed TWI interface.<br> With altitude measure, high speed sense and temperature sensor on board the use of BMP180 module is promoted even further than
                            other modules.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use BMP180 MODULE:</h4>
                </button>
                    <div class="content">
                        <h5>As seen in PIN DIAGRAM. There are only two pins present to communicate with the module. And this communication is I2C interface. The data is sent to the module or received from the module though I2C interface.<br>So we have to
                            get the information of barometric pressure and temperature through this interface. A typical circuit diagram of BMP180 with ARDUINO is shown below.<br> As shown in circuit diagram the module is connected to +5V power supply
                            or to ARDUINO UNO Vout pin. The module can work on +5V regulated power and higher voltage may damage the module. The I2C interface is established as shown in figure.<br>All you need to do is connect SDA PIN of module to SDA
                            PIN of ARDUINO and SCL PIN of module to SCL of ARDUINO.<br> Although connecting to BMP180 sensor module is easy communicating with it is not easy. The data exchange between controller of ARDUINO and module is really complex.<br>Usually
                            to send information to module or receive the information from it we have to follow the protocol. This protocol is sequence of steps to be followed without an error. These steps are complex to follow for starters.<br>So using
                            libraries which are pre written for the module is ideal. Using libraries makes the communication easy. All you need to do is download these libraries and call them in programs.<br> Once the header file is included, the ARDUINO
                            follows the protocol automatically and decodes the required data. Once this data is available we can perform functions of desire.<br> Hence by using libraries we can use BMP180 module easily.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Indoor navigation<br> • Sport devices<br> • Computer Peripherals<br> • GPS<br> • Weather forecast<br> • Vertical velocity Indication<br> • Hobby projects
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn63"><img class="image" src="TMP36.jpg"></button><br>TMP36
            <div id="myModal63" class="modal">
                <div class="modal-content">
                    <span class="close63">&times;</span>
                    <img src="tmp36outpin.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The TMP36 is a low voltage, precision centigrade temperature sensor. It provides a voltage output that is linearly proportional to the Celsius temperature.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>GND</th>
                                    <th>Ground pin</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Vcc</th>
                                    <th>Positive supply pin</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Vout</th>
                                    <th>Output voltage pin</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Operate on low voltage<br> • 10 mV/°C scale factor<br> • ±2°C Temperature accuracy<br> • ±0.5°C linearity<br> • External Calibration not required<br> • Stable with large capacitive loads<br> • Specified −40°C to +125°C, operation
                            to +150°C<br> • Less than 50 µA quiescent current<br> • Auto Shutdown current 0.5 µA max<br> • Low self-heating Qualified for automotive applications
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>• Supply Voltage: 2.7 V to 5.5 V<br> • Supply Current up to 50uA<br> • Ramp-Up Rate 3°C/sec<br> • Ramp-Down Rate −6°C/sec<br> • Offset Voltage: 0.5V<br> • Output voltage at 25°C: 750mV<br> • Device turning ON time: 0.5ms<br> •
                            Operating Temperature Range: −55°C to +150°C<br> • Storage Temperature Range: −65°C to +160°C<br> • Package Available: TO-92; SOIC_N; SOT-23
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Equivalent Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>TMP35, TMP37
                        </h5>
                    </div>
                    <img src="tmp36-arduino.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Alternate Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>LM35, LM45, MCP9700, MCP9700A, TC1046, TC1047, MCP9701, MCP9701A, DHT11
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use TMP36?:</h4>
                </button>
                    <div class="content">
                        <h5>As per the TMP36 example circuit diagram shown above, the characteristics of output voltage results as 1 mV/°F but is referenced to the common ground of the circuit.<br>Also, there is a 58 mV (58°F) offset in the output voltage.<br>                            Let’s take an example:<br> The output voltage of the circuit reads 18 mV if the temperature of TMP36 is -40°F environment and 315 mV at +257°F.<br>The offset voltage refers to the difference of 58(offset value) between temperature
                            and the output voltage.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Environmental control systems<br> • Thermal protection<br> • Industrial process control<br> • Fire alarms<br> • Power system monitors<br> • CPU thermal management
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn64"><img class="image" src="17.jpg"></button><br>BME280
            <div id="myModal64" class="modal">
                <div class="modal-content">
                    <span class="close64">&times;</span>
                    <img src="bme280-pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Bosch has stepped up their game with their new BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity!<br>This sensor is great for all sorts of weather/environmental sensing and can even be used
                            in both I2C and SPI!<br> This precision sensor from Bosch is the best low-cost sensing solution for measuring humidity with ±3% accuracy, barometric pressure with ±1 hPa absolute accuraccy, and temperature with ±1.0°C accuracy.<br>Because
                            pressure changes with altitude, and the pressure measurements are so good, you can also use it as an altimeter with ±1 meter accuracy!<br> The BME280 is the next-generation of sensors from Bosch, and is the upgrade to the BMP085/BMP180/BMP183
                            - with a low altitude noise<br>of 0.25m and the same fast conversion time. It has the same specifications, but can use either I2C or SPI.<br>For simple easy wiring, go with I2C. If you want to connect a bunch of sensors without
                            worrying about I2C address collisions, go with SPI.<br> Nice sensor right? So we made it easy for you to get right into your next project.<br>The surface-mount sensor is soldered onto a PCB and comes with a 3.3V regulator and
                            level shifting so you can use it with a 3V or 5V logic microcontroller without worry. We even wrote up a nice tutorial with wiring diagrams, schematics, libraries and examples to get you running in 10 minutes!<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Power Pins:</h4>
                </button>
                    <div class="content">
                        <h5>• Vin - this is the power pin. Since the sensor chip uses 3 VDC, we have included a voltage regulator on board that will take 3-5VDC and safely convert it down. To power the board, give it the same power as the logic level of your
                            microcontroller - e.g. for a 5V micro like Arduino, use 5V<br> • 3Vo - this is the 3.3V output from the voltage regulator, you can grab up to 100mA from this if you like<br> • GND - common ground for power and logic.<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>SPI Logic pins:</h4>
                </button>
                    <div class="content">
                        <h5>All pins going into the breakout have level shifting circuitry to make them 3-5V logic level safe. Use whatever logic level is on Vin!<br> • SCK - This is the SPI Clock pin, its an input to the chip<br> • SDO - this is the Serial
                            Data Out / Master In Slave Out pin, for data sent from the BMP183 to your processor<br> • SDI - this is the Serial Data In / Master Out Slave In pin, for data sent from your processor to the BME280<br> • CS - this is the Chip
                            Select pin, drop it low to start an SPI transaction. Its an input to the chip<br> If you want to connect multiple BME280's to one microcontroller, have them share the SDI, SDO and SCK pins. Then assign each one a unique CS
                            pin.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>I2C Logic pins:</h4>
                </button>
                    <div class="content">
                        <h5>• SCK - this is also the I2C clock pin, connect to your microcontrollers I2C clock line.<br> • SDI - this is also the I2C data pin, connect to your microcontrollers I2C data line.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn65"><img class="image" src="16.jpg"></button><br>DS18B20 Temperature Sensor
            <div id="myModal65" class="modal">
                <div class="modal-content">
                    <span class="close65">&times;</span>
                    <img src="DS18B20-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>DS18B20 is a temperature sensor which can measure temperature from -55oC to +125oC with an accuracy of +- 5%.<br>It follows 1 wire protocol which has revolutionized the digital world. Because of its 1 wire protocol, you can control
                            multiple sensors from a single pin of Microcontroller.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>GND</th>
                                    <th>Connect to the ground of the circuit</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Vcc</th>
                                    <th>Powers the Sensor, can be 3.3V or 5V</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Vout</th>
                                    <th>This pin gives output the temperature value which can be read using 1-wire method</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>• Programmable Digital Temperature Sensor<br> • Communicates using 1-Wire method<br> • Operating voltage: 3V to 5V<br> • Temperature Range: -55°C to +125°C<br> • Accuracy: ±0.5°C<br> • Output Resolution: 9-bit to 12-bit (programmable)<br>                            • Unique 64-bit address enables multiplexing<br> • Conversion time: 750ms at 12-bit <br> • Programmable alarm options<br> • Available as To-92, SOP and even as a waterproof sensor
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Alternative Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>Thermocouple, TMP100, LM75, DHT11, SHT15, LM35DZ, TPA81, D6T
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Equivalent Temperature Sensors:</h4>
                </button>
                    <div class="content">
                        <h5>DS18S20
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use DS18B20 Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The DS18B20 is a 1-wire programmable Temperature sensor from maxim integrated. It is widely used to measure temperature in hard environments like in chemical solutions, mines or soil etc.<br>The constriction of the sensor is rugged
                            and also can be purchased with a waterproof option making the mounting process easy.<br>It can measure a wide range of temperature from -55°C to +125° with a decent accuracy of ±5°C.<br>Each sensor has a unique address and
                            requires only one pin of the MCU to transfer data so it a very good choice for measuring temperature at multiple points without compromising much of your digital pins on the microcontroller.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use the DS18B20 Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The sensor works with the method of 1-Wire communication. It requires only the data pin connected to the microcontroller with a pull up resistor and the other two pins are used for power as shown below.<br> The pull-up resistor
                            is used to keep the line in high state when the bus is not in use. The temperature value measured by the sensor will be stored in a 2-byte register inside the sensor.<br>This data can be read by the using the 1- wire method
                            by sending in a sequence of data. There are two types of commands that are to be sent to read the values, one is a ROM command and the other is function command.<br>The address value of each ROM memory along with the sequence
                            is given in the datasheet below. You have to read through it to understand how to communicate with the sensor<br>. If you are planning to interface it with Arduino, then you need not worry about all these. You can develop the
                            readily available library and use the in-built functions to access the data.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Measuring temperature at hard environments<br> • Liquid temperature measurement<br> • Applications where temperature has to be measured at multiple points
                        </h5>
                    </div>
                </div>
            </div>
        </div>

        <div class="item"><button class="effe" id="myBtn66"><img class="image" src="pulse-sensor.jpg"></button><br>Pulse Sensor - Heart Rate Detector
            <div id="myModal66" class="modal">
                <div class="modal-content">
                    <span class="close66">&times;</span>
                    <img src="Pulse-Sensor-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>• Biometric Pulse Rate or Heart Rate detecting sensor<br> • Plug and Play type sensor<br> • Operating Voltage: +5V or +3.3V<br> • Current Consumption: 4mA<br> • Inbuilt Amplification and Noise cancellation circuit.<br> • Diameter:
                            0.625”
                            <br> • Thickness: 0.125” Thick
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin no.</th>
                                    <th>Pin Name</th>
                                    <th>Wire Colour</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>GND</th>
                                    <th>Black</th>
                                    <th>Connected to the ground of the system</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Vcc</th>
                                    <th>Red</th>
                                    <th>Connect to +5V or +3.3V supply voltage</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>Signal</th>
                                    <th>Purple</th>
                                    <th>Pulsating output signal.</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How Pulse sensor works:</h4>
                </button>
                    <div class="content">
                        <h5>The working of the Pulse/Heart beat sensor is very simple.<br>The sensor has two sides, on one side the LED is placed along with an ambient light sensor and on the other side we have some circuitry. This circuitry is responsible
                            for the amplification and noise cancellation work.<br>The LED on the front side of the sensor is placed over a vein in our human body. This can either be your Finger tip or you ear tips, but it should be placed directly on
                            top of a vein.<br> Now the LED emits light which will fall on the vein directly. The veins will have blood flow inside them only when the heart is pumping, so if we monitor the flow of blood we can monitor the heart beats as
                            well. If the flow of blood is detected then the ambient light sensor will pick up more light since they will be reflect ted by the blood, this minor change in received light is analysed over time to determine our heart beats.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use Pulse sensor:</h4>
                </button>
                    <div class="content">
                        <h5>Using the pulse sensor is straight forward, but positioning it in the right way matters.<br>Since all the electronics on the sensor are directly exposed it is also recommended to cover the sensor with hot glue, vinyl tape or other
                            non conductive materials. Also it is not recommended to handle these sensors with wet hands.<br>The flat side of the sensor should be placed on top of the vein and a slight presser should be applied on top of it, normally clips
                            or Velcro tapes are used to attain this pressure.<br> To use the sensor simply power it using the Vcc and ground pins, the sensor can operate both at +5V or 3.3V system.<br>Once powered connect the Signal pin to the ADC pin
                            of the microcontroller to monitor the change in output voltage.<br>If you are using a development board like Arduino then you can use the readily available code which will make things a lot easier. Refer the datasheet at the
                            bottom of the page for more information on how to interface the sensor with Arduino and how to mount it. The schematics of the sensor, code and processing sketch can be obtained from the Sprakfun product page.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>• Sleep Tracking<br> • Anxiety monitoring<br> • Remote patient monitoring/alarm system<br> • Health bands<br> • Advanced gaming consoles
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn67"><img class="image" src="ecg.jpg"></button><br>AD8232 ECG Monitor Sensor Module
            <div id="myModal67" class="modal">
                <div class="modal-content">
                    <span class="close67">&times;</span>
                    <img src="heart-rate-sensor-arduino.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                        <h4>Descriptions:</h4>
                    </button>
                    <div class="content">
                        <h5>The AD8232 from Analog Devices is a dedicated single lead heart rate monitor front end integrated circuit.<br>The AD8232 is an integrated signal conditioning block for ECG and other biopotential measurement applications. It is
                            designed to extract, amplify, and filter small biopotential signals in the presence of noisy conditions, such as those created by motion or remote electrode placement.<br> This design allows for an ultralow power analog-to-digital
                            converter (ADC) or an embedded microcontroller to acquire the output signal easily.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>What is ECG?:</h4>
                    </button>
                    <div class="content">
                        <h5>Electrocardiography (ECG or EKG) is the method of recording the electrical activity of heart over a period of time using the electrodes placed on the skin.<br> This ECG wave has two sections as PR interval and QT interval, by using
                            the AD8232 IC we can get noise less information.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Heart Monitor AD8232 Board:</h4>
                    </button>
                    <div class="content">
                        <h5>The simple and easy to use breakout board for heart rate monitoring from Sparkfun. This board measures electrical activity of heart through the Electrode pads placed on the skin. By Interfacing this board with Arduino we can get
                            ECG graph through Processing IDE window.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Pin Configuration:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Board Label</th>
                                    <th>Pin Function</th>
                                    <th>Arduino Connection</th>
                                </tr>
                                <tr>
                                    <th>GND</th>
                                    <th>ground</th>
                                    <th>GND</th>
                                </tr>
                                <tr>
                                    <th>Vcc</th>
                                    <th>3.3v power supply</th>
                                    <th>3.3V</th>
                                </tr>
                                <tr>
                                    <th>Output</th>
                                    <th>output signal</th>
                                    <th>A0</th>
                                </tr>
                                <tr>
                                    <th>LO-</th>
                                    <th>leads off detect-</th>
                                    <th>11</th>
                                </tr>
                                <tr>
                                    <th>LO+</th>
                                    <th>leads off detect-</th>
                                    <th>10</th>
                                </tr>
                                <tr>
                                    <th>SDN</th>
                                    <th>shutdown</th>
                                    <th>not used</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Electrode Pads:</h4>
                    </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Cable Color</th>
                                    <th>Signal</th>
                                </tr>
                                <tr>
                                    <th>black</th>
                                    <th>RA(right arm)</th>
                                </tr>
                                <tr>
                                    <th>blue</th>
                                    <th>LA(left arm)</th>
                                </tr>
                                <tr>
                                    <th>red</th>
                                    <th>RL(right leg)</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>AD8232 Hookup with Arduino:</h4>
                    </button>
                    <div class="content">
                        <h5>We can use the electrode jack or else pin holes for electrodes. Connect corresponding electrode pads in skin and then provide 3.3V and GND power supply from the Arduino board, the SDN (shutdown) pin is not connected to any part.
                            Output from the breakout board is taken to Arduino’s A0 (Analog input 0) pin. To detect the Leads off situation LO – , LO + are connected to Arduino digital pin D11 and D10 respectively.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Arduino Code:</h4>
                    </button>
                    <div class="content">
                        <h5>Heart_Rate_Display.inoDemo Program for AD8232 Heart Rate sensor.<br> Casey Kuhns @ SparkFun Electronics 6/27/2014<br> https://github.com/sparkfun/AD8232_Heart_Rate_Monitor
                            <br> void setup() {<br> // initialize the serial communication:<br> Serial.begin(9600);
                            <br> pinMode(10, INPUT); // Setup for leads off detection LO +<br> pinMode(11, INPUT); // Setup for leads off detection LO -<br> }
                            <br> void loop() {<br> if((digitalRead(10) == 1)||(digitalRead(11) == 1)){<br> Serial.println('!');
                            <br> }
                            <br> else{
                            <br> // send the value of analog input 0:<br> Serial.println(analogRead(A0));
                            <br> }
                            <br> //Wait for a bit to keep serial data from saturating<br> delay(1);
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn68"><img class="image" src="ir-sensor.jpg"></button><br>IR Proximity Sensor
            <div id="myModal68" class="modal">
                <div class="modal-content">
                    <span class="close68">&times;</span>
                    <img src="Connection Diagram.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is a multipurpose infrared sensor which can be used for obstacle sensing, color detection(between basic contrasting colors), fire detection, line sensing, etc and also as an encoder sensor. The sensor provides a digital output.<br>The
                            sensor outputs a logic one(+5V) at the digital output when an object is placed in front of the sensor and a logic zero(0V), when there is no object in front of the sensor.<br>An on board LED is used to indicate the presence
                            of an object. This digital output can be directly connected to an Arduino, Raspberry Pi, AVR, PIC, 8051 or any other microcontroller to read the sensor output.<br> IR sensors are highly susceptible to ambient light and the
                            IR sensor on this sensor is suitably covered to reduce effect of ambient light on the sensor.<br>T For maximum, range the on board potentiometer should be used to calibrate the sensor.<br> To set the potentiometer, use a screw
                            driver and turn the potentiometer till the output LED just turns off.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Feature:</h4>
                </button>
                    <div class="content">
                        <h5>• Can be used for obstacle sensing, color detection(between basic contrasting colors), fire detection, line sensing, etc and also as an encoder sensor<br> • Input Voltage: 5V DC<br> • Comes with an easy to use digital output<br>                            • Can be used for wireless communication and sensing IR remote signals<br> • Sensor comes with ambient light protection<br> • The sensor a hole of 3mm diameter for easy mounting.
                        </h5>
                    </div>
                    <img src="irpinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>IR Sensor have three to four Lines<br> 1. +5V VCC<br> 2. GND<br> 3. D0 or OUT (Digital Output)<br> 4. A0 - Analog Out
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Arduino Connection:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino interfacing with IR Proximity sensor is very simple like interfacing of Switch with the arduino, The obstacle sensor gives logic 0 as output when there is no obstacle in front of it, and when obstacle is placed in front
                            of it, it will give logic high output i.e. +5V.<br>We need to read these logic changes on the arduino. using digitalRead Command. In my design I have connected its output to Pin 2 of Arduino You can use any other IO line as
                            per your requirement.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>ERxample Code:</h4>
                </button>
                    <div class="content">
                        <h5>/*<br> IR Proximity Sensor interface code<br> Turns on an LED on when obstacle is detected, else off.<br> blog.circuits4you.com 2016<br> */
                            <br> const int ProxSensor=2;<br> void setup() {<br> // initialize the digital pin as an output.<br> // Pin 13 has an LED connected on most Arduino boards:<br> pinMode(13, OUTPUT);<br> //Pin 2 is connected to the output of proximity
                            sensor
                            <br> pinMode(ProxSensor,INPUT);
                            <br> }
                            <br> void loop() {<br> if(digitalRead(ProxSensor)==HIGH) //Check the sensor output<br> {
                            <br> digitalWrite(13, HIGH); // set the LED on<br> }
                            <br> else
                            <br> {
                            <br> digitalWrite(13, LOW); // set the LED off<br> }
                            <br> delay(100); // wait for a second<br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Testing:</h4>
                </button>
                    <div class="content">
                        <h5>1. Place the object in front of IR proximity sensor and observe the change in LED<br> connected to Pin 13 (on board LED)<br> 2. When you remove object you will see it gets turned off.<br> 3. You can program this to display message
                            Obstacle detected using LCD.<br> 4. Refer LCD Interfacing Tutorial<br> 5. For measuring Linear distance using IR Sensors we have Sharp Distance sensor.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn69"><img class="image" src="14.jpg"></button><br>Photo cell (CdS photoresistor)
            <div id="myModal69" class="modal">
                <div class="modal-content">
                    <span class="close69">&times;</span>
                    <img src="photocell.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>CdS cells are little light sensors. As the squiggly face is exposed to more light, the resistance goes down. When its light, the resistance is about 5-10KΩ, when dark it goes up to 200KΩ.<br> To use, connect one side of the photo
                            cell (either one, its symmetric) to power (for example 5V) and the other side to your microcontroller's analog input pin.<br>Then connect a 10K pull-down resistor from that analog pin to ground. The voltage on the pin will
                            be 2.5V or higher when its light out and near ground when its dark.
                        </h5>
                    </div>
                    <img src="photocell-arduino.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>• Length: 4.46mm/0.18in<br> • Width: 5mm/0.20in<br> • Height: 2.09mm/0.08in<br> • Weight: 0.25g/0.01oz
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn70"><img class="image" src="laser-diode.jpg"></button><br>laser-diode
            <div id="myModal70" class="modal">
                <div class="modal-content">
                    <span class="close70">&times;</span>
                    <img src="lasermodule_diag.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Description:</h4>
                </button>
                    <div class="content">
                        <h5>This 100mW laser module emits a small intense focused beam of visible red light. The module can be used with an Arduino and photo resistor module to perform basic remote signaling.<br> Warning:
                            <br>This is a low power laser device, however as with all laser devices care should be taken when in use.<br>You should never look directly in to its beam or point the laser at another person. Doing so may cause permanent eye
                            damage.
                            <br> This item is not suitable for children.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Operating Voltage 5V<br> Output Power 5mW<br> Wavelength 650nm<br> Operating Current less than 40mA<br> Working Temperature -10°C ~ 40°C [14°F to 104°F]<br> Dimensions 18.5mm x 15mm [0.728in x 0.591in]
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>int laserPin = 13;<br> void setup() {<br> pinMode(laserPin, OUTPUT); // Define the digital output interface pin 13<br> }
                            <br> void loop() {<br> digitalWrite(laserPin, HIGH); // Open the laser head<br> delay(1000); // Delay one second<br> digitalWrite(laserPin, LOW); // Close the laser head<br> delay(1000);
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn71"><img class="image" src="Laser_proximity_sensor.jpg"></button><br>Laser_proximity_sensor
            <div id="myModal71" class="modal">
                <div class="modal-content">
                    <span class="close71">&times;</span>
                    <img src="laser-proximity.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is LASER proximity sensor. It is used for detecting objects passing in the LASER light pass by reflecting the projected LASER. This proximity sensor (object detector) is excellent in detecting very small size objects in the
                            detection range. This is because the LASER light ray is very focused and almost have no divergence over small distances.<br> The sensor is easy to use, have 3 pins: power, ground and signal. It includes LASER source, LASER
                            detector, signal amplification (conditioning circuit). It can be used with Arduino or any other micro-controller.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Effective distance : 0.8m(typical) :1.5m(max)<br> Power: 5.0 V<br> Dimension: 47.7mm * 17.9mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>Obstacle detection<br> Pipeline counter<br> Smart robot<br> Obstacle-avoiding
                            <br>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn72"><img class="image" src="pir-sensor.jpg"></button><br>Passive IR-sensor
            <div id="myModal72" class="modal">
                <div class="modal-content">
                    <span class="close72">&times;</span>
                    <img src="PIR-Sensor-Pinout.png" height="400px" width="49%" alt="image is here"><img src="Arduino-motion-sensor-circuit.jpg" height="400px" width="45%" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The term PIR is the short form ofthe PassiveInfra Red. The term “passive”indicates that the sensor does not actively take part in the process, whichmeans, it does not emit the referred IR signals itself, rather passively detects
                            the infrared radiationscoming from thehuman body in the surrounding area.<br><br> The detected radiations are converted into an electrical charge, which is proportional to the detected level of the radiation.
                            <br>Then this charge is further improved by a built in FET and fed to the output pin of the device which becomes applicable to an external circuit for further triggering and amplification of the alarm stages.<br>The PIR sensor
                            range is up to 10 meters at an angle of +15o or -15o.<br><br> The Passive infrared sensors consist of three pins as indicated in the diagram shown above.<br>
                            <img src="9-10-2014-10-30-23-AM.jpg" class="collapsible_image" alt="image is here"><br> 1.Pin1 corresponds to the drain terminal of the device, which should be connected to the positive supply 5V DC.<br> 2.Pin2 corresponds
                            to the source terminal of the device, which should be connected to the ground terminal via a 100K or 47K resistor. The Pin2 is the output pin of the sensor, and the detected IR signal is carried forward to an amplifier from
                            the pin 2 of the sensor.<br> 3.Pin3 of the sensor is connected to the ground.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PIR Sensor’sWorking Principle:</h4>
                </button>
                    <div class="content">
                        <h5>The PIR sensors are more complicated thanthe other sensors as they consists of two slots. These slots are made of a special material which is sensitive to IR.<br>The Fresnel lens is used to see that the two slots of the PIR can
                            see out past some distance. When the sensor is inactive, then the two slots sense the same amount of IR.The ambient amount radiates from the outdoors, walls or room,etc.<br>When a human body or any animal passes by, then it
                            intercepts the first slot of the PIR sensor. This causes a positive differential change between the two bisects.When a human body leaves the sensing area,the sensor generates a negative differential change between the two bisects.<br>The
                            infrared sensor itself is housed in a hermetically sealed metal to improve humidity/temperature/noise/immunity. There is a window which is made of typically coated silicon material to protect the sensing element.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>A Motion Detection Circuit Using PIR Sensor:</h4>
                </button>
                    <div class="content">
                        <img src="9-10-2014-10-31-09-AM.jpg" class="collapsible_image" alt="image is here"><br>
                        <h5>n the above segment, we have learned the pin outs of a PIR sensor, now let’s move on to study a simple application of the PIR sensor. The below diagram depicts a motion detector PIR sensor circuit.<br>In the presence of a human
                            IR energy or radiation, the infrared sensor detects the energy and immediately converts it into minute electrical pulses, enough to activate the transistor BC547 into conduction and to make its collector go low.<br> As a comparator,
                            the IC741 is set up –which consists of 8 pins. Wherein the pin3 is allocated as the reference input, while the Pin2 as the sensing input. When the collector terminal of the transistor goes low, then the potential pin2 of the
                            IC becomes lower than the potential pin3.<br>Immediately it makes the output of the IC high, triggering the relay driver consisting of another transistor and relay. The relay triggers and switches on the alarm device, which
                            is connected to the circuit.<br> The capacitor 100uF/25V makes sure that the relay remains on even after the passive infrared sensor is turned off possibly due the exit of the radiation source.<br>The PIR sensor device must
                            be properly enclosed in a Fresnel lens cover to ensure that its efficiency is sufficiently enhanced.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PIR Sensor Based Projects with Abstracts:</h4>
                </button>
                    <div class="content">
                        <h5>By understanding the use and limitations of sensors, gives a clear idea of developing the projects. Advanced level projects such as SCADA, fuzzy logic control, data acquisition usually adopts embedded systems and these projects
                            requires software domain knowledge, especially the C language. Here, the details about a few passive infrared sensor based projects with description is given below.<br><br> PIR Sensor based Automatic Door Opening System:-<br>                            The main aim of this project is to opening and closing of doors, in places wherein a person’s presence is mandatory – for instance, hotels, shopping malls, theaters,etc. this project consists of a PIR sensor that senses the
                            presence of the human body and sends pulses to the 8051 microcontroller. This microcontroller controls the motor driver by sending suitable pulses to its input and enable pins.<br><br> Security Alarm System based on PIR sensor:-<br>                            The main intention of this project is to provide security. This project is based on PIR sensor with an integrated circuit which generates a siren. This sensor senses the infrared radiation which is emitted from the humans and
                            then gives a digital output. This digital output is applied to the UM3561 IC. Thus, it generates the sound when any human body is detected. The UM3561 IC is a ROM IC, that generates multi siren tones such as fire engine sirens,
                            ambulance sirens, machine gun sound and police sirens.<br><br> Human Detection Robot Using PIR Sensor:-<br> The human detection robot using PIR sensor mainly detects human, and it is based on an 8-bit microcontroller. A passive
                            infrared sensors used to detect the human beings and this project is mainly used to rescue people stuck in debris during earthquake. It basically brings humans stuck under debris to the surface, thereby saving them effectively.<br><br>                            PIR Sensor based Stepper Motor Control:-<br> The main goal of this project is to control a stepper motor using PIR sensor. This project is mainly based on the robotic technology. This technology is mainly used for advanced
                            applications. In this project, internally PIR sensor is used for excellent performance- IR sensor is used in burglar alarm systems, light switches, visitor present monitoring and robots. In robotics, stepper motors are used
                            widely and they offer continuous rotation as well as amazing precision.<br> Thus, an overview of PIR sensor basics and its applications has been discussed. These sensors are used in many applications such as in real-time monitoring
                            including physical health, electronic security systems, etc. Apart from this, for any help regarding this topic or sensor based project ideas, you can contact us by commenting in the comment section below.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn73"><img class="image" src="LDR.png"></button><br>LDR
            <div id="myModal73" class="modal">
                <div class="modal-content">
                    <span class="close73">&times;</span>
                    <img src="ldr-pin.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The LDR Sensor Module is used to detect the presence of light / measuring the intensity of light. The output of the module goes high in the presence of light and it becomes low in the absence of light. The sensitivity of the signal
                            detection can be adjusted using potentiometer.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Operating Voltage: 3.3V to 5V DC<br> Operating Current: 15ma<br> Output Digital - 0V to 5V, Adjustable trigger level from preset<br> Output Analog - 0V to 5V based on light falling on the LDR<br> LEDs indicating output and power<br>                            PCB Size: 3.2cm x 1.4cm<br> LM393 based design
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Description:</h4>
                </button>
                    <div class="content">
                        <h5>VCC = 3.3V to 5V DC<br> GND = Ground<br> DO = Digital Output<br> AO = Analog Output
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>Photosensitive resistor module most sensitive to environmental light intensity is generally used to detect the ambient brightness and light intensity.</li><br>
                                <li>Module light conditions or light intensity reach the set threshold, DO port output high, when the external ambient light intensity exceeds a set threshold, the module D0 output low;</li><br>
                                <li>Digital output D0 directly connected to the MCU, and detect high or low TTL, thereby detecting ambient light intensity changes;</li><br>
                                <li>Digital output module DO can directly drive the relay module, which can be composed of a photoelectric switch;</li><br>
                                <li>Analog output module AO and AD modules can be connected through the AD converter, you can get a more accurate light intensity value.</li>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn74"><img class="image" src="soil-moisture-sensor.jpg"></button><br>Soil Moisture Sensor
            <div id="myModal74" class="modal">
                <div class="modal-content">
                    <span class="close74">&times;</span>
                    <img src="pinout of soil moisture.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This sensor measures the volumetric content of water inside the soil and gives us the moisture level as output. The sensor is equipped with both analog and digital output, so it can be used in both analog and digital mode.<br>In
                            this article, we are going to interface the sensor in both modes. So let’s begin our tutorial on interfacing Arduino and Soil moisture sensor.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Working of Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>The soil moisture sensor consists of two probes which are used to measure the volumetric content of water. The two probes allow the current to pass through the soil and then it gets the resistance value to measure the moisture
                            value.
                            <br> When there is more water, the soil will conduct more electricity which means that there will be less resistance. Therefore, the moisture level will be higher.<br>Dry soil conducts electricity poorly, so when there will
                            be less water, then the soil will conduct less electricity which means that there will be more resistance. Therefore, the moisture level will be lower.<br> This sensor can be connected in two modes; Analog mode and digital
                            mode. First, we will connect it in Analog mode and then we will use it in Digital mode.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The specifications of the soil moisture sensor FC-28 are as follows:-<br> Input Voltage 3.3 – 5V<br> Output Voltage 0 – 4.2V<br> Input Current 35mA<br> Output Signal Both Analog and Digital
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Description:</h4>
                </button>
                    <div class="content">
                        <h5>The soil Moisture sensor FC-28 has four pins:-<br> VCC: For power<br> A0: Analog output<br> D0: Digital output<br> GND: Ground<br> The Module also contains a potentiometer which will set the threshold value and then this threshold
                            value will be compared by the LM393 comparator. The output LED will light up and down according to this threshold value.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Analog Mode – Interfacing Soil Moisture Sensor and Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>To connect the sensor in the analog mode, we will need to use the analog output of the sensor. When taking the analog output from the soil moisture sensor FC-28, the sensor gives us the value from 0-1023.<br>The moisture is measured
                            in percentage, so we will map these values from 0 -100 and then we will show these values on the serial monitor.<br> You can further set different ranges of the moisture values and turn on or off the water pump according to
                            it.
                            <br> The connections for connecting the soil moisture sensor FC-28 to the Arduino are as follows.<br>
                            <img src="Interface_Soil_Sensor_Arduino.png" class="collapsible_image" alt="image is here"><br> VCC of FC-28 to 5V of Arduino<br> GND of FC-28 to GND of Arduino<br> A0 of FC-28 to A0 of Arduino
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Analog Code :</h4>
                </button>
                    <div class="content">
                        <h5>int sensor_pin = A0;<br> int output_value ;<br> void setup() {<br> Serial.begin(9600);
                            <br> Serial.println("Reading From the Sensor ...");<br> delay(2000);
                            <br> }
                            <br> void loop() {<br> output_value= analogRead(sensor_pin);<br> output_value = map(output_value,550,0,0,100);<br> Serial.print("Mositure : ");<br> Serial.print(output_value);
                            <br> Serial.println("%");
                            <br> delay(1000);
                            <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Digital Mode – Interfacing Arduino and Soil Moisture Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>To connect the soil moisture sensor FC-28 in the digital mode, we will connect the digital output of the sensor to the digital pin of the Arduino.<br>The Sensor module contains a potentiometer with it, which is used to set the
                            threshold value. This threshold value is then compared with the sensor output value using the LM393 comparator which is placed on the sensor module.<br> The LM393 comparator will compare the sensor output value and the threshold
                            value and then gives us the output through the digital pin.<br>When the sensor value will be greater than the threshold value, then the digital pin will give us 5V and the LED on the sensor will light up and when the sensor
                            value will be less than this threshold value, then the digital pin will give us 0V and the light will go down.<br> The connections for connecting the soil moisture sensor FC-28 to the Arduino in digital mode are as follows:<br>
                            <img src="Interface_Arduino_Soil_Moisture_Sensor.png" class="collapsible_image" alt="image is here"><br> VCC of FC-28 to 5V of Arduino<br> GND of FC-28 to GND of Arduino<br> D0 of FC-28 to pin 12 of Arduino<br> LED positive
                            to pin 13 of Arduino<br> LED negative to GND of Arduino
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Digital Code:</h4>
                </button>
                    <div class="content">
                        <h5>int led_pin =13;<br> int sensor_pin =8;<br> void setup() {<br> pinMode(led_pin, OUTPUT);<br> pinMode(sensor_pin, INPUT);<br> }
                            <br> void loop() {<br> if(digitalRead(sensor_pin) == HIGH){<br> digitalWrite(led_pin, HIGH);<br> } else {<br> digitalWrite(led_pin, LOW);<br> delay(1000);
                            <br> }
                            <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications of Soil Moisture Sensor:</h4>
                </button>
                    <div class="content">
                        <h5>A Soil Moisture Sensor has many applications, especially in agriculture. Irrigation is a key factor in farming.<br>Detecting the amount of moisture in the soil and managing irrigation systems (turn on the system when the moisture
                            level falls below a certain predefined value) helps to avoid a lot of wastage of water and human resources.<br>These kinds of sensors make automation of farming easier. This is also used in controlled environments where experiments
                            are conducted.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn75"><img class="image" src="water_detector_sensor.jpg"></button><br>Water Detector Sensor
            <div id="myModal75" class="modal">
                <div class="modal-content">
                    <span class="close75">&times;</span>
                    <img src="water_sensor_circuit_connection.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Water sensor brick is designed for water detection, which can be widely used in sensing rainfall, water level, and even liquid leakage.Connecting a water sensor to an Arduino is a great way to detect a leak, spill, flood, rain,
                            etc. It can be used to detect the presence, the level, the volume and/or the absence of water.<br>While this could be used to remind you to water your plants, there is a better Grove sensor for that. The sensor has an array
                            of exposed traces, which read LOW when water is detected.<br> In this chapter, we will connect the water sensor to Digital Pin 8 on Arduino, and will enlist the very handy LED to help identify when the water sensor comes into
                            contact with a source of water.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Operating Voltage: +5V<br> Working Current :
                            < 20mA<br> Sensor Type : Analog or Digital<br> Water Detection Area :. 1.58in X .63in (40mm X 16mm)<br> Mounting Hole Size : .12in (3mm)<br> Operating Humidity: 10% to 90% (non-condensating)<br> Working Temperature: -22f to 122f (-30c
                                to 50c)
                                <br> Weight :. 3 grams<br> Product Dimensions : 2.56in X .79in (65mm x 20mm)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection With Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>Water sensor has three terminals - S, Vout(+), and GND (-). Connect the sensor as follows −<br> Connect the +Vs to +5v on your Arduino board.<br> Connect S to digital pin number 8 on Arduino board.<br> Connect GND with GND on Arduino.<br>                            Connect LED to digital pin number 9 in Arduino board.<br> When the sensor detects water, pin 8 on Arduino becomes LOW and then the LED on Arduino is turned ON.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>#define Grove_Water_Sensor 8 // Attach Water sensor to Arduino Digital Pin 8<br> #define LED 9 // Attach an LED to Digital Pin 9 (or use onboard LED)<br> void setup() {<br> pinMode(Grove_Water_Sensor, INPUT); // The Water Sensor
                            is an Input<br> pinMode(LED, OUTPUT); // The LED is an Output<br> }
                            <br> void loop() {<br> /* The water sensor will switch LOW when water is detected.<br> Get the Arduino to illuminate the LED and activate the buzzer<br> when water is detected, and switch both off when no water is present */<br>                            if( digitalRead(Grove_Water_Sensor) == LOW) {<br> digitalWrite(LED,HIGH);
                            <br> }else {<br> digitalWrite(LED,LOW
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn76"><img class="image" src="turbidity-sensor.jpg"></button><br>Turbidity Sensor Module
            <div id="myModal76" class="modal">
                <div class="modal-content">
                    <span class="close76">&times;</span>
                    <img src="SEN0189_connection.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The gravity arduino turbidity sensor detects water quality by measuring the levels of turbidity, or the opaqueness.<br>It uses light to detect suspended particles in water by measuring the light transmittance and scattering rate,
                            which changes with the amount of total suspended solids (TSS) in water. As the TTS increases, the liquid turbidity level increases.<br>Turbidity sensors are used to measure water quality in rivers and streams, wastewater and
                            effluent measurements, control instrumentation for settling ponds, sediment transport research and laboratory measurements.<br>This liquid sensor provides analog and digital signal output modes. The threshold is adjustable
                            when in digital signal mode. You can select the mode according to your MCU.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>Operating Voltage: 5V DC<br> Operating Current: 40mA (MAX)<br> Response Time :
                            < 500ms<br>
                                Insulation Resistance: 100M (Min)<br> Output Method:<br>
                                <ul>
                                    <li>Analog output: 0-4.5V</li><br>
                                    <li>Digital Output: High/Low level signal (you can adjust the threshold value by adjusting the potentiometer)</li>
                                </ul><br> Operating Temperature: 5℃~90℃<br> Storage Temperature: -10℃~90℃<br> Weight: 30g<br> Adapter Dimensions: 38mm*28mm*10mm/1.5inches *1.1inches*0.4inches
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Interface Description:</h4>
                </button>
                    <div class="content">
                        <h5>"D/A" Output Signal Switch:-<br>
                            <ul>
                                <li>"A": Analog Signal Output, the output value will decrease when in liquids with a high turbidity</li><br>
                                <li>"D": Digital Signal Output, high and low levels, which can be adjusted by the threshold potentiometer</li>
                            </ul><br> Threshold Potentiometer: you can change the trigger condition by adjusting the threshold potentiometer in digital signal mode.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>Example-1:-<br><br> void setup() {<br> Serial.begin(9600); //Baud rate: 9600<br> }
                            <br> void loop() {<br> int sensorValue = analogRead(A0);// read the input on analog pin 0:<br> float voltage = sensorValue * (5.0 / 1024.0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):<br>                            Serial.println(voltage); // print out the value you read:<br> delay(500);
                            <br> }
                            <br><br> Example-2:-
                            <br><br> int ledPin = 13; // Connect an LED on pin 13, or use the onboard one<br> int sensor_in = 2; // Connect turbidity sensor to Digital Pin 2<br> void setup(){<br> pinMode(ledPin, OUTPUT); // Set ledPin to output mode<br>                            pinMode(sensor_in, INPUT); //Set the turbidity sensor pin to input mode<br> }
                            <br> void loop(){<br> if(digitalRead(sensor_in)==LOW){ //read sensor signal<br> digitalWrite(ledPin, HIGH); // if sensor is LOW, then turn on<br> }
                            <br> else{
                            <br> digitalWrite(ledPin, LOW); // if sensor is HIGH, then turn off the led<br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn77"><img class="image" src="tactile-switch.jpg"></button><br>Tactile Switch
            <div id="myModal77" class="modal">
                <div class="modal-content">
                    <span class="close77">&times;</span>
                    <img src="Push-button-Pinout.gif" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A tactile switch is an on/off electronic switch that is only on when the button is pressed or if there is a definitive change in pressure. ... Tact switches react to user interaction with the button or switch when it makes contact
                            with the control panel beneath. In most cases this is usually a printed circuit board (PCB).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Prevent flux rise by the insert-molded terminal<br> Snap-in mount terminal<br> Contact Bounce: MAX 5mS<br> Crisp clicking by tactile feedback<br> Dielectric Withstanding Voltage 250V AC for 1 minute
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Mode of Operation: Tactile feedback<br> Power Rating: MAX 50mA 24V DC<br> Insulation Resistance: 100Mohm at 100v<br> Operating Force: 2.55±0.69 N<br> Contact Resistance: MAX 100mOhm<br> Operating Temperature Range: -20 to +70 ℃
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use push button?:</h4>
                </button>
                    <div class="content">
                        <h5>Push-Buttons are normally-open tactile switches. Push buttons allow us to power the circuit or make any particular connection only when we press the button.<br>Simply, it makes the circuit connected when pressed and breaks when
                            released. A push button is also used for triggering of the SCR by gate terminal.<br>These are the most common buttons which we see in our daily life electronic equipment’s. Some of the applications of the Push button are mentioned
                            at the end of the article.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use a push button?:</h4>
                </button>
                    <div class="content">
                        <h5>When connecting in between of supply and the circuit we should only connect the wires with both the legs of the Push-Button.<br> A Push-Button can also be used for the triggering purpose like of SCR.<br>An SCR is a gate controlled
                            Switch which needs a triggering pulse. So, for this we can add a Push button in the circuit to give a triggering pulse.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>Calculators<br> Push-button telephones<br> Kitchen appliances<br> Magnetic locks<br> Various other mechanical and electronic devices, home and commercials.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn78"><img class="image" src="15.jpg"></button><br>Breadboard trim potentiometer - 10K
            <div id="myModal78" class="modal">
                <div class="modal-content">
                    <span class="close78">&times;</span>
                    <img src="Preset-Potentiometer-Pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A Trimpot is another type of potentiometer that comes in small package.<br>It has three leads and can be easily mounted on breadboard or perf board for quick prototyping. The value of the pot can changed by varying the knob on
                            top of it.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="1" class="collapsible_image">
                                <tr>
                                    <th>Pin No.</th>
                                    <th>Pin Name</th>
                                    <th>Description</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>Fixed End 1</th>
                                    <th>This end is connected to one end of the resistive track</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>Variable End</th>
                                    <th>This end is connected to the wiper, to provide variable voltage</th>
                                </tr>
                                <tr>
                                    <th>3</th>
                                    <th>ixed End 1</th>
                                    <th>This end is connected to another end of the resistive track</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Type: Preset Potentiometer – Trimpot<br> Available in standard or carbon film type<br> Available in different resistance values like 500Ω, 1K, 2K, 5K, 10K, 20K, 50K, 100K, 200K,1M. <br> Maximum operating Voltage: 50V DC<br> Rotational
                            Life: 20 cycles
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Alternative Variable Resistors:</h4>
                </button>
                    <div class="content">
                        <h5>Thumbwheel Potentiometer, Potentiometer, Trimmer
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Selecting a Potentiometer:</h4>
                </button>
                    <div class="content">
                        <h5>Potentiometers also known as POT, are nothing but variable resistors.<br>They can provide a variable resistance by simply varying the knob on top of its head. It can be classified based on two main parameters. One is their Resistance
                            (R-ohms) itself and the other is its Power (P-Watts) rating.<br> The value or resistance decides how much opposition it provides to the flow of current. The greater the resistor value the smaller the current will flow. Some
                            standard values for a potentiometer are 500Ω, 1K, 2K, 5K, 10K, 22K, 47K, 50K, 100K, 220K, 470K, 500K, 1M. <br> Resistors are also classified based on how much current it can allow; this is called Power (wattage) rating.<br>The
                            higher the power rating the bigger the resistor gets and it can also more current. For potentiometers the power rating is 0.3W and hence can be used only for low current circuits.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Difference between a Preset Pot and Normal Potentiometer:</h4>
                </button>
                    <div class="content">
                        <h5>Preset pots and potentiometer almost work like the same, but they both have totally different applications.<br>The preset pot comes in small package and can be mounted on the PCB or perf board. Due to its small size the power rating
                            is also less than knob type potentiometers.<br> These potentiometers are not meant to be controlled by users. They are used by engineers to fine tune or calibrate the design after the fabrication is complete.<br>Once calibrated
                            to right value, these pots will no longer be used to vary the resistance and acts like normal resistors. This is why they have low rotation life of only turns.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Identifying values of Preset Potentiometer:</h4>
                </button>
                    <div class="content">
                        <h5>The value of a preset potentiometer will be written on top of it in three digits, something similar to ceramic capacitors. The first two digits is the actual value and the 3rd digit has to be taken to the power of ten.<br>For example
                            in digits 202, the first two digits 20 is taken as such and the 3rd digit is taken to the power of 10. So it becomes 20×102 which becomes 2000 which is nothing but 2K potentiometer.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>Voltage and Current Control Circuits<br> Used as volume control knobs in radios<br> Tuning or controlling circuits<br> Analog input control knobs
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn79"><img class="image" src="resistor.jpg"></button><br>Resistor
            <div id="myModal79" class="modal">
                <div class="modal-content">
                    <span class="close79">&times;</span>
                    <img src="resistors-dd.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions</h4>
                </button>
                    <div class="content">
                        <h5>A resistor is a passive two-terminal electrical component that implements electrical resistance as a circuit element.<br>In electronic circuits, resistors are used to reduce current flow, adjust signal levels, to divide voltages,
                            bias active elements, and terminate transmission lines, among other uses.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Theory of operation:</h4>
                </button>
                    <div class="content">
                        <h5>Ohm's law<br> Main article: Ohm's law<br> The behaviour of an ideal resistor is dictated by the relationship specified by Ohm's law:<br> {\displaystyle V=I\cdot R.}V=I \cdot R.<br> Ohm's law states that the voltage (V) across a
                            resistor is proportional to the current (I), where the constant of proportionality is the resistance (R). For example, if a 300 ohm resistor is attached across the terminals of a 12 volt battery, then a current of 12 / 300
                            = 0.04 amperes flows through that resistor.<br> Practical resistors also have some inductance and capacitance which affect the relation between voltage and current in alternating current circuits.<br> The ohm (symbol: Ω) is
                            the SI unit of electrical resistance, named after Georg Simon Ohm. An ohm is equivalent to a volt per ampere. Since resistors are specified and manufactured over a very large range of values, the derived units of milliohm (1
                            mΩ = 10−3 Ω), kilohm (1 kΩ = 103 Ω), and megohm (1 MΩ = 106 Ω) are also in common usage.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Types of Resistor:</h4>
                </button>
                    <div class="content">
                        <h5>Carbon Composition Resistor: – Made of carbon dust or graphite paste, low wattage values<br> Film or Cermet Resistor: – Made from conductive metal oxide paste, very low wattage values<br> Wire-wound Resistor: – Metallic bodies
                            for heatsink mounting, very high wattage ratings<br> Semiconductor Resistor: – High frequency/precision surface mount thin film technology<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications Of Variable Resistors:</h4>
                </button>
                    <div class="content">
                        <h5>Simply put, a variable resistor is able to have its electrical resistance adjusted. These devices are used when working with electrical circuitry because they help to control voltage and/or currents.<br>They specifically work with
                            voltage and currents that are a part of the circuit.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Resistor Colour Code:</h4>
                </button>
                    <div class="content">
                        <h5>There are many different types of Resistor available which can be used in both electrical and electronic circuits to control the flow of current or to produce a voltage drop in many different ways. But in order to do this the actual
                            resistor needs to have some form of “resistive” or “resistance” value. Resistors are available in a range of different resistance values from fractions of an Ohm ( Ω ) to millions of Ohms.<br> Obviously, it would be impractical
                            to have available resistors of every possible value for example, 1Ω, 2Ω, 3Ω, 4Ω etc, because literally tens of hundreds of thousands, if not tens of millions of different resistors would need to exist to cover all the possible
                            values. Instead, resistors are manufactured in what are called “preferred values” with their resistance value printed onto their body in coloured ink.<br> The resistance value, tolerance, and wattage rating are generally printed
                            onto the body of the resistor as numbers or letters when the resistors body is big enough to read the print, such as large power resistors. But when the resistor is small such as a 1/4 watt carbon or film type, these specifications
                            must be shown in some other manner as the print would be too small to read.<br>
                            <img src="color-code.png" class="collapsible_image" alt="image is here"><br> So to overcome this, small resistors use coloured painted bands to indicate both their resistive value and their tolerance with the physical size
                            of the resistor indicating its wattage rating. These coloured painted bands produce a system of identification generally known as a Resistors Colour Code.<br> An international and universally accepted resistor colour code scheme
                            was developed many years ago as a simple and quick way of identifying a resistors ohmic value no matter what its size or condition. It consists of a set of individual coloured rings or bands in spectral order representing each
                            digit of the resistors value.<br> The resistor colour code markings are always read one band at a time starting from the left to the right, with the larger width tolerance band oriented to the right side indicating its tolerance.
                            By matching the colour of the first band with its associated number in the digit column of the colour chart below the first digit is identified and this represents the first digit of the resistance value.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn80"><img class="image" src="NTC-Thermistor.jpg"></button><br>NTC Thermistor Temperature Sensor
            <div id="myModal80" class="modal">
                <div class="modal-content">
                    <span class="close80">&times;</span>
                    <img src="thermistor.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>NTC Thermistor temperature sensor module is low cost, small size module. It is very sensitive to ambient temperature. It is generally used to detect the temperature of the surrounding environment. Through potentiometer adjustment,
                            it is possible to change the temperature detection threshold.<br> DO output can be directly connected to the microcontroller to detect high and low, by detecting temperature changes in the environment. The temperature detection
                            range of the module is between 20 and 80 degrees Celsius. This module can be replaced with a line temperature sensor for controlling the water temperature, water tank, etc.<br> Generally, the 4 wire method of thermistor measurement
                            is the most accurate because there is effectively no current flowing in either of the measurement cable wires and therefore no added resistance due to the cable wires.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>NTC thermistors are used in a wide variety of applications. The medical industry relies on NTC's in various applications including catheters, dialysis equipment, and patient monitoring. Appliances from dryers to coffee makers use
                            NTC thermistors to accurately measure temperature.<br>HVAC and refrigeration equipment use NTC sensors to measure temperature in building controls and processes, resulting in increased efficiency and control.<br>Automotive
                            and aerospace industries use NTC thermistors for test and measurement as well as production applications.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Adopt the NTC thermistor sensor, sensitivity is good.<br> The comparator output, signal clean, good waveform, driving ability is strong, for more than 15 ma.<br> With potentiometer to adjust the temperature detection threshold.<br>                            Working voltage: 3.3 V to 5 V.<br> Output form: digital switch output (0 and 1).<br> It has a fixed bolt hole, convenient installation.<br> Using the LM393 wide voltage comparator.

                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Module instructions:</h4>
                </button>
                    <div class="content">
                        <h5>A thermistor module is sensitive to the environment temperature, are commonly used to detect the temperature of the surrounding environment.<br> Through to the potentiometer adjustment, can change the temperature detection threshold
                            (i.e., temperature control), such as the need to control the environment temperature is 50 degrees, while the module corresponding environmental temperature to the green light, the DO output high level, below the set temperature,
                            the output high level, green light don’t.<br> The DO output can be attached directly to the single-chip microcomputer, through a single-chip microcomputer to detect the high and low level, thus to detect the temperature of
                            the environment change.<br> The DO output can be directly driven by our relay module, which can form a temperature control switch and control related equipment operating temperature, also can connect the fan used for cooling,
                            etc.
                            <br> The module of the temperature detection range of 20-80 degrees Celsius.<br> This module can also be replaced with a line of a temperature sensor, used for water temperature, control of the water tank, etc.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn81"><img class="image" src="raspberry-pi-channel-level.jpg"></button><br>Raspberry Pi 8 channel Level Switching (3.5V to 5V) IO Module
            <div id="myModal81" class="modal">
                <div class="modal-content">
                    <span class="close81">&times;</span>
                    <img src="images.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Raspberry Pi 8 channel Level Switching (3.5V to 5V) IO Module Logic Level Converter is able to convert signals from 5V down to 3.3V (and vice versa) meaning you can safely use 5V or 3.3V devices with the Raspberry Pi (compatible).<br>                            Because raspberries GPIO is 3.3 V, so regular 5 V sensor is not easy.<br> Therefore the product realization 8 – channel high – voltage logic and logic low voltage bi-directional transformations embodiment Ax and Bxbi-directional
                            conversion between the two.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use?:</h4>
                </button>
                    <div class="content">
                        <h5>In the case of translating between 3.3V and 5V system:<br> 1. VCCA/VA connects to the 3.3V power supply<br> 2. VCCB/VB connects to the 5V power supply<br> 3. GND connects to power negative pole respectively, the two power supply
                            should be common-grounded with each other<br> 4. When Ax has TTL 3.3V input, Bx will get TTL 5V output<br> 5. When Bx has TTL 5V input, Ax will get TTL 3.3V output<br> 6. NO direction control required
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>VCCA Raspberry 3.3 V<br> 8 channels bidirectional voltage translation between different logic level, translate between Ax and Bx automatically<br> 4 pairs of power supply interfaces, supports more situation<br> Use tantalum capacitors
                            for power filter, provides more stability<br> VCCB 5V power supply (can be an external 5V power supply)<br> GND connect the negative pole
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn82"><img class="image" src="toggle-switch.jpg"></button><br>Mini Panel Mount SPDT Toggle Switch
            <div id="myModal82" class="modal">
                <div class="modal-content">
                    <span class="close82">&times;</span>
                    <img src="images.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This or that, one or the other, perhaps or perhaps not! So hard to make decisions these days without feeling like you're just going back and forth constantly.<br>Deciding whether or not to use this mini toggle switch? That's the
                            easiest decision you'll make all day!<br> This Mini Panel Mount SPDT Toggle Switch is great for any project where you have two options to select between. Maybe you'll be selecting between two voltages? Two audio outputs? Two
                            sensor inputs?<br>It's up to you! It's short, sweet, blue, and to the point! The part is marked at 6A 125VAC but we haven't tested it at such high current/voltages and don't recommend it for more than 1A at 24V.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>SPDT 3 Terminal ON-ON 2 - Position Latching Toggle Switch.<br> Each switch is assembled with two hex nuts, a flat and a locking washer.<br> Easy installation, fits into any 6mm hole.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn83"><img class="image" src="spst-switch.jpg"></button><br>SPST ON/OFF Switch
            <div id="myModal83" class="modal">
                <div class="modal-content">
                    <span class="close83">&times;</span>
                    <img src="Pinout-of-SPST-ON-OFF-Rocker-Swicth.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>SDDJE series comes with the electrical ratings of 10A 250V AC. They have Operating temperature range of –10 °C to +55 °C. This series of rocker switches have the operating life 10,000 cycles.<br>SPST (single-pole, single-throw)
                            Rocker ON-OFF switch comes with two states of operation, either ON state or OFF state. They come with no marking or various marking on it indicating it’s ON and OFF states.<br>There is H mark made at the input side terminal
                            indicating "high" state at the bottom surface. SDDJE11200 comes with horizontal IO Marking on it.<br>At the I terminal input is given through through the SPST rocker switch and output is connected at the O terminal of the switch.
                            There are Illuminated Rocker switch, When the switch is ON the switch gets lighted up.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2px" class="collapsible_image">
                                <tr>
                                    <th>Pin No</th>
                                    <th>Pin Name</th>
                                    <th>Pin Function</th>
                                </tr>
                                <tr>
                                    <th>1</th>
                                    <th>I (Input)</th>
                                    <th>ON, Connects the input supply to the output when pressed</th>
                                </tr>
                                <tr>
                                    <th>2</th>
                                    <th>O (Output)</th>
                                    <th>OFF, Disconnects the input supply to the output when pressed dwon</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features and Electrical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Power switches<br> Snap-in type<br> SDDJE series comes in SPST (Single Pole Single Throw) and DPST (Double Throw Single Pole) configuration<br> SDDJE11200 is SPST ON-OFF Rocker Switch with IO marking.<br> Operating temperature
                            range –10 °C to +55 °C<br> Contact resistance 100mΩ max.<br> Insulation resistance 500MΩ min. 500V DC<br> Voltage proof 2,000V AC for 1minute<br> Operating life 10,000cycles<br> Actuator strength - Operating direction 25N<br>                            Actuator strength - Perpendicular direction 25N
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to Use Rocker Switch?:</h4>
                </button>
                    <div class="content">
                        <h5>The SPST switch has one input terminal and an output terminal. The input battery source is given at the input or I terminal of the switch. LED is connected to the output or the O side terminal of the switch as seen in the figure.<br>When
                            the Rocker switch is pressed down the input terminal is connected to the output terminal and the LED glows.<br>When the switch is again pressed down at the end of O terminal, the LED turns OFF.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Applications:</h4>
                    </button>
                    <div class="content">
                        <h5>Small appliances<br> As AC and DC power ON-OFF switches<br> Computers and peripherals<br> Medical instrumentation
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn84"><img class="image" src="adafruit-touch-sensor.jpg"></button><br>Adafruit Standalone Momentary Capacitive Touch Sensor
            <div id="myModal84" class="modal">
                <div class="modal-content">
                    <span class="close84">&times;</span>
                    <img src="images (1).jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This breakout board is the simplest way to create a project with a single "momentary" capacitive touch sensor. No microcontroller is required here - just power with 1.8 to 5.5VDC and touch the pad to activate the sensor.
                            <br> When a capacitive load is detected (e.g. a person touches the sensor-pad area) the red LED lights up and the output pin goes high. You can also solder a wire to the middle pad and create your own capacitive pad if the
                            built-in one isn't suited to your project.
                            <br> If you want to save power, the LED can be disconnected from the output pin (cut the trace between the jumper marked as such). We designed this breakout to have the more-responsive "fast mode" which draws about 0.5mA. If
                            you need ultra-low (~50uA) power usage, the mode jumper can be cut on one side & soldered closed on the other to fix it into that mode. Check the datasheet for specific power usage measurements.
                            <br> Comes with a fully assembled board, and a small stick of 0.1" header so you can solder and plug it into a breadboard. For additional contacts, we suggest using copper foil, then solder a wire that connects from the foil
                            pad to the breakout.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>The breakouts come in three styles::</h4>
                </button>
                    <div class="content">
                        <h5>Momentary:-<br> This sensor has a built-in sense-pad and is active for as long as the sensor area is touched.<br> The sense-pad can be extended with wire and almost any conductive material.<br><br> Toggle:-
                            <br> This sensor also has a built-in sense-pad. It becomes active when touched and remains active until it is touched again.<br> As with the momentary sensor, the sense-pad can be extended with wire and almost any conductive
                            material.
                            <br><br> 5-Pad Momentary:-<br> This version combines 5 momentary switches into one breakout. There are 5 pins for attaching wires to up to 5 external sensor pads.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Wiring for Toggle and Momentary:</h4>
                </button>
                    <div class="content">
                        <h5>These two breakouts are very similar and can be powered by anything from 1.8V to 5.5V DC. Simply connect Ground to GND and the positive voltage to VDD. The standalone sensors are fully functional without further connections.<br>                            Toggle Operation:-<br> The Toggle version of the sensor turns on when you touch it once, then turns off when you touch it again. The on-board LED indicates the state of the switch.<br><br> Momentary Operation:-<br> The momentary
                            touch sensor works just like a momentary switch. It is on when you touch it and off when you move away. The on-board LED indicates the state of the switch.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connecting to your Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>The outputs of these touch switches are 'active high'. Use them like a positive logic signal, or a pushbutton that shorts to VCC.<br> Simple Motor Control:-<br> You can use it just like a pushbutton or logic signal with a transistor
                            or MOSFET to drive high-current loads like a DC motor.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Wiring for 5-pad Momentary:</h4>
                    </button>
                    <div class="content">
                        <h5>The 5-pin momentary breakout can be powered with anything from 1.8V to 5.5VDC. Just connect ground to GND and the positive voltage to VDD.<br>This sensor does not have built-in touch pads, but you can create your own pads in any
                            size or shape from wire, foil or any other conductive material. Simply connect your touch-pads to each of the 5 sense pins.<br>When you touch the pad, the corresponding LED on the other side will light up. The chip only detects
                            one touch-pad at a time to prevent false readings.<br> 5 touch inputs in one device makes this the perfect component for building your own custom capacitive touch panel!
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn85"><img class="image" src="adafruit-12key-touch-sensor.jpg"></button><br>Adafruit 12-Key Capacitive Touch Sensor
            <div id="myModal85" class="modal">
                <div class="modal-content">
                    <span class="close85">&times;</span>
                    <img src="sensors_pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Add lots of touch sensors to your next microcontroller project with this easy-to-use 12-channel capacitive touch sensor breakout board, starring the MPR121.<br>This chip can handle up to 12 individual touch pads.The MPR121 has
                            support for only I2C, which can be implemented with nearly any microcontroller. You can select one of 4 addresses with the ADDR pin, for a total of 48 capacitive touch pads on one I2C 2-wire bus.<br>Using this chip is a lot
                            easier than doing the capacitive sensing with analog inputs: it handles all the filtering for you and can be configured for more/less sensitivity.<br>This sensor comes as a tiny hard-to-solder chip so we put it onto a breakout
                            board for you. Since it's a 3V-only chip, we added a 3V regulator and I2C level shifting so its safe to use with any 3V or 5V microcontroller/processor like Arduino.<br>We even added an LED onto the IRQ line so it will blink
                            when touches are detected, making debugging by sight a bit easier on you. Comes with a fully assembled board, and a stick of 0.1" header so you can plug it into a breadboard. For contacts, we suggest using copper foil or pyralux,
                            then solder a wire that connects from the foil pad to the breakout.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pinouts:</h4>
                </button>
                    <div class="content">
                        <h5>The little chip in the middle of the PCB is the actual MPR121 sensor that does all the capacitive sensing and filtering. We add all the extra components you need to get started, and 'break out' all the other pins you may want to
                            connect to onto the PCB.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Power Pins:</h4>
                </button>
                    <div class="content">
                        <h5>The sensor on the breakout requires 3V power. Since many customers have 5V microcontrollers like Arduino, we tossed a 3.3V regulator on the board. Its ultra-low dropout so you can power it from 3.3V-5V just fine.<br> Vin - this
                            is the power pin. Since the chip uses 3 VDC, we have included a voltage regulator on board that will take 3-5VDC and safely convert it down. To power the board, give it the same power as the logic level of your microcontroller
                            - e.g. for a 5V micro like Arduino, use 5V<br> 3Vo - this is the 3.3V output from the voltage regulator, you can grab up to 100mA from this if you like<br> GND - common ground for power and logic
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>I2C Pins:</h4>
                </button>
                    <div class="content">
                        <h5>SCL - I2C clock pin, connect to your microcontrollers I2C clock line.<br> SDA - I2C data pin, connect to your microcontrollers I2C data line.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>IRQ and ADDR Pins:</h4>
                </button>
                    <div class="content">
                        <h5>ADDR is the I2C address select pin. By default this is pulled down to ground with a 100K resistor, for an I2C address of 0x5A. You can also connect it to the 3Vo pin for an address of 0x5B, the SDA pin for 0x5C or SCL for address
                            0x5D
                            <br> IRQ is the Interrupt Request signal pin. It is pulled up to 3.3V on the breakout and when the sensor chip detects a change in the touch sense switches, the pin goes to 0V until the data is read over i2c
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Assembly:</h4>
                </button>
                    <div class="content">
                        <h5>Prepare the header strip:-<br> Cut the strip to length if necessary. It will be easier to solder if you insert it into a breadboard - long pins down<br> Add the breakout board:-<br> Place the breakout board over the pins so that
                            the short pins poke through the breakout pads.<br> And Solder!:-<br> Be sure to solder all pins for reliable electrical contact.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Wiring:</h4>
                </button>
                    <div class="content">
                        <h5>You can easily wire this breakout to any microcontroller, we'll be using an Arduino. For another kind of microcontroller, just make sure it has I2C, then port the code - its pretty simple stuff!<br> Connect Vin to the power supply,
                            3-5V is fine. Use the same voltage that the microcontroller logic is based off of. For most Arduinos, that is 5V<br> Connect GND to common power/data ground<br> Connect the SCL pin to the I2C clock SCL pin on your Arduino.
                            On an UNO & '328 based Arduino, this is also known as A5, on a Mega it is also known as digital 21 and on a Leonardo/Micro, digital 3<br> Connect the SDA pin to the I2C data SDA pin on your Arduino. On an UNO & '328 based Arduino,
                            this is also known as A4, on a Mega it is also known as digital 20 and on a Leonardo/Micro, digital 2<br><br> The MPR121 ADDR pin is pulled to ground and has a default I2C address of 0x5A You can adjust the I2C address by connecting
                            ADDR to other pins:-<br> ADDR not connected: 0x5A<br> ADDR tied to 3V: 0x5B<br> ADDR tied to SDA: 0x5C<br> ADDR tied to SCL: 0x5D
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn86"><img class="image" src="capacitive-touch-sensor.jpg"></button><br>Capacitive Touch Sensor
            <div id="myModal86" class="modal">
                <div class="modal-content">
                    <span class="close86">&times;</span>
                    <img src="capacitive touch sensor.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>1 Channel Capacitive Touch Sesnor Module uses the touch-sensing IC TTP223 to sense the touch input thus making it easy to add capacitive touch input to your project. The touching detection IC is designed for replacing traditional
                            direct button key with diverse pad size. The module has single touch pad. Power the module with 2 ~ 5.5V DC and the touch pad is all active to sense the input.<br> Single Channel Capacitive Touch Sensor Module is easy to interface.
                            It can be used along with a microcontroller or an arduino or even without one. When a capacitive load (such as a human hand) is in close proximity to the sense-pad, the sensor detects the change in capacitance and activates
                            the switch. Custom sense-pads can be made from nearly any conductive material and these sensors can detect touch through thin layers of non-conductive materials such as glass, plastic, fabric or even wood.<br> In the normal
                            state, the module output is low, low power consumption; When a finger touches the corresponding position, the module output high, if not touched for 12 seconds, switch to low-power mode.<br> Jog type : the initial state is
                            low , high touch , do not touch is low ( similar touch of a button feature ).<br> Module can be installed in such as surface plastic, glass of non-metallic materials.<br> In addition to the thin paper ( non-metallic ) covering
                            the surface of the module , as long as the correct location of the touch , you can make hidden in the walls, desktops and other parts of buttons.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features::</h4>
                </button>
                    <div class="content">
                        <h5>Low power consumption<br> Power supply for 2 ~ 5.5V DC<br> Can replace the traditional touch of a button<br> Four M2 screws positioning holes for easy installation
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Power supply voltage(VCC): 2.0, 3, 5.5 V.<br> Output high VOH: 0.8VCC V<br> Output low VOL: 0.3VCC V<br> Response time (touch mode) : 60 mS<br> Output Pin Sink Current (@ VCC = 3V, VOL = 0.6V) : 8 mA<br> Output pin pull-up current
                            (@ VCC = 3V, VOH = 2.4V) : 4 mA<br> Response time (low power mode) : 220 mS<br> Size : 24 x 24 x 7.2 mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Touch Sensor Interface:</h4>
                </button>
                    <div class="content">
                        <h5>Control Interface: A total of three pins (GND, VCC, SIG), GND to ground, VCC is the power supply, SIG digital signal output pin.<br> Power Indicator: Green LED, power on the right that is shiny.<br> Touch area: Similar to a fingerprint
                            icon inside the area, you can touch the trigger finger.<br> Positioning holes: 4 M2 screws positioning hole diameter is 2.2mm, the positioning of the module is easy to install, to achieve inter-module combination.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn87"><img class="image" src="micro-sd-card.jpg"></button><br>Micro SD Card Module
            <div id="myModal87" class="modal">
                <div class="modal-content">
                    <span class="close87">&times;</span>
                    <img src="Micro-SD-TF-Card-Module-Pinout-SPI.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This Micro SD Card is used for transfering data to and from a standard sd card. The pin out is directly compatible with Arduino and also can be used with other microcontrollers. It allow us to add mass storage and data logging
                            to our project.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Input Voltage: 3.3V/5V<br> With all SD SPI Pins out :MOSI, SCK, MISO and CS ,for further connection<br> Through programming, you can read and write to the SD card using your arduino<br> Make your SD application more easier and
                            simple
                            <br> Communicate with Arduino using SPI interface<br> Push-pop socket with card slightly over the edge of the PCB so its easy to insert and remove<br> 4 mounting holes with 2.2mm diameter<br> Only use 4 I/O pins on the Arduino
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Micro SD Card Module:</h4>
                </button>
                    <div class="content">
                        <h5>This module uses the standard SPI interface for communication, which involve SPI buses, MISO, MOSI, SCK, and a CS signal pin. through programming, the data can easily be read and wrote into SD Card by using the Arduino or other
                            microcontrollers.
                            <br> CS (chip select)<br> SCK (serial clock)<br> MOSI (master out slave in)<br> VCC (3.3V or 5V)<br> GND (ground)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Micro SD Card Module Pinout:</h4>
                </button>
                    <div class="content">
                        <h5>The micro SD card module is fairly simple to connect. It has six pins:-<br> VCC pin supplies power for the module and should be connected to 5V pin on the Arduino.<br> GND should be connected to the ground of Arduino.<br> MISO
                            (Master In Slave Out) is SPI output from the Micro SD Card Module.<br> MOSI (Master Out Slave In) is SPI input to the Micro SD Card Module.<br> SCK (Serial Clock) pin accepts clock pulses which synchronize data transmission
                            generated by Arduino.<br> SS (Slave Select) pin is used by Arduino(Master) to enable and disable specific devices on SPI bus.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            <SPI.h><br> #include
                                <SD.h><br> File myFile;<br> // change this to match your SD shield or module;<br> const int chipSelect = 10;<br> void setup()<br> {
                                    <br> // Open serial communications and wait for port to open:<br> Serial.begin(9600);
                                    <br> while (!Serial) {<br> ; // wait for serial port to connect. Needed for Leonardo only<br> }
                                    <br> Serial.print("Initializing SD card...");<br> if (!SD.begin()) {<br> Serial.println("initialization failed!");<br> return;
                                    <br> }
                                    <br> Serial.println("initialization done.");<br> // open the file. note that only one file can be open at a time,<br> // so you have to close this one before opening another.<br> myFile = SD.open("test.txt", FILE_WRITE);<br>                                    // if the file opened okay, write to it:<br> if (myFile) {<br> Serial.print("Writing to test.txt...");<br> myFile.println("testing 1, 2, 3.");<br> // close the file:<br> myFile.close();
                                    <br> Serial.println("done.");
                                    <br> } else {<br> // if the file didn't open, print an error:<br> Serial.println("error opening test.txt");<br> }
                                    <br> // re-open the file for reading:<br> myFile = SD.open("test.txt");<br> if (myFile) {<br> Serial.println("test.txt:");
                                    <br> // read from the file until there's nothing else in it:<br> while (myFile.available()) {<br> Serial.write(myFile.read());
                                    <br> }
                                    <br> // close the file:<br> myFile.close();
                                    <br> } else {<br> // if the file didn't open, print an error:<br> Serial.println("error opening test.txt");<br> }
                                    <br> }
                                    <br> void loop()<br> {
                                    <br> // nothing happens after setup<br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn88"><img class="image" src="cmos-camera.jpg"></button><br>OV7670 CMOS Camera Image Sensor Module
            <div id="myModal88" class="modal">
                <div class="modal-content">
                    <span class="close88">&times;</span>
                    <img src="camera sensor pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The camera module is powered from a single +3.3V power supply. An external oscillator provide the clock source for camera module XCLK pin. With proper configuration to the camera internal registers via I2C bus, then the camera
                            supply pixel clock (PCLK) and camera data back to the host with synchronize signal like HREF and VSYNC.<br>The OV7670 camera module is a low cost 0.3 mega pixel CMOS color camera module, it can output 640x480 VGA resolution
                            image at 30fps.<br>The OV7670 camera module build in onboard LDO regulator only single 3.3V power needed and can be used in Arduino, STM32,Chipkit, ARM, DSP , FPGA and etc.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>Optical size 1/6 inch<br> Resolution 640x480 VGA<br> Onboard regulator, only single 3.3V supply needed<br> Mounted with high quality F1.8 / 6mm lens<br> High sensitivity for low-light operation<br> VarioPixel® method for sub-sampling<br>                            Automatic image control functions including: Automatic<br> Exposure Control (AEC), Automatic Gain Control (AGC), Automatic White Balance (AWB), Automatic<br> Band Filter (ABF), and Automatic Black-Level Calibration (ABLC)<br>                            Image quality controls including color saturation, hue, gamma, sharpness (edge enhancement), and anti-blooming<br> ISP includes noise reduction and defect correction<br> Supports LED and flash strobe mode<br> Supports scaling<br>                            Lens shading correction<br> Flicker (50/60 Hz) auto detection<br> Saturation level auto adjust (UV adjust)<br> Edge enhancement level auto adjust<br> De-noise level auto adjust
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Things to Remember about Camera Module OV7670:</h4>
                </button>
                    <div class="content">
                        <h5>OV7670 Camera Module is a FIFO camera Module available from different Manufacturers with different pin Configurations. TheOV7670 provides full frame, windowed 8-bit images in a wide range of formats. The image array is capable
                            of operating at up to 30 frames per second (fps) in VGA. The OV7670 includes:-<br> Image Sensor Array(of about 656 x 488 pixels)<br> Timing Generator<br> Analog Signal Processor<br> A/D Converters<br> Test Pattern Generator<br>                            Digital Signal Processor(DSP)<br> Image Scaler<br> Digital Video Port<br> LED and Strobe Flash Control Output<br><br> The OV7670 image sensor is controlled using Serial Camera Control Bus (SCCB) which is an I2C interface (SIOC,
                            SIOD) with a maximum clock frequency of 400KHz.<br> The Camera comes with handshaking signals such as:-<br> VSYNC: Vertical Sync Output – Low during frame<br> HREF: Horizontal Reference – High during active pixels of row<br>                            PCLK: Pixel Clock Output – Free running clock. Data is valid on rising edge<br><br> In addition to this, it has several more signals such as:-<br> D0-D7: 8-bit YUV/RGB Video Component Digital Output<br> PWDN: Power Down Mode
                            Selection – Normal Mode and Power Down Mode<br> XCLK: System Clock Input<br> Reset: Reset Signal<br> The OV7670 is clocked from a 24MHz oscillator. This gives a Pixel Clock(PCLK) output of 24MHz. The FIFO provides 3Mbps of
                            video frame buffer memory. The test pattern generator features 8-bar color bar pattern, fade-to-gray color bar patter. Now let’s start programming the Arduino UNO for testing Camera OV7670 and grabbing frames using serial port
                            reader.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn89"><img class="image" src="ccd-camera.jpg"></button><br>Barcode Reader/Scanner Module - CCD Camera
            <div id="myModal89" class="modal">
                <div class="modal-content">
                    <span class="close89">&times;</span>
                    <img src="barcode.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This reader module brings the benefits of bar code scanning to a variety of OEM devices, it is light, small and low-power.<br>Now kiosks, medical instruments, diagnostic equipment, lottery terminals, vending machines and countless
                            other appliances can all be equipped with the leading-edge scanning technology and reliability.<br>This scanner module is a compact long-range CCD bar code scanning module with high sensitive liner image sensor and build in
                            Auto-sense function, which can be used in your project to decode nearly any kind of 1D(striped) barcode.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>Light Source: Visible Red light 632nm LED<br> Sensor: Linear CCD Sensor<br> Reading Indicator: Beeper<br> Operating Voltage: DC 3.3V~5V<br> Stand-by Current: 30mA<br> Working Current: 110mA<br> Interface: USB/TTL-RS232/PS2<br>                            Working Frequency: 8MHz<br> Working Temperature: -20℃~50℃<br> Storage Temperature: -40℃~70℃<br> Detecting Angle(Test Conditions : Code 39, 10mil/0.25mm,PCS90%): tilt: ±60°; rotation: ±30°; deflection: ±60°<br> Reading Distance:
                            500mm@20mil/0.5mm, PCS90%<br> Scan Rate: 100 scans/sec ±10%<br> Size: 46mm*32.5mm*11.5mm<br> Weight: 80g
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>String code = ""; //initialize the output string<br> boolean endbit = 0; //a flag to mark 0D received<br> char temp;<br> void setup() {<br> Serial.begin(9600); //initialize the Serial port<br> }
                            <br> void loop() {<br> if (Serial.available() > 0) {<br> temp = char( Serial.read()); //read the input data<br> code += temp;<br> }
                            <br> if (temp == 0x0D){ // Or temp == '\r'<br> Serial.println(code);
                            <br> code = "";<br> endbit = 0;<br> temp = 0;<br> }
                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn90"><img class="image" src="w1209-temperature-control-switch.jpg"></button><br>Temperature Controller W/ Display and NTC Waterproof Temperature Sensor
            <div id="myModal90" class="modal">
                <div class="modal-content">
                    <span class="close90">&times;</span>
                    <img src="temperature controler.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is XH-W1209 12V Digital Temperature Controller Module W/ Display and NTC Waterproof Temperature Sensor.<br> W1209 Mini thermostat Temperature controller is low-cost 12V Temperature controller with 7-segment display and 3 switch
                            keypad for setting temperature and other parameters. The module features an NTC thermistor temperature sensing and has an accuracy of 0.1 C.<br> The XH-W1209 12V Digital Temperature Controller Module W/ Display and NTC Waterproof
                            Temperature Sensor is an incredibly low cost yet highly functional thermostat controller. With this module, you can intelligently control power to most types of electrical device based on the temperature sensed by the included
                            high accuracy NTC temperature sensor.<br> Although this module has an embedded microcontroller no programming knowledge is required. 3 tactile switches allow for configuring various parameters including on & off trigger temperatures.
                            The onboard relay can switch up to a maximum of 240V AC at 5A or 14V DC at 10A. <br> The current temperature is displayed in degrees Centigrade via its 3 digit seven segment display and the current relay state by an onboard
                            LED.
                            <br><br> Displaying the current temperature:-<br> The thermostat will display the current temperature in °C by default. When in any other mode making no input for approximately 5 seconds will cause the thermostat to return
                            to this default display.<br><br> Setting the trigger temperature:-<br> To set the trigger temperature press the button marked ‘SET’. The seven segment display will flash. You can now set a trigger temperature (in °C) using
                            the ‘+’ and ‘-‘ buttons in 0.1° increments. If no buttons are pressed for approximately 2 seconds the trigger temperature will be stored and the display will return back to the current temperature.<br><br> Setting the parameters:-<br>                            To set any parameter first long press the ‘SET’ button for at least 5 seconds. The seven segment display should now display ‘P0’. This represents parameter P0. Pressing the ‘+’ or ‘-‘ buttons will cycle through the various
                            parameters (P0 to P6). Pressing the ‘SET’ button whilst any of these parameters are displayed will allow you to change the value for that parameter using the ‘+’ and ‘-‘ buttons. When finished setting a parameter press the
                            set button to exit that option. If no buttons are pressed for approximately 5 seconds the thermostat will exit the parameter options and will return back to the default temperature display.<br><br> Setting the cooling or heating
                            parameter P0:-<br> The parameter P0 has two settings, C and H. When setting to C (default) the relay will energize when the temperature is reached. Use this setting if connecting to an air-conditioning system. When set to H
                            the relay will de-energize when the temperature is reached. Use this setting if controlling a heating device.<br><br> Setting the hysteresis parameter P1:-<br> This sets how much change in temperature must occur before the
                            relay will change state. For example, if set to the default 2oC and the trigger temperature has been set to 25oC, it will not de-energize until the temperature falls back below 23oC. Setting this hysteresis helps stop the thermostat
                            from continually triggering when the temperature drifts around the trip temperature.<br><br> Setting the upper limit of the thermostat parameter P2:-<br> This parameter limits the maximum trigger temperature that can be set.
                            It can be used as a safety to stop an excessively high trigger temperature from accidentally being set by the user.<br><br> Setting the lower limit of the thermostat parameter P3:-<br> This parameter limits the minimum trigger
                            temperature that can be set. It can be used as a safety to stop an excessively low trigger temperature from accidentally being set by the user.<br><br> Setting temperature offset correction parameter P4:-<br> Should you find
                            there is a difference between the displayed temperature and the actual temperature (for instance, if the temperature probe is on a long run of cable) you can make minor corrections to the temperature reading with this parameter.<br><br>                            Setting the trigger delay parameter P5:-<br> This parameter allows for delaying switching of the relay when the trigger temperature has been reached. The parameter can be set in one-minute increments up to a maximum of 10 minutes.<br><br>                            Setting the high-temperature alarm parameter P6:-<br> Setting a value for this parameter will cause the relay to switch off when the temperature reaches this setting. The seven segment display will also show ‘—‘ to indicate
                            an alarm condition. The relay will not re-energize until the temperature falls below this value. The default setting is OFF.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Settings Chart:</h4>
                </button>
                    <div class="content">
                        <h5>Long press the “SET” button to activate the menu.<br> (SET THE VALUES AS MENTIONED IN BRACKET)<br> Code Description Range Default Value:-<br> P0 Heat C/H (C)<br> P1 Backlash Set 0.1-15 (2)<br> P2 Upper Limit 110 (110)<br> P3 Lower
                            Limit -39 (-39)<br> P4 Correction -7.0 ~ (0)<br> P5 Delay Start Time 0-10 mins (0)<br> P6 High Temperature Alarm 0-110 (OFF)<br> Long pressing “+/-” will reset all values to their default
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>To measure and display temperature<br> To Turn any application ON/OFF based on temperature reading . (Both AC and DC)<br> Example Project :- A.Fire alarm system . B. Auto cut off Electric Water Heater
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Power Consumption:-<br> Static Current:
                            <=35mA<br>
                                Current:
                                <=65mA<br>
                                    Environmental Requirements:-<br> Temperature: -10 ~ 60 C<br> Humidity: 20-85%
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn91"><img class="image" src="capacitors.jpg"></button><br>Capacitors
            <div id="myModal91" class="modal">
                <div class="modal-content">
                    <span class="close91">&times;</span>
                    <img src="capacitor.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A capacitor is a passive electronic component that stores energy in the form of an electrostatic field. In its simplest form, a capacitor consists of two conducting plates separated by an insulating material called the dielectric.
                            <br>The capacitance is directly proportional to the surface areas of the plates, and is inversely proportional to the separation between the plates. Capacitance also depends on the dielectric constant of the substance separating
                            the plates.<br><br> The standard unit of capacitance is the farad, abbreviated. This is a large unit; more common units are the microfarad, abbreviated µF (1 µF =10-6F) and the picofarad, abbreviated pF (1 pF = 10-12 F).<br><br>                            Capacitors can be fabricated onto integrated circuit (IC) chips. They are commonly used in conjunction with transistors in dynamic random access memory (DRAM). The capacitors help maintain the contents of memory.<br>Because
                            of their tiny physical size, these components have low capacitance. They must be recharged thousands of times per second or the DRAM will lose its data.<br><br> Large capacitors are used in the power supplies of electronic
                            equipment o fall types, including computers and their peripherals. In these systems,the capacitors smooth out the rectified utility AC, providing pure, battery-like DC.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Types of Capacitors:</h4>
                </button>
                    <div class="content">
                        <h5>There are numerous types of capacitors with various functions and applications. Capacitors range from small to large, and each has characteristics that make them unique. For example, some capacitors are small and delicate, such
                            as the ones found in radio circuits.<br> The range of capacitors is numerous. Take, for instance, variable type capacitors that give the user the ability to vary their capacitance value for use in "frequency tuning" type circuits.
                            <br>Some capacitors look tube-like due to metal foil plates that roll up into a cylinder. Dielectric material typically sits between the metal foil plates and the cylinder.<br> Then there are capacitors used for commercial
                            purposes which are made from metallic foil interweaved with thin sheets of either Mylar or paraffin-impregnated paper.<br> Small capacitors are typically made from ceramic materials and then sealed with epoxy resin. No matter
                            what type of capacitor is used they all play an integral role in electronic circuits. Let's take a more in-depth look at many of the more common capacitor types currently available.<br><br> Film Capacitor Type:-<br> A Mallory
                            150 100nF 630 VDC polyester film capacitor<br> This is the most common type of capacitor (in terms of availability) that belongs to a relatively large family of capacitors. <br>The primary difference between film capacitors
                            and other forms of capacitors is their dielectric properties.
                            <br>These include polycarbonate, polypropylene, polyester (Mylar), polystyrene, Teflon, and metalized paper. Regarding capacitance range, film type capacitors are available in ranges starting from 5pF to 100uF.<br><br> Film
                            capacitors come in a variety of case styles and shapes that include:<br> 1.Epoxy Case (Rectangular & Round) -<br> the capacitor is enclosed within a molded plastic shell that's then filled with. epoxy.
                            <br> 2.Wrap and Fill (Oval and Round) - <br>plastic tape is used to tightly wrap the capacitor, and the ends are sealed with epoxy.<br> 3.Metal Hermetically Sealed (Rectangular and Round) - the capacitor is enclosed within
                            a metal can or tube and sealed with epoxy.
                            <br><br> Dielectric Capacitors:-<br> A capacitor with dielectric<br> Dielectric capacitors considered to belong to the "variable type" of capacitors in which a continuous variation of capacitance is needed for tuning transistor
                            radios, transmitters, and receivers.<br>Variable dielectric capacitors are unique in that they're multi-plate air-spaced types that have stator vanes (fixed plates) and rotor vanes (movable plates) that move between the fixed
                            plates.
                            <br> The capacitance value is ultimately determined by the position of the moving plates in relation to the fixed plates. Typically, when the two sets of plates mesh together fully the capacitance value will be at its maximum.
                            <br>Capacitors that have high voltages have relatively large air-gaps or spacing’s between the plates.<br><br> Ceramic Capacitors:-<br> A ceramic capacitor<br> Ceramic Capacitors are typically referred to as "Disc Capacitors."
                            They're made by taking a small ceramic or porcelain disc and coating both sides with silver before stacking them together to make a functioning capacitor.<br> Single ceramic discs of around 3 - 6mm are used when low capacitance
                            values are needed. Ceramic capacitors have a high dielectric constant (High-K) and are typically available so that a high capacitance can be achieved from a smaller sized object.
                            <br> Ceramic capacitors tend to display substantial non-linear changes in capacitance against temperature. As a result, ceramic capacitors are often used as by-pass or decoupling capacitors.<br>Concerning values, ceramic capacitors
                            range from a couple of picofarads to several microfarads (μF). Typically, however, ceramic capacitors have low voltage ratings.<br><br> Electrolytic Capacitors:-<br> An electrolytic capacitor<br> Electrolytic capacitors are
                            typically reserved for situations where larger capacitance values are needed. Electrolytic capacitors are different in that instead of using a thin film layer (metallic) to act as one of the electrodes, an electrolyte solution
                            in the form of a semi-liquid jelly or paste is instead used as the second electrode.<br> Most electrolytic types of capacitors are polarized, meaning that the correct polarity must be used for the DC voltage applied to the
                            capacitor.
                            <br>In the event of an incorrect polarization, the oxide layer acting as insulation may break down and may become permanently damaged as a result.<br> Due to their large capacitance and small size, electrolytic capacitors are
                            used in DC power supply circuits. This is done for coupling and decoupling applications and to lessen the ripple voltage.<br>Electrolytic capacitors come with a relatively low voltage rating (one of its main disadvantages).
                            Because electrolytic capacitors polarize, they cannot (and must not) be used with AC supplies.<br><br> There are two forms of electrolytics you should be aware of – Tantalum Electrolytic Capacitors and Aluminum Electrolytic
                            Capacitors.
                            <br> 1) Tantalum Electrolytic Capacitors:-<br> Tantalum Electrolytic Capacitors and Tantalum Beads come in two varieties – dry (solid) and wet (foil) electrolytic types. Dry tantalum capacitors are physically smaller than aluminium
                            capacitors and use manganese dioxide as the second terminal.
                            <br><br> 2) Aluminium Electrolytic Capacitors:-<br> Aluminium Electrolytic Capacitors have two types – foil types and etched foil types. Due to the high breakdown voltage and the aluminium oxide film, Aluminium Electrolytic
                            Capacitors have high capacitance values when compared to their size.
                            <br><br> The capacitor has foil plates that are anodized with a DC current. During this process, the polarity of the plate material is set up, and the positive and negative sides are created.<br> The etched foil types differentiate
                            themselves from the plain foil types in one primary way – the aluminium oxide on the cathode and anode has been etched chemically to increase its permittivity and surface area.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Uses of Capacitors:</h4>
                </button>
                    <div class="content">
                        <h5>Capacitors for Energy Storage:-<br> Capacitors have been used to store electrical energy since the late 18th century. Benjamin Franklin was the first to coin the phrase "battery" for a series of capacitors in an energy store application.<br>Individual
                            capacitors generally do not hold a great deal of energy, providing only enough power for electronic devices to use during temporary power outages or when they need additional power.<br>For example, large capacitors are included
                            in car audio systems to provide extra power to amplifiers when needed.<br><br> Capacitors for Power Conditioning:-<br> One important application of capacitors is the conditioning of power supplies. Capacitors allow AC signals
                            to pass but block DC signals when they are charged. They can effectively split these two signal types, cleaning the supply of power.<br> This effect has been exploited to separate or decouple different parts of electrical circuits
                            to reduce noise which could lead to reduction of efficiency. <br>Capacitors are also used in utility substations to counteract inductive loading introduced by transmission lines.<br><br> Capacitors as Sensors:-<br> Capacitors
                            are used as sensors to measure a variety of things, including air humidity, fuel levels and mechanical strain. <br>The capacitance of a device is dependent on its structure. Changes in the structure can be measured as a loss
                            or gain of capacitance. <br>Two aspects of a capacitor are used in sensing applications: the distance between the parallel plates and the material between them. <br>The former is used to detect mechanical changes such as acceleration
                            and pressure. Even minute changes in the material between the plates can be enough to alter the capacitance of the device, an effect exploited when sensing air humidity.<br><br> Capacitors for Signal Processing:-<br> Capacitors
                            have found increasingly advanced applications in information technology. Dynamic Random Access Memory (DRAM) devices use capacitors to represent binary information as bits.<br>The device reads one value when the capacitor is
                            charged and another when discharged. Charge Coupled Devices (CCDs) use capacitors in an analogue form.<br>Capacitors are also used in conjunction with inductors to tune circuits to particular frequencies, an effect exploited
                            by radio receivers, speakers, and analog equalizers.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Capacitor Characteristics:</h4>
                </button>
                    <div class="content">
                        <h5>1.Nominal Capacitance, ( C ) The nominal value of the Capacitance, C of a capacitor is the most important of all capacitor characteristics
                            <br> 2.Working Voltage, ( WV )<br> 3.Tolerance, ( ±% )<br> 4.Leakage Current.<br> 5.Working Temperature, ( T )<br> 6.Temperature Coefficient, ( TC )<br> 7.Polarization
                            <br> 8.Equivalent Series Resistance, ( ESR )
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn92"><img class="image" src="lcd_arduino.png"></button><br>lcd for arduino
            <div id="myModal92" class="modal">
                <div class="modal-content">
                    <span class="close92">&times;</span>
                    <img src="Arduino_LCD_interface_bb.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The LiquidCrystal library allows you to control LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface.<br> The LCDs have a parallel
                            interface, meaning that the microcontroller has to manipulate several interface pins at once to control the display. The interface consists of the following pins:-<br> A register select (RS) pin that controls where in the LCD's
                            memory you're writing data to. You can select either the data register, which holds what goes on the screen, or an instruction register, which is where the LCD's controller looks for instructions on what to do next.<br> A Read/Write
                            (R/W) pin that selects reading mode or writing mode.<br> An Enable pin that enables writing to the registers.<br> 8 data pins (D0 -D7). The states of these pins (high or low) are the bits that you're writing to a register when
                            you write, or the values you're reading when you read.<br> There's also a display constrast pin (Vo), power supply pins (+5V and Gnd) and LED Backlight (Bklt+ and BKlt-) pins that you can use to power the LCD, control the display
                            contrast, and turn on and off the LED backlight, respectively.<br> The process of controlling the display involves putting the data that form the image of what you want to display into the data registers, then putting instructions
                            in the instruction register.<br>The LiquidCrystal Library simplifies this for you so you don't need to know the low-level instructions.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>LCD 1602 pinout and Interface:</h4>
                </button>
                    <div class="content">
                        <h5>The LCD pins are numbered from 1- 16 , look behind the LCD to see the numbering. The table below explains how to connect the LCD pins to the Arduino.<br>
                            <img src="LCD_01.jpg" class="collapsible_image" alt="image is here"><br> In the case where the LCD is powered with the Arduino by the 5V USB cable, selecting the contrast resistor to be 2K ohm and the back LED resistor to be
                            100 ohm is a good start. Alternatively, a 5K potentiometer can be used to adjust the contrast for vest viewing.<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Wiring with Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>Follow the above table and circuit diagram in Fig 1, and wire up the LCD using the wires provided.<br> Color coding:<br> Wire Color----------Description<br> RED----------VCC of +5V<br> BLACK----------Ground
                            <br> Other colors----------Data and signal lines
                        </h5>
                    </div>
                    <img src="LCD-Display-Tutorial.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>/*<br> * Arduino LCD Tutorial<br> *
                            <br> * Crated by Dejan Nedelkovski,<br> *
                            <br> */
                            <br> #include
                            <LiquidCrystal.h> // includes the LiquidCrystal Library<br> LiquidCrystal lcd(1, 2, 4, 5, 6, 7); // Creates an LC object. Parameters: (rs, enable, d4, d5, d6, d7)<br> void setup() {<br> lcd.begin(16,2); // Initializes the interface to the LCD
                                screen, and specifies the dimensions (width and height) of<br> the display }<br> }
                                <br> void loop() {<br> lcd.print("Arduino"); // Prints "Arduino" on the LCD<br> delay(3000); // 3 seconds delay<br> lcd.setCursor(2,1); // Sets the location at which subsequent text written to the LCD will be displayed<br>                                lcd.print("LCD Tutorial");<br> delay(3000);
                                <br> lcd.clear(); // Clears the display<br> lcd.blink(); //Displays the blinking LCD cursor<br> delay(4000);
                                <br> lcd.setCursor(7,1);
                                <br> delay(3000);
                                <br> lcd.noBlink(); // Turns off the blinking LCD cursor<br> lcd.cursor(); // Displays an underscore (line) at the position to which the next character will be written<br> delay(4000);
                                <br> lcd.noCursor(); // Hides the LCD cursor<br> lcd.clear(); // Clears the LCD screen<br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn93"><img class="image" src="RPi-LCD-B-4-1.jpg"></button><br>Resistive Touch Display/Screen for Raspberry Pi
            <div id="myModal93" class="modal">
                <div class="modal-content">
                    <span class="close93">&times;</span>
                    <img src="raspberry display.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Is this not the cutest, little display for the Raspberry Pi? It features a 3.5" display with 480x320 16-bit color pixels and a resistive touch overlay, but is only slightly larger than our popular original.<br>The plate uses the
                            high speed SPI interface on the Pi and can use the mini display as a console, X window port, displaying images or video etc. Best of all it plugs right in on top!<br>It's designed to fit nicely onto the Pi Model A or B but
                            also works perfectly fine with the Model B+ as long as you don't mind the PCB overhangs the USB ports by 5mm.<br>Uses the hardware SPI pins (SCK, MOSI, MISO, CE0, CE1) as well as GPIO #25 and #24. GPIO #18 can be used to PWM
                            dim the backlight if you like. All other GPIO are unused. There's a 2x13 header on the bottom, you can connect a standard Pi GPIO cable to it to use any of the other pins ask you like,Best of all, it comes fully assembled and
                            ready to plug into your Pi! <br>You can use this as a display for running the X interface, or pygame. You can also have an HDMI display seperately connected.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Install Raspbian on an SD Card:</h4>
                </button>
                    <div class="content">
                        <h5>You'll need to start with Raspbian or Raspbian Lite.<br> The last known for-sure tested-and-working version is March 13, 2018 (https://downloads.raspberrypi.org/raspbian/images/raspbian-2018-03-14/) from https://downloads.raspberrypi.org/raspbian/images/
                            <br> Raspbian does often 'break' stuff when new versions come out so to be safe, if you are having problems try this version!
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Installer script:</h4>
                </button>
                    <div class="content">
                        <h5>This script will do all the work for you, and install both device tree overlay support as well as configure rotation and any HDMI mirroring. PiTFT no longer needs any custom kernels or modules, so you can continue to update/upgrade
                            your Pi and it will work with the most recent releases.<br> Here's the commands to run. Make sure your Pi has network access, it needs to download the software!<br> command:-
                            <br> 1.cd ~<br> 2.wget https://raw.githubusercontent.com/adafruit/Raspberry-Pi-Installer-Scripts/master/adafruit-pitft.sh<br> 3.chmod +x adafruit-pitft.sh<br> 4.sudo ./adafruit-pitft.sh
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PiTFT as Text Console (best for Raspbian 'Lite'):</h4>
                </button>
                    <div class="content">
                        <h5>This is the simplest to set-up type of use. Its great if you have a simple text based or pygame/SDL based interface. If you want the PiTFT to act as a text console you can expect:<br> 1.HDMI will be 'deactivated' - nothing appears
                            on the HDMI output but a black screen<br> 2.The login prompt appears on the Pi<br> 3.The Pi is all text, not a GUI (no PIXEL desktop)<br> 4.Keyboard and mouse are used only by the PiTFT interface<br> 5.Framebuffer-capable software
                            (such as fbi for displaying images, mplayer for videos, or pygame software, etc) appear on the PiTFT<br> 6.OpenGL accelerated software will not appear on the PiTFT (it is unaccelerated framebuffer only)<br> 7.But, non-OpenGL-accelerated
                            graphics software is a bit faster than using HDMI mirroring (not tons faster but you're not running fbcp which will always make it faster)<br> If you want that say Yes to the question Would you like the console to appear on
                            the PiTFT display<br>
                            <img src="adafruit_products_consoleY.png" class="collapsible_image" alt="image is here"><br> Then simply reboot. Once rebooted you will not see anything on HDMI, but the console will appear on the PiTFT. That's it!
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PiTFT as HDMI Mirror (Best for Raspbian Full/PIXEL):</h4>
                </button>
                    <div class="content">
                        <h5>This option is the easiest to understand: whatever appears on the HDMI display will be 'mirrored' to the PiTFT. Note that HDMI is much higher resolution so it's not like it turns the PiTFT into a 1080p display. <br>This is great
                            for when you want to run OpenGL-optimized software, PIXEL desktop software, or really anything. The down-side is its a little slower than drawing directly to the framebuffer. You may not notice it but it's worth us mentioning!<br><br>                            1.HDMI will be 'activated' but at a lower resolution - you can change this later but it looks best at 320x240 (PiTFT 2.2", 2.4", 2.8" and 3.2") or 480x320 (PiTFT 3.5")<br> 2.The login prompt or GUI appears on both HDMI and
                            PiTFT at the same time<br> 3.Keyboard and mouse are shared, since the display is mirrored<br> 4.All graphics appear on both HDMI and PiTFT, thanks to fbcp
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>PiTFT as Raw Framebuffer Device:</h4>
                    </button>
                    <div class="content">
                        <h5>For advanced users who are comfortable using framebuffer devices, it is possible to have the PiTFT and HDMI graphics be both active and display different data.<br> 1.HDMI will be active and act like a normal Pi<br> 2.The login
                            prompt or GUI (PIXEL) appears on the HDMI<br> 3.PiTFT appears black, nothing appears on it<br> 4.Keyboard and mouse are used by the HDMI interface but can, in theory, be captured and used to change graphics on PiTFT through
                            programming
                            <br> 5.Framebuffer-capable software (such as fbi for displaying images, mplayer for videos, or pygame software, etc) can appear on the PiTFT if you set it up to display to /dev/fb1<br> 6.OpenGL accelerated software will never
                            appear on the PiTFT (it is unaccelerated framebuffer only)
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Technical Specifications:</h4>
                    </button>
                    <div class="content">
                        <h5>LCD Type---------TFT<br> Size---------3.5
                            <br> Resolution---------320*480 Pixels<br> Interface---------SPI
                            <br> Display Controller---------XPT2046<br> Touch Type---------Resistive<br> Backlight---------LED
                            <br> Aspect Ratio---------8:5<br> Colours---------65536
                            <br> Supports---------Camera, Mouse and Keyboard
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn94"><img class="image" src="PN532 NFRC RFID.jpg"></button><br>PN532 NFC RFID Module
            <div id="myModal94" class="modal">
                <div class="modal-content">
                    <span class="close94">&times;</span>
                    <img src="PN532-NFC-Module-Pinout.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>We recently hear a lot about NFC. This feature is available in the latest high end smart phones present in the market. NFC stands for Near Field Communication. <br>NFC is a protocol designed for smart phones and similar devices
                            to establish radio communication with each other by touching them together or bringing them into close proximity, usually no more than a few centimeters. This type of communication is needed for simple and fast data exchange
                            between devices.
                            <br> And for engineers and hobbyists it is another important communication method. And for establishing this NFC communication we can use this PN532 MODULE. This module acts a modem to send and receive data.
                            <br> PN532 is NFC RFID (Radio Frequency Identification) module. This module is built around NXP PN532 IC. NXP PN532 IC is very popular in NFC applications.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PN532 NFC Pinout Configuration:</h4>
                </button>
                    <div class="content">
                        <h5>PIN NUMBER--------DESCRIPTION<br> VCC--------Should be power source.<br> GND--------Should be connected to ground.<br> SDA/TXD--------SDA: Serial Data pin[I2C Interface],TXD: Transmit pin[UART Interface]<br> SCL/RXD--------SCL:
                            Serial Clock pin[I2C Interface],RXD: Receive pin [UART Interface]<br> SCK--------Serial Clock pin [SPI Interface]<br> MISO--------Master Input Slave Output pin [SPI Interface]<br> MOSI--------Master Output Slave Input pin [SPI
                            Interface]
                            <br> SS--------Slave Select pin [SPI Interface]<br> IRQ--------Interrupt Signal pin [SPI Interface]<br> RSTO--------Reset pin
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>PN532 NFC Module Features and Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>80C51 microcontroller core with 40 Kbyte ROM and 1 Kbyte RAM</li>
                                <li>Highly integrated analog circuitry to demodulate and decode responses</li>
                                <li>Buffered output drivers to connect an antenna with minimum number of external components</li>
                                <li> RF level detector</li>
                                <li>Integrated data mode detector</li>
                                <li>RFID reader/writer mode support [MIFARE 1k, 4k, Ultra light, and DESFIRE cards, ISO/IEC 14443-4 cards such as CD97BX, CD</li>
                                <li>light, DESFIRE, P5CN072 (SMX), INNOVISION Jewel cards such as IRT5001 card, FELICA cards such as RCS_860 and RCS_854]</li>
                                <li>Built in PCB Antenna, with 5cm to7cm communication distance</li>
                                <li>Supports MIFIRE higher transfer speed communication at 212Kbits/s and 424 Kbits/s</li>
                                <li>Supported host communication: SPI Interface, I2C Interface and High Speed Serial UART</li>
                                <li>Flexible interrupt using IRQ pin</li>
                                <li>Hard reset with low power function</li>
                                <li>Power down mode per embedded firmware</li>
                                <li>Automatic wake up on HSU,I2C and SPI interfaces when device is in power down mode</li>
                                <li>Programmable timer</li>
                                <li>Contactless communication at 13.56MHz</li>
                                <li>On-board level shifter, Standard 5V TTL for I2C and UART, 3.3V TTL SPI</li>
                                <li>Work as RFID reader and writer</li>
                                <li>Work as RFID card or a virtual card</li>
                                <li>Operating voltage: +2.7V to +5.5V</li>
                                <li>On-board level shifter: Standard 5V TTL for I2C and UART, 3.3V TTL SPI</li>
                                <li>Low power modes: Hard-Power-Down mode (1µA typical), Soft-Power-Down mode (22µA typical)</li>
                                <li>Operating temperature: -30ºC to +85ºC</li>
                            </ul>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Similar RFID Reader Modules:</h4>
                </button>
                    <div class="content">
                        <h5>RMD6300, RC522, EM-18
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Where to use PN532 NFC module?:</h4>
                </button>
                    <div class="content">
                        <h5>PN532 module basically used to setup a communication mode to devices for quick data exchange.<br> PN532 module can be used on experimental products to communicate with smart phones and PC.<br> The module is used as a communication
                            shield for ARDUINO and PI platforms.<br> The module can be used an RFID (Radio Frequency Identification) reader and writer.<br> The module itself can be used as RFID card.<br> The module consumes very less power so it can be
                            used in mobile systems which work on battery.<br> The module can be used on any controller (or processer) who has any one of three Interfaces (I2C, UART, and SPI).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use PN532 NFC module?:</h4>
                </button>
                    <div class="content">
                        <h5>For using PN532 module, first we will choose the mode of communication between MODULE and CONTROLLER. As mentioned earlier this module has three interfaces, of which we have to choose one. Remember at any given point of time only
                            one of three interfaces can be used. All three cannot be used together. We will have to choose the mode of interface using two switches solder to the board. The switches are S1 and S2 shown in pin diagram.<br> S1----S2----Interface
                            <br> OFF----OFF----HSU (High Speed UART)<br> ON----OFF----I2C
                            <br> ON----ON----SPI
                            <br> Choose the mode of interface and corresponding state of switches from above table. Next toggle the switches S1 and S2 to those positions.<br> After choosing the type of interface, connect the module to the controller or
                            processor. Say if you opted to use I2C, then connect module to I2C of the controller. If you opted to use SPI, then connect module to SPI of controller.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>Media or Data sharing<br> Robotics
                            <br> Smart Phones and Smart devices<br> Security systems<br> Computer Peripherals<br> Package Identification<br> Theft protection systems
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn95"><img class="image" src="GPS_Receiver.jpg"></button><br>Arduino Gps Module
            <div id="myModal95" class="modal">
                <div class="modal-content">
                    <span class="close95">&times;</span>
                    <img src="GPS_Interfacing_Diagram.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Global Positioning System (GPS) makes use of signals sent by satellites in space and ground stations on Earth to accurately determine its position on Earth.<br> The NEO-6M GPS receiver module uses USART communication to communicate
                            with microcontroller or PC terminal.<br> It receives information like latitude, longitude, altitude, UTC time, etc. from the satellites in the form of NMEA string. This string needs to be parsed to extract the information that
                            we want to use.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            < TinyGPS++.h><br> #include
                                < SoftwareSerial.h><br> /* Create object named bt of the class SoftwareSerial */<br> SoftwareSerial GPS_SoftSerial(4, 3);/* (Rx, Tx) */<br> /* Create an object named gps of the class TinyGPSPlus */<br> TinyGPSPlus gps;<br> volatile float
                                    minutes, seconds;<br> volatile int degree, secs, mins;<br> void setup() {<br> Serial.begin(9600); /* Define baud rate for serial communication */<br> GPS_SoftSerial.begin(9600); /* Define baud rate for software serial
                                    communication */<br> }
                                    <br> void loop() {<br> smartDelay(1000); /* Generate precise delay of 1ms */<br> unsigned long start;<br> double lat_val, lng_val, alt_m_val;<br> uint8_t hr_val, min_val, sec_val;<br> bool loc_valid, alt_valid, time_valid;<br>                                    lat_val = gps.location.lat(); /* Get latitude data */<br> loc_valid = gps.location.isValid(); /* Check if valid location data is available */<br> lng_val = gps.location.lng(); /* Get longtitude data */<br> alt_m_val
                                    = gps.altitude.meters(); /* Get altitude data in meters */<br> alt_valid = gps.altitude.isValid(); /* Check if valid altitude data is available */<br> hr_val = gps.time.hour(); /* Get hour */<br> min_val = gps.time.minute();
                                    /* Get minutes */<br> sec_val = gps.time.second(); /* Get seconds */<br> time_valid = gps.time.isValid(); /* Check if valid time data is available */<br> if (!loc_valid)<br> {
                                    <br> Serial.print("Latitude : ");<br> Serial.println("*****");
                                    <br> Serial.print("Longitude : ");<br> Serial.println("*****");
                                    <br> }
                                    <br> else
                                    <br> {
                                    <br> DegMinSec(lat_val);
                                    <br> Serial.print("Latitude in Decimal Degrees : ");<br> Serial.println(lat_val, 6);<br> Serial.print("Latitude in Degrees Minutes Seconds : ");<br> Serial.print(degree);
                                    <br> Serial.print("\t");
                                    <br> Serial.print(mins);
                                    <br> Serial.print("\t");
                                    <br> Serial.println(secs);
                                    <br> DegMinSec(lng_val); /* Convert the decimal degree value into degrees minutes seconds form */<br> Serial.print("Longitude in Decimal Degrees : ");<br> Serial.println(lng_val, 6);<br> Serial.print("Longitude in Degrees
                                    Minutes Seconds : ");<br> Serial.print(degree);
                                    <br> Serial.print("\t");
                                    <br> Serial.print(mins);
                                    <br> Serial.print("\t");
                                    <br> Serial.println(secs);
                                    <br> }
                                    <br> if (!alt_valid)<br> {
                                    <br> Serial.print("Altitude : ");<br> Serial.println("*****");
                                    <br> }
                                    <br> else
                                    <br> {
                                    <br> Serial.print("Altitude : ");<br> Serial.println(alt_m_val, 6); <br> }
                                    <br> if (!time_valid)<br> {
                                    <br> Serial.print("Time : ");<br> Serial.println("*****");
                                    <br> }
                                    <br> else
                                    <br> {
                                    <br> char time_string[32];<br> sprintf(time_string, "Time : %02d/%02d/%02d \n", hr_val, min_val, sec_val);<br> Serial.print(time_string);
                                    <br> }
                                    <br> }
                                    <br> static void smartDelay(unsigned long ms)<br> {
                                    <br> unsigned long start = millis();<br> do <br> {
                                    <br> while (GPS_SoftSerial.available()) /* Encode data read from GPS while data is available on serial port */<br> gps.encode(GPS_SoftSerial.read());
                                    <br> /* Encode basically is used to parse the string received by the GPS and to store it in a buffer so that information can be extracted from it */<br> } while (millis() - start
                                    < ms);<br>
                                        }<br> void DegMinSec( double tot_val) /* Convert data in decimal degrees into degrees minutes seconds form */<br> { <br> degree = (int)tot_val;<br> minutes = tot_val - degree;<br> seconds = 60 * minutes;<br> minutes
                                        = (int)seconds;<br> mins = (int)minutes;<br> seconds = seconds - minutes;<br> seconds = 60 * seconds;<br> secs = (int)seconds;<br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How GPS works:</h4>
                </button>
                    <div class="content">
                        <h5>GPS satellites circle the Earth twice a day in a precise orbit. Each satellite transmits a unique signal and orbital parameters that allow GPS devices to decode and compute the precise location of the satellite. GPS receivers use
                            this information and trilateration to calculate a user's exact location. Essentially, the GPS receiver measures the distance to each satellite by the amount of time it takes to receive a transmitted signal. With distance measurements
                            from a few more satellites, the receiver can determine a user's position and display it.<br> To calculate your 2-D position (latitude and longitude) and track movement, a GPS receiver must be locked on to the signal of at least
                            3 satellites. With 4 or more satellites in view, the receiver can determine your 3-D position (latitude, longitude and altitude). Generally, a GPS receiver will track 8 or more satellites, but that depends on the time of day
                            and where you are on the earth.<br> Once your position has been determined, the GPS unit can calculate other information, such as:-<br> Speed
                            <br> Bearing
                            <br> Track
                            <br> Trip dist<br> Distance to destination
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>What's the signal?:</h4>
                </button>
                    <div class="content">
                        <h5>GPS satellites transmit at least 2 low-power radio signals. The signals travel by line of sight, meaning they will pass through clouds, glass and plastic but will not go through most solid objects, such as buildings and mountains.
                            However, modern receivers are more sensitive and can usually track through houses.<br> A GPS signal contains 3 different types of information:-<br> 1.Pseudorandom code is an I.D. code that identifies which satellite is transmitting
                            information. You can see which satellites you are getting signals from on your device's satellite page.<br> 2.Ephemeris data is needed to determine a satellite's position and gives important information about the health of
                            a satellite, current date and time.<br> 3.Almanac data tells the GPS receiver where each GPS satellite should be at any time throughout the day and shows the orbital information for that satellite and every other satellite
                            in the system.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pinout:</h4>
                </button>
                    <div class="content">
                        <h5>GND is the Ground Pin and needs to be connected to GND pin on the Arduino.<br> TxD (Transmitter) pin is used for serial communication.<br> RxD (Receiver) pin is used for serial communication.<br> VCC supplies power for the module.
                            You can directly connect it to the 5V pin on the Arduino.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn96"><img class="image" src="gps port raspberry pi.jpg"></button><br>GPS L80-39 GPS Module for Raspberry Pi 3
            <div id="myModal96" class="modal">
                <div class="modal-content">
                    <span class="close96">&times;</span>
                    <img src="gps module.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>-PPS output can be used to coordinate time with satellite<br> -Internal patch antenna works well outdoors<br> -EASY, advanced AGPS technology without external memory<br> -Time service application can be achieved by PPS sync NMEA
                            feature
                            <br> -Built-in LNA for better sensitivity<br> -RTC battery-compatible<br> With L80-39 GPS Chip inside, this US GPS L80-39 GPS Module for Raspberry Pi will help you communicate via satellite with UART or USB. It includes 66
                            search channels and 22 simultaneous tracking channels which helps acquire and track satellites in the shortest time outdoors. It uses chip CP2102 for the USB to UART bridge which works faster and is more stable.<br>It is compatible
                            with all models of Raspberry Pi which includes Raspberry Pi 3/Pi 2/B+/A+/B/A/Zero.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Working Voltage: 4.5-5.5V<br> 100mA current draw to startup<br> Maximum Current: 100mA MAX<br> Working Temperature: -40 ~ +85°c<br> GPS: L80-M39<br> Patch Antenna Size: 15.0 x 15.0 x 4.0mm<br> Position Accuracy:
                            < 2.5M CEP<br>
                                Velocity Accuracy:
                                < 1.0m/s<br>
                                    Warm/cold start without ESEY:
                                    < 35s<br>
                                        Warm/cold start with ESEY:
                                        < 15s<br>
                                            Acquisition sensitivity: -148dBm<br> Tracking sensitivity: -165dBm<br> Update rate:1Hz (Default) up to 5Hz<br> Baud Rate: 4800~115200 bps, 9600bps default<br> Protocols: NMEA 0183<br> Mount Cable: 1x8 Stacking
                                            Header USB micro data cable
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to use it:</h4>
                </button>
                    <div class="content">
                        <h5>-After power on and login to the system. you can open a terminal and typing following command to install packages for GPS module.sudo apt-get update && sudo apt-get -y install gpsd gpsd-clients python-gps <br> -Reboot your Raspberry
                            Pi and login, also typing the command in your terminal, it will help you reconfigure your gpsd service:sudo dpkg-reconfigure gpsd <br> -Start the gpsd service:sudo gpsd /dev/ttyUSB0 -F /var/run/gpsd.sock <br> -you can stop
                            the gpsd service:sudo killall gpsd <br> -You can also use systemctl command to manage this service,but at the first, you should modify the configuration file of gpsd in /etc/default/gpsd,filling the blank with your device name
                            and socket name and path.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How to wire it up:</h4>
                </button>
                    <div class="content">
                        <h5>Because of the Serial port issue of Raspberry Pi 3, Model B, it may cause an unexpected problem, we suggest that you do not connect the GPS module with Raspberry Pi directly with GPIO Pins.<br> 1. You need a USB-to-TTL cable to
                            connect GPS module and Raspberry Pi, and you can wire it up like this chart:<br> GPS module-----Wire color<br> VCC-----Red wire<br> GND-----Black wire<br> TXD-----Green wire<br> RXD-----White wire
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn97"><img class="image" src="Pi-Camera-v2.jpg"></button><br>Raspberry Pi Camera Module V2
            <div id="myModal97" class="modal">
                <div class="modal-content">
                    <span class="close97">&times;</span>
                    <img src="raspberry pi camera module.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The Raspberry Pi Camera Module is an official product from the Raspberry Pi Foundation. The original 5-megapixel model was released in 2013, and an 8-megapixel Camera Module v2 was released in 2016. For both iterations, there are
                            visible light and infrared versions.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="2">
                                <tr>
                                    <th> </th>
                                    <th>Camera Module v1</th>
                                    <th>Camera Module v2</th>
                                </tr>
                                <tr>
                                    <th>Net price</th>
                                    <th>$25</th>
                                    <th>$25</th>
                                </tr>
                                <tr>
                                    <th>Size</th>
                                    <th>Around 25 × 24 × 9 mm</th>
                                </tr>
                                <tr>
                                    <th>Weight</th>
                                    <th>3g</th>
                                    <th>3g</th>
                                </tr>
                                <tr>
                                    <th>Still resolution</th>
                                    <th>5 Megapixels</th>
                                    <th>8 Megapixels</th>
                                </tr>
                                <tr>
                                    <th>Video modes</th>
                                    <th>1080p30, 720p60 and 640 × 480p60/90</th>
                                    <th>1080p30, 720p60 and 640 × 480p60/90</th>
                                </tr>
                                <tr>
                                    <th>Linux integration</th>
                                    <th>V4L2 driver available</th>
                                    <th>V4L2 driver available</th>
                                </tr>
                                <tr>
                                    <th>C programming API</th>
                                    <th>OpenMAX IL and others available</th>
                                    <th>OpenMAX IL and others available</th>
                                </tr>
                                <tr>
                                    <th>Sensor</th>
                                    <th>OmniVision OV5647</th>
                                    <th>Sony IMX219</th>
                                </tr>
                                <tr>
                                    <th>Sensor resolution</th>
                                    <th>2592 × 1944 pixels</th>
                                    <th>3280 × 2464 pixels</th>
                                </tr>
                                <tr>
                                    <th>Sensor image area</th>
                                    <th>3.76 × 2.74 mm</th>
                                    <th>3.68 x 2.76 mm (4.6 mm diagonal)</th>
                                </tr>
                                <tr>
                                    <th>Pixel size</th>
                                    <th>1.4 µm × 1.4 µm</th>
                                    <th>1.12 µm x 1.12 µm</th>
                                </tr>
                                <tr>
                                    <th>Optical size</th>
                                    <th>1/4"</th>
                                    <th>1/4"</th>
                                </tr>
                                <tr>
                                    <th>Full-frame SLR lens equivalent</th>
                                    <th>35 mm</th>
                                </tr>
                                <tr>
                                    <th>S/N ratio</th>
                                    <th>36 dB</th>
                                </tr>
                                <tr>
                                    <th>Dynamic range</th>
                                    <th>67 dB @ 8x gain</th>
                                </tr>
                                <tr>
                                    <th>Sensitivity</th>
                                    <th>680 mV/lux-sec</th>
                                </tr>
                                <tr>
                                    <th>Dark current</th>
                                    <th>16 mV/sec @ 60 C</th>
                                </tr>
                                <tr>
                                    <th>Well capacity</th>
                                    <th>4.3 Ke-</th>
                                </tr>
                                <tr>
                                    <th>Fixed focus</th>
                                    <th>1 m to infinity</th>
                                </tr>
                                <tr>
                                    <th>Focal length</th>
                                    <th>3.60 mm +/- 0.01</th>
                                    <th>3.04 mm</th>
                                </tr>
                                <tr>
                                    <th>Horizontal field of view</th>
                                    <th>53.50 +/- 0.13 degrees</th>
                                    <th>62.2 degrees</th>
                                </tr>
                                <tr>
                                    <th>Vertical field of view</th>
                                    <th>41.41 +/- 0.11 degrees</th>
                                    <th>48.8 degrees</th>
                                </tr>
                                <tr>
                                    <th>Focal ratio (F-Stop)</th>
                                    <th>2.9</th>
                                    <th>2.0</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Hardware Features:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <table border="3">
                                <tr>
                                    <th>Available</th>
                                    <th>Implemented</th>
                                </tr>
                                <tr>
                                    <th>Chief ray angle correction</th>
                                    <th>Yes</th>
                                </tr>
                                <tr>
                                    <th>Global and rolling shutter</th>
                                    <th>Rolling shutter</th>
                                </tr>
                                <tr>
                                    <th>Automatic exposure control (AEC)</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Automatic white balance (AWB)</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Automatic black level calibration (ABLC)</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Automatic 50/60 Hz luminance detection</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Frame rate up to 120 fps</th>
                                    <th>Max 90fps. Limitations on frame size for the higher frame rates (VGA only for above 47fps)</th>
                                </tr>
                                <tr>
                                    <th>AEC/AGC 16-zone size/position/weight control</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Mirror and flip</th>
                                    <th>Yes</th>
                                </tr>
                                <tr>
                                    <th>Cropping</th>
                                    <th>No - done by ISP instead (except 1080p mode)</th>
                                </tr>
                                <tr>
                                    <th>Lens correction</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>Defective pixel cancelling</th>
                                    <th>No - done by ISP instead</th>
                                </tr>
                                <tr>
                                    <th>10-bit RAW RGB data</th>
                                    <th>Yes - format conversions available via GPU</th>
                                </tr>
                                <tr>
                                    <th>Support for LED and flash strobe mode</th>
                                    <th>LED flash</th>
                                </tr>
                                <tr>
                                    <th>Support for internal and external frame synchronisation for frame exposure mode</th>
                                    <th>No</th>
                                </tr>
                                <tr>
                                    <th>Support for 2 × 2 binning for better SNR in low light conditions</th>
                                    <th>Anything output res below 1296 x 976 will use the 2 x 2 binned mode</th>
                                </tr>
                                <tr>
                                    <th>Support for horizontal and vertical sub-sampling</th>
                                    <th>Yes, via binning and skipping</th>
                                </tr>
                                <tr>
                                    <th>On-chip phase lock loop (PLL)</th>
                                    <th>Yes</th>
                                </tr>
                                <tr>
                                    <th>Standard serial SCCB interface</th>
                                    <th>Yes</th>
                                </tr>
                                <tr>
                                    <th>Digital video port (DVP) parallel output interface</th>
                                    <th>No</th>
                                </tr>
                                <tr>
                                    <th>MIPI interface (two lanes)</th>
                                    <th>Yes</th>
                                </tr>
                                <tr>
                                    <th>32 bytes of embedded one-time programmable (OTP) memory</th>
                                    <th>No</th>
                                </tr>
                                <tr>
                                    <th>Embedded 1.5V regulator for core power</th>
                                    <th>Yes</th>
                                </tr>
                            </table>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn98"><img class="image" src="arduino membrane keypad.jpg"></button><br>Arduino Membrane Keypad
            <div id="myModal98" class="modal">
                <div class="modal-content">
                    <span class="close98">&times;</span>
                    <div><img src="4x3-Membrane-Keypad-Pinout.png" height="400px" width="48%" alt="image is here"><img src="4x4-Mambrane-Keypad-Pinout.png" height="400px" width="48%" alt="image is here"></div>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Matrix keypads are the kind of keypads you see on cell phones, calculators, microwaves ovens, door locks, etc. They’re practically everywhere.<br> However, in DIY electronics, they are a great way to let users interact with your
                            project and are often needed to navigate menus, punch in passwords and control robots.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Keypad Material:</h4>
                </button>
                    <div class="content">
                        <h5>Membrane keypads are made of a thin, flexible membrane material. They do come in may sizes 4×3, 4×4, 4×1 etc. Regardless of their size, they all work in the same way.<br> One of the great thing about them is that they come with
                            an adhesive backing so you can attach it to nearly anything. You just have to peel the paper backing off.<br>Let’s take 4×4 keypad as an example. It has total 16 keys. Beneath each key is a special membrane switch.<br> All
                            these membrane switches are connected to each other with conductive trace underneath the pad forming a matrix of 4×4 grid.<br>If you had used 16 individual push buttons, you would have required 17 input pins (one for each key
                            and a ground pin) in order to make them work.<br>However, with matrix arrangement, you only need 8 microcontroller pins (4-columns and 4-rows) to scan through the pad.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>How keypad works & How to scan them?:</h4>
                </button>
                    <div class="content">
                        <h5>The working principle is very simple. Pressing a button shorts one of the row lines to one of the column lines, allowing current to flow between them. For example, when key ‘4’ is pressed, column 1 and row 2 are shorted.<br> A
                            microcontroller can scan these lines for a button-pressed state. To do this, it follows below procedure.<br> 1.Microcontroller sets all the column and row lines to input.<br> 2.Then, it picks a row and sets it HIGH.<br> 3.After
                            that, it checks the column lines one at a time.<br> 4.If the column connection stays LOW, the button on the row has not been pressed.<br> 5.If it goes HIGH, the microcontroller knows which row was set HIGH, and which column
                            was detected HIGH when checked.<br> 6.Finally, it knows which button was pressed that corresponds to detected row & column.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Wiring 4×3 & 4×4 Membrane Keypad with Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>Now that we know everything about the membrane keypad, we can begin hooking it up with Arduino.<br> The connections are pretty straightforward. Start by connecting pin 1 of keypad to digital pin 9 on Arduino. Now keep on connecting
                            the pins leftwards like 2 with 8, 3 with 7 etc.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code for 4×3 Keypad:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            < Keypad.h><br> const byte ROWS = 4; //four rows<br> const byte COLS = 3; //three columns<br> char keys[ROWS][COLS] = {<br> {'1','2','3'},
                                <br> {'4','5','6'},
                                <br> {'7','8','9'},
                                <br> {'*','0','#'}
                                <br> };
                                <br> byte rowPins[ROWS] = {9, 8, 7, 6}; //connect to the row pinouts of the keypad<br> byte colPins[COLS] = {5, 4, 3}; //connect to the column pinouts of the keypad<br> //Create an object of keypad<br> Keypad keypad = Keypad(
                                makeKeymap(keys), rowPins, colPins, ROWS, COLS );<br> void setup(){<br> Serial.begin(9600);
                                <br> }
                                <br> void loop(){<br> char key = keypad.getKey();// Read the key<br> // Print if key pressed<br> if (key){<br> Serial.print("Key Pressed : ");<br> Serial.println(key);
                                <br> }
                                <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Code for 4×4 Keypad:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            < Keypad.h><br> const byte ROWS = 4; //four rows<br> const byte COLS = 4; //four columns<br> char keys[ROWS][COLS] = {<br> {'1','2','3','A'},
                                <br> {'4','5','6','B'},
                                <br> {'7','8','9','C'},
                                <br> {'*','0','#','D'}
                                <br> };
                                <br> byte rowPins[ROWS] = {9, 8, 7, 6}; //connect to the row pinouts of the keypad<br> byte colPins[COLS] = {5, 4, 3, 2}; //connect to the column pinouts of the keypad<br> //Create an object of keypad<br> Keypad keypad
                                = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );<br> void setup(){<br> Serial.begin(9600);
                                <br> }
                                <br> void loop(){<br> char key = keypad.getKey();// Read the key<br> // Print if key pressed<br> if (key){<br> Serial.print("Key Pressed : ");<br> Serial.println(key);
                                <br> }
                                <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn99"><img class="image" src="Photo-Interrupter.jpg"></button><br>Photo Interrupter Speed Sensor Module LM393
            <div id="myModal99" class="modal">
                <div class="modal-content">
                    <span class="close99">&times;</span>
                    <img src="speed module.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is a Photo Interrupter Speed Sensor Module LM393, the major goal is to check the rate of an electric motor. The module can be used in association with a microcontroller for motor speed detection, pulse count, position limit,
                            etc. In principle, any rate meter simply measures the rate at which some event occurs.<br>Usually this is done by counting the events for a given period of time (integration interval) and then simply dividing the number of
                            events by the time to get the rate.<br> Basically, the microcontroller-compatible motor speed sensor module described is a simple device that yields processed pulse trains when the visual path of its optical sensor is physically
                            interrupted by some sort of slotted wheel or similar mechanism (an optical sensor commonly consists of a light emitting diode that provides the illumination, and a phototransistor that senses the presence or absence of that
                            illumination).
                            <br>The transmissive optical sensor used here consists of an infrared light emitting diode and a phototransistor.<br>This both prevents interference from stray external light sources and by having the two components matched
                            for a specific frequency of radiation, they are even more immune to undesired interference.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>the use of imported groove coupler sensor<br> the slot width 5mm.<br> the output state indicator lamp output high, output low lights.<br> block, output low; no shelter, output high.<br> the comparator outputs a signal clean, good
                            waveform driving ability more than 15mA.<br> the working voltage of 3.3V-5V<br> the output format: digital switching output (0 and 1)<br> a fixed bolt holes for easy installation<br> small plates PCB size: 3.2cm x 1.7cm<br>                            using a wide voltage LM393 comparator
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Usage:</h4>
                </button>
                    <div class="content">
                        <h5>1.Module slot unobstructed, the receiver tube is turned on, the module DO output low, when blocked, DO output high.<br> 2.The modules can be connected with the relay DO, limit switches and other components, which can also be connected
                            to active buzzer module composed alarm.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Groove width 10 mm.<br> the working voltage of 3.3 V to 5 V<br> output form: digital switch output (0 and 1)<br> PCB size: 2.3 cmx2cm<br> use the LM393 wide voltage comparator
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn100"><img class="image" src="bread board power supply.jpg"></button><br>Mini USB Breadboard Power Supply Module 3.3V & 5V (Arduino & Raspberry Pi Compatible)
            <div id="myModal100" class="modal">
                <div class="modal-content">
                    <span class="close100">&times;</span>
                    <img src="miniusb.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This Breadboard Power Supply is your solution to powering your 3.3V and 5V breadboard electronics projects for quick and easy prototyping as well as circuit building. Power your projects by plugging in any standard DC Wall Adapter
                            with a voltage between 6.5V and 12V such as our 9V Wall Power Adapter.<br>The Power Supply Module will then convert the 9V into 3.3V or 5V and output it into each side of your breadboard, giving power to your breadboard rails
                            (the blue and red strips at the edge of the breadboard labelled + and -).<br>Move the Black jumpers up or down to select whether you'd like 5V or 3.3V on the left and right rails of your breadboard. The LED indicator will light
                            up when your power is on. Use the onboard button to turn your power supply on/off.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>1.Use a mini USB cable to supply power or a power adapter to power your breadboard projects!<br> 2.Input Ports:-<br> -5V Mini USB<br> -6.5V - 12V DC via 5.5mm x 2.1mm DC jack (such as our 9V Wall Power Adapter)<br> 3.Outputs (to
                            breadboard):- <br> -Selectable GND, 3.3V, 5.5V DC (these outputs will be on the Blue and Red rails at the edges of your breadboard labelled + and -)<br> 4.LED Power Indicator<br> 5.2 sets of Jumpers (used to select 5V, OFF,
                            or 3.3V as the output on the left & right breadboard rails)<br> 6.Small form factor<br> 7.Max Current: 700mA<br> 8.Arduino and Raspberry Pi Compatible (Select 5V for Arduino and 3.3V for Raspberry Pi)
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn101"><img class="image" src="battery connector.jpg"></button><br>Arduino 9V battery connector
            <div id="myModal101" class="modal">
                <div class="modal-content">
                    <span class="close101">&times;</span>
                    <img src="connectora.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The 9V Battery Snap Connector with Power Plug is provides the ability to conveniently use a 9V battery to power many common boards and modules.<br> such as the popular Arduino and compatible microcontrollers. This plug is a very
                            common barrel type with an outside diameter of 5.5mm and an inside diameter of 2.1mm. The center is positive.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>1.Made of hard leather.<br> 2.Excellent material, fine workmanship.<br> 3.It is an environmental 9V battery buckle.<br> 4.Wire Length: 10cm.<br> 5.Color: Black.<br> 6.Avoid the polarity conflict and short circuit.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn102"><img class="image" src="audio amplifier.jpg"></button><br>LM386 Audio Amplifier Module for Arduino
            <div id="myModal102" class="modal">
                <div class="modal-content">
                    <span class="close102">&times;</span>
                    <img src="lm386.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The LM386 Audio Amplifier Module is a mono audio amplifier based on the LM386 chip. On eBay, it goes by various names and descriptions such as "LM386 Audio Amplifier Module 200 Times 5V-12V Input 10K Adjustable Resistance".<br>                            The LM386M chip is available in a SO package (M) manufactured by Texas Instruments, and operates on a voltage range between 4 V and 12 V. It has an absolute maximum rating of 15 V. Package (M) has a dissipation rating of 0.73
                            W.
                            <br> The LM386M version of the chip will provide a typical output of 325 mW, when the supply voltage is 6 V and the speaker load 8 Ω. A 9 V battery power supply will provide an output of around 500 mW.<br> The size of the PCB
                            is 41 mm × 13 mm, manufactured using SMD components, and arrives ready assembled. This will save the user much time and resources.<br> As you can see, the PCB manufacturing is to a high quality standard, and the one I received
                            worked straight away without any problems.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>Signal Gain 200 (multiplier)<br> Operating voltage 5 V to 12 V DC<br> On-board LED for power indicator<br> Volume Control 10 k Ω preset<br> Screw Terminal for speaker output connection<br> Board size Approx. 41 mm × 13 mm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>LM386 Chip:</h4>
                </button>
                    <div class="content">
                        <h5>The LM386 is a wonderful chip by Texas Instruments.<br>A power amplifier that requires minimal components to operate solves many cost issues associated with discrete component circuits. The application circuit is very simple and
                            input / outputs are ground referenced.<br> Based on Class AB architecture, it is very simple to manufacture thus keeping the cost of the chip down.<br>You can buy these chips on eBay at the going rate of ten for a pound, which
                            is excellent for students, and schools operating on minimal budgets.<br> This chip has a quiescent current drain of 4 mA making it suitable for battery powered applications.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>1.Operating Voltage: 5V - 12V<br> 2.Voltage Gain Range: 20 - 200<br> 3.Total Harmonic Distortion: 0.2%<br> 4.Rejection Ratio: 50dB<br> 5.Onboard Potentiometer: 10K (to adjust the volume/gain)<br> 6.Pinout:-
                            <br> -VDD: Power Input 5V - 12VDC<br> -IN: Audio Signal Input (what you want to amplify)<br> -GND: Audio Signal Ground<br> -GND: Power Ground: 0V<br> 7.Screw terminals:-<br> -OUT: Output Signal<br> -GND: Output Ground<br> 8.Operating
                            Temperature Range: -20 to 85 C<br> 9.Chipset: LM386
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn103"><img class="image" src="ampplus-2.jpg"></button><br>HiFiBerry AMP+ - 25W digial audio amplifier for the Raspberry Pi
            <div id="myModal103" class="modal">
                <div class="modal-content">
                    <span class="close103">&times;</span>
                    <img src="hificonnection_diagram.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The HiFiBerry Amp+ is a high-quality, highly efficient Class-D power amplifier for the Raspberry Pi (newer models with 40 pin GPIO connector), that is mounted onto the Raspberry Pi to create a stereo audio system. The speakers
                            just have to be connected directly, which makes it an ideal module for multi-room audio installations.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Usage recommendations:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>small and elegant music playback devices</li>
                                <li>home automation and multi-room audio systems</li>
                                <li>solutions that require high-quality sound but unobtrusive appearance</li>
                            </ul>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>-Up to 25W output power<br> -Capable of driving a pair of 4 Ohm speakers<br> -Fully controllable from the Raspberry Pi<br> -44.1kHz and 48kHz sample rates<br> -Digital-analog conversion included, no need for external DACs or sound
                            cards
                            <br> -Fully digital sound path for optimal audio performance<br> -Connects directly to the Raspberry Pi A+, B+ and 2B, no additional cables needed (Zero compatible after soldering the GPIO header)<br> -Only one 12-18V external
                            power supply needed for both AMP+ and the Raspberry Pi, no need for USB power supply anymore<br> -No soldering required, the AMP+ is directly mounted on the Raspberry Pi A+/B+ in less than a minute
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connection:</h4>
                </button>
                    <div class="content">
                        <h5>HiFiBerry installation is very simple, just need a memory card to insert into the card reader of the computer, then run the configuration program and select the appropriate plate and the operating system. The app will automatically
                            install the operating system with appropriate drivers. After the passage of the card for Raspberry Pi HiFiberry Board will already be properly configured.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn104"><img class="image" src="camera module for jetson nano.jpg"></button><br>Camera Module for NVIDIA Jetson Nano Board | 8MP Sensor
            <div id="myModal104" class="modal">
                <div class="modal-content">
                    <span class="close104">&times;</span>
                    <img src="nvidia camera.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Desdcriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Supports night vision:-<br> This camera is designed for NVIDIA Jetson Nano Board. With infrared light, the night vision distance can reach 6m, so you can use it on a dark night.<br> Super Crisp Image Quality:-<br> Equipped with
                            8 megapixel Sony IMX219 sensor for high-definition pictures to meet your daily needs.<br> Wide Applications:-<br> This camera module is widely used for AI intelligent recognition, face recognition, road identification line
                            recognition, license plate recognition, etc.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Camera Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The camera is capable of 3280 x 2464 pixel static images, and also supports 1080p @ 30fps, 720p @ 60 fps and 640 x 480 p 60/90 video recording.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Photosensitive Chip: Sony IMX219<br> CMOS Size: 1/4 inch<br> Aperture (F): 2.0<br> Focal Length: 2.96mm<br> Field of View: 77 degree<br> Distortion:
                            < 1%<br>
                                Resolution: 3280 x 2464<br> 4 Screw Holes: For fixed position / Supports 3.3V output power supply<br> Size: 25mm × 24mm× 6mm
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn105"><img class="image" src="cooling fan jetson nano.jpg"></button><br>Acrylic Case Box with Cooling Fan for NVIDIA Jetson Nano
            <div id="myModal105" class="modal">
                <div class="modal-content">
                    <span class="close105">&times;</span>
                    <img src="acrylic case.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Specification:</h4>
                </button>
                    <div class="content">
                        <h5>1. Material: Acrylic<br> 2. Color: Transparent<br> 3. There is a protective film on above, please tear off it on the corner.<br> 4. Fan size : 40*40*10mm<br> 5. Interface: 3PIN anti-reverse interface<br> 6. Voltage: 5-12V
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn106"><img class="image" src="7sengment.jpg"></button><br>7-Segment Display - LED
            <div id="myModal106" class="modal">
                <div class="modal-content">
                    <span class="close106">&times;</span>
                    <img src="segment pinout.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The emission of these photons occurs when the diode junction is forward biased by an external voltage allowing current to flow across its junction, and in Electronics we call this process electroluminescence.<br> The actual colour
                            of the visible light emitted by an LED, ranging from blue to red to orange, is decided by the spectral wavelength of the emitted light which itself is dependent upon the mixture of the various impurities added to the semiconductor
                            materials used to produce it.<br> Light emitting diodes have many advantages over traditional bulbs and lamps, with the main ones being their small size, long life, various colours, cheapness and are readily available, as well
                            as being easy to interface with various other electronic components and digital circuits.<br> But the main advantage of light emitting diodes is that because of their small die size, several of them can be connected together
                            within one small and compact package producing what is generally called a 7-segment Display.<br> The 7-segment display, also written as “seven segment display”, consists of seven LEDs (hence its name) arranged in a rectangular
                            fashion as shown. Each of the seven LEDs is called a segment because when illuminated the segment forms part of a numerical digit (both Decimal and Hex) to be displayed.<br>An additional 8th LED is sometimes used within the
                            same package thus allowing the indication of a decimal point, (DP) when two or more 7-segment displays are connected together to display numbers greater than ten.<br> Each one of the seven LEDs in the display is given a positional
                            segment with one of its connection pins being brought straight out of the rectangular plastic package.<br>These individually LED pins are labelled from a through to g representing each individual LED. The other LED pins are
                            connected together and wired to form a common pin.<br> So by forward biasing the appropriate pins of the LED segments in a particular order, some segments will be light and others will be dark allowing the desired character
                            pattern of the number to be generated on the display.<br>This then allows us to display each of the ten decimal digits 0 through to 9 on the same 7-segment display.<br> The displays common pin is generally used to identify
                            which type of 7-segment display it is. As each LED has two connecting pins, one called the “Anode” and the other called the “Cathode”, there are therefore two types of LED 7-segment display called: Common Cathode (CC) and Common
                            Anode (CA).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Types of 7 segments:</h4>
                </button>
                    <div class="content">
                        <h5>Common Anode: All the Negative terminals (Anode) of all the 8 LEDs are connected together. All the positive terminals are left alone.<br> Common Cathode: All the positive terminals (Cathode) of all the 8 LEDs are connected together.
                            All the negative thermals are left alone.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Working on 7 segments:</h4>
                </button>
                    <div class="content">
                        <h5>Seven segment devices are generally made up of LEDs. These LEDs will glow when they are forward biased. The intensity of the LEDs depends on forward current.<br>So, sufficient forward current has to be provided to these LEDs to
                            glow with full intensity. This is provided by the driver and is applied to the seven segments.<br>
                            <br>Number---------g f e d c b a---------Hex code<br> 0---------1000000---------C0
                            <br> 1---------1111001---------F9
                            <br> 2---------0100100---------A4
                            <br> 3---------0110000---------B0
                            <br> 4---------0011001---------99
                            <br> 5---------0010010---------92
                            <br> 6---------0000010---------82
                            <br> 7---------1111000---------F8
                            <br> 8---------0000000---------80
                            <br> 9---------0010000---------90
                            <br><br> Table: Display numbers on a seven segment display in common anode configuration.<br> Things change for common cathode configuration.<br><br> Number--------g f e d c b a--------Hex Code<br> 0--------0111111--------3F
                            <br> 1--------0000110--------06
                            <br> 2--------1011011--------5B
                            <br> 3--------1001111--------4F
                            <br> 4--------1100110--------66
                            <br> 5--------1101101--------6D
                            <br> 6--------1111101--------7D
                            <br> 7--------0000111--------07
                            <br> 8--------1111111--------7F
                            <br> 9--------1001111--------4F
                            <br> Table: Display numbers on a seven segment display in common cathode configuration.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Checking 7-Segment Display:</h4>
                </button>
                    <div class="content">
                        <h5>1.Hold the display in your hand and identify pin 1.<br> 2.Now take the multimeter (assuming a red lead for positive and a black lead for negative) and set it to the proper continuity range.<br> 3.Check your meter with a sound test
                            (touch both the leads together, and a sound will be produced). Sometimes the battery in your multimeter may grow weak and it will not be able to display data properly If this happens switch out the batteries in your multimeter
                            for new ones.<br> 4.Put your multimeter’s black lead on pin 3 or 8. Both are common pin as they are internally connected.<br> 5.Now put your meter’s red lead on any other pin such as 1 or 5.<br> 6.If any of the display’s segments
                            glow then the display is common cathode.<br> 7.If none of the segment glows than interchange the leads of multi-meter.<br> 8.Connect your meter’s red lead to pin 3 or pin 8.<br> 9.Now put the black lead of the multimeter on
                            other remaining pin. If any of the segment glow than the display is common anode, as in common anode the positive pin is common and the rest are connected to a negative supply.<br> 10.Check all segments of both common cathode
                            and anode to ensure the display is working properly.<br> 11.If no segment glows, this 7 segment is faulty.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Available in two modes Common Cathode (CC) and Common Anode (CA)<br> Available in many different sizes like 9.14mm,14.20mm,20.40mm,38.10mm,57.0mm and 100mm (Commonly used/available size is 14.20mm)<br> Available colours: White,
                            Blue, Red, Yellow and Green (Res is commonly used)<br> Low current operation<br> Better, brighter and larger display than conventional LCD displays.<br> Current consumption : 30mA / segment<br> Peak current : 70mA
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>1.Used in applications where font size is required to be bigger<br> 2.Microcontroller Independent, hence used in small circuit projects<br> 3.Used in combination with four segments to display measurement/sensor value with four
                            characters
                            <br> 4.Has bright illumination, hence used where display are required to work in low light or dark conditions
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn107"><img class="image" src="male to male.jpg"></button><br>Male-Male Jumper Wires
            <div id="myModal107" class="modal">
                <div class="modal-content">
                    <span class="close107">&times;</span>
                    <img src="758-04.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>These are Jumper wire male to male, used in connecting female header pin of any developemnt board (like Arduino) to other development board or breadboard.Also you can combined it with our Female jumper wire to create Male to Female
                            jumper wire.<br> Handy for making wire harnesses or jumpering between headers on PCB's.<br>These premium jumper wires are 6" (150mm) long and come in a 'strip' of 40 (4 pieces of each of ten rainbow colors). They have 0.1"
                            male header contacts on either end and fit cleanly next to each other on standard-pitch 0.1" (2.54mm) header.<br>The best part is they come in a 40-pin ribbon cable. You can always pull the ribbon wires off to make individual
                            jumpers, or keep them together to make neatly organized wire harnesses.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn108"><img class="image" src="male-female.jpg"></button><br>Male-Female Jumper Wires
            <div id="myModal108" class="modal">
                <div class="modal-content">
                    <span class="close108">&times;</span>
                    <img src="male to female.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A male connector is commonly referred to as a plug and has a solid pin for a center conductor. A female connector is commonly referred to as a jack and has a center conductor with a hole in it to accept the male pin.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn109"><img class="image" src="female-female.jpg"></button><br>Female-Female Jumper Wires
            <div id="myModal109" class="modal">
                <div class="modal-content">
                    <span class="close109">&times;</span>
                    <img src="female to female.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Handy for making wire harnesses or jumpering between headers on PCB's. These premium jumper wires are a little over 6" (150mm) long and come in a 'strip' of 40 (4 pieces of each of ten colors). They have 0.1" sockets on either
                            end and fit cleanly next to each other on standard-pitch 0.1" (2.54mm) header.<br>We recentlty updated these so they are in a 'ribbon strip' instead of individual wires. You can always pull the ribbon wires off to make individual
                            jumpers, or keep them together to make neatly organized wire harnesses.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn110"><img class="image" src="rf module.jpeg"></button><br>433Mhz RF Decoder Transmitter With Receiver Module Kit For Arduino ARM MCU Wireless
            <div id="myModal110" class="modal">
                <div class="modal-content">
                    <span class="close110">&times;</span>
                    <div><img src="rfdecoder.jpg" height="400px" width="47%" alt="image is here"><img src="rf decoder.jpg" height="400px" width="47%" alt="image is here"></div>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Throughout this tutorial we’ll be using the FS1000A transmitter and corresponding receiver, but the instructions provided also work with other 433MHz transmitter/receiver modules that work in a similar fashion. These RF modules
                            are very popular among the Arduino tinkerers and are used on a wide variety of applications that require wireless control.<br> These modules are very cheap and you can use them with any microcontroller, whether it’s an Arduino,
                            ESP8266, or ESP32.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Specifications RF 433MHz Receiver:-<br> Frequency Range: 433.92 MHz<br> Modulation: ASK<br> Input Voltage: 5V<br> Specifications RF 433MHz Transmitter:-<br> Frequency Range: 433.92MHz<br> Input Voltage: 3-12V<br>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Installing the RadioHead Library:</h4>
                </button>
                    <div class="content">
                        <h5>The RadioHead library provides an easy way to work with the 433 MHz transmitter/receiver with the Arduino. Follow the next steps to install that library in the Arduino IDE:<br> 1.Click here to download the RadioHead library. You
                            should have a .zip folder in your Downloads folder.<br> 2.Unzip the RadioHead library.<br> 3.Move the RadioHead library folder to the Arduino IDE installation libraries folder.<br> 4.Restart your Arduino IDE.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Transmitter Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>Wire the transmitter module to the Arduino by following the next schematic diagram.
                            <img src="433-mhz-arduino-transmitter_bb.png" class="collapsible_image" alt="image is here">
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Transmitter Sketch:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            < RH_ASK.h><br> #include
                                <SPI.h> // Not actually used but needed to compile<br> RH_ASK driver;<br> void setup()<br> {
                                    <br> Serial.begin(9600); // Debugging only<br> if (!driver.init())<br> Serial.println("init failed");<br> }
                                    <br> void loop()<br> {
                                    <br> const char *msg = "Hello World!";<br> driver.send((uint8_t *)msg, strlen(msg));<br> driver.waitPacketSent();
                                    <br> delay(1000);
                                    <br> }
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Receiver Circuit:</h4>
                </button>
                    <div class="content">
                        <h5>Wire the receiver module to another Arduino by following the next schematic diagram.
                            <img src="433-mhz-arduino_bb.png" class="collapsible_image" alt="image is here">
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Receiver Sketch:</h4>
                </button>
                    <div class="content">
                        <h5>#include
                            < RH_ASK.h><br> #include
                                <SPI.h> // Not actualy used but needed to compile<br> RH_ASK driver;<br> void setup()<br> {
                                    <br> Serial.begin(9600); // Debugging only<br> if (!driver.init())<br> Serial.println("init failed");<br> }
                                    <br> void loop()<br> {
                                    <br> uint8_t buf[12];<br> uint8_t buflen = sizeof(buf);<br> if (driver.recv(buf, &buflen)) // Non-blocking<br> {
                                    <br> int i;<br> // Message with a good checksum received, dump it.<br> Serial.print("Message: ");<br> Serial.println((char*)buf);
                                    <br> }
                                    <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn111"><img class="image" src="mp3 shield.jpg"></button><br>MP3 Player Arduino Shield for UNO-MEGA VS1053B
            <div id="myModal111" class="modal">
                <div class="modal-content">
                    <span class="close111">&times;</span>
                    <img src="vs1053b.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>With this MP3 shield you can play various formats of music and have it controlled by your Arduino.<br> The music is on a micro-SD card that you can place in the micro-SD card holder on the shield.<br> In addition to playing music,
                            this shield can also record music with the build-in microphone or an external microphone.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>
                            <ul>
                                <li>Uses SPI interface</li>
                                <li>Has a 3.5mm female (stereo) audio jack for output and microphone input. (two separate 3.5 mm connections)</li>
                                <li>Has a build-in microphone for sound recording</li>
                                <li>Compatible with the Arduino Uno and Mega</li>
                                <li>Has a micro-SD card holder (the chip on the shield supports FAT16 and FAT32)</li>
                                <li>For pinout see image with pin descriptions (pin descriptions with X refer to pins to the VS1053 chip)</li>
                                <li>Only works on 5V DC.</li>
                            </ul>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>-Can play a variety of music formats, support for OGG encoding real-time recording<br> -SPI interface, the control signal lines are led out<br> -A headphone and stereo output<br> -A microphone for recording<br> -A line_in input
                            interface
                            <br> -Power indicator<br> -3.3V and 2.8V of LDO chip AMS-1117 on board, provides up to 800mA current<br> -A single power supply: +5 VDC<br> -12.288 Mhz crystal<br> -TF card slot<br><br> Decodes formats<br> -Ogg Vorbis<br> -MP3
                            = MPEG 1 & 2 audio layer III (CBR+VBR+ABR)<br> -MP1 & MP2 = MPEG 1 & 2 audio layers I & II optional<br> -MPEG4 / 2 AAC-LC(+PNS), HE-AAC v2 (Level 3) (SBR + PS)<br> -WMA4.0/4.1/7/8/9 all profiles (5-384 kbps)<br> -FLAC lossless
                            audio with software plugin (upto 24 bits, 48 kHz)-<br> -WAV (PCM + IMA ADPCM)<br> -General MIDI 1 / SP-MIDI format 0<br> -Encodes formats from mic/line<br> -Ogg Vorbis with software plugin<br> -IMA ADPCM<br> -16-bit PCM
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn112"><img class="image" src="l293d-motor-driver.jpg"></button><br>L293d Motor Driver Module
            <div id="myModal112" class="modal">
                <div class="modal-content">
                    <span class="close112">&times;</span>
                    <img src="l293d.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The Motor Driver is a module for motors that allows you to control the working speed and direction of two motors simultaneously .This Motor Driver is designed and developed based on L293D IC.<br> L293D is a 16 Pin Motor Driver
                            IC. This is designed to provide bidirectional drive currents at voltages from 5 V to 36 V.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections with Arduino:</h4>
                </button>
                    <div class="content">
                        <h5>1. Module 5V (VCC) – Arduino 5V.<br> 2. Module GND – Arduino GND.<br> 3. Module 1 – Arduino D8.<br> 4. Module 2 – Arduino D9.<br> 5. Module 3 – Arduino D10.<br> 6. Module 4 – Arduino D11.<br> 7. Module Motor terminals – DC motors.<br>                            8. Module VSS power terminal- External power source of 9V.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>L293D IC Pin Out:</h4>
                </button>
                    <div class="content">
                        <h5>The L293D is a 16 pin IC, with eight pins, on each side, to controlling of two DC motor simultaneously. There are 4 INPUT pins, 4 OUTPUT pins and 2 ENABLE pin for each motor.
                            <img src="4-12-1024x553.png" class="collapsible_image" alt="image is here"><br> Pin 1: When Enable1/2 is HIGH, Left part of IC will work, i.e motor connected with pin 3 and pin 6 will rotate.<br> Pin 2: Input 1, when this pin
                            is HIGH the current will flow though output 1.<br> Pin 3: Output 1, this pin is connected with one terminal of motor.<br> Pin 4/5: GND pins<br> Pin 6: Output 2, this pin is connected with one terminal of motor.<br> Pin 7: Input
                            2, when this pin is HIGH the current will flow though output 2.<br> Pin 8: VSS, this pin is used to give power supply to connected motors from 5V to 36V maximum depends on Motor connected.<br> Pin 9: When Enable 3/4 is HIGH,
                            Right part of IC will work, i.e motor connected with pin 11 and pin 14 will rotate.<br> Pin 10: Input 4, when this pin is HIGH the current will flow though output 4.<br> Pin 11: Output 4, this pin is connected with one terminal
                            of motor.<br> Pin 12/13: GND pins<br> Pin 14: Output 3, this pin is connected with one terminal of motor.<br> Pin 15: Input 3, when this pin is HIGH the current will flow though output 3.<br> Pin 16: VCC, for supply power to
                            IC i.e 5V.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>//Motor A<br> const int inputPin1 = 10; // Pin 15 of L293D IC<br> const int inputPin2 = 11; // Pin 10 of L293D IC<br> //Motor B<br> const int inputPin3 = 9; // Pin 7 of L293D IC<br> const int inputPin4 = 8; // Pin 2 of L293D IC<br>                            void setup() <br> {
                            <br> pinMode(inputPin1, OUTPUT);<br> pinMode(inputPin2, OUTPUT);<br> pinMode(inputPin3, OUTPUT);<br> pinMode(inputPin4, OUTPUT);<br> }
                            <br> void loop() <br> {
                            <br> digitalWrite(inputPin1, HIGH);<br> digitalWrite(inputPin2, LOW);<br> digitalWrite(inputPin3, HIGH);<br> digitalWrite(inputPin4, LOW);<br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn113"><img class="image" src="l298 motor driver.jpg"></button><br>L298 Motor Driver Module
            <div id="myModal113" class="modal">
                <div class="modal-content">
                    <span class="close113">&times;</span>
                    <img src="l298.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The L298N module has a very famous L298 Motor driver IC which is the main part of this module. This module uses the PWM method to control the speed of DC motors.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The module will allow you to control the speed and direction of two DC motors.<br> It can control motors which operates between 5 to 35V and up to 2A.<br> The module has an onboard regulator which helps in giving the output of
                            5V.
                            <br> The module can be powered from 5 to 35V from Arduino or external power supply. It is recommended to always use the external voltage supply.<br> It can also control a stepper motor.<br> It is inexpensive and perfect for
                            robotic projects.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Pin out of  L298N Motor Driver:</h4>
                </button>
                    <div class="content">
                        <h5>Motor A: This terminal block will give the output for the first motor.<br> 12V Jumper: Keep this jumper in place if your supply voltage is less than 12V and the 5V power pin will give you the output of 5V. If the supply voltage
                            is greater than 12V, then remove this jumper and give the 5V supply to the 5V power pin so that the L298 Dual H Bridge IC can work properly.<br> Power Pins: Give the supply voltage from 5 to 35V at the 12V pin and ground. If
                            your supply voltage is greater than 12, then make sure to remove the 12V jumper. 5V pin will act as Output if the Vs will be less than 12V and 5V pin will act as Input if the Vs will be greater than 12V.<br> Enable Pins: Remove
                            the jumpers on the Enable A and Enable B if you want to control the speed of DC motors and connect these to PWM pins of Arduino. If you want to control the stepper motor with L298N, then keep the jumper on Enable A and Enable
                            B. Keeping the jumper on these pins means that the these pins will be High.<br> Logic Pins: Connect the Logic pins to any digital pins of Arduino. These will help in controlling the rotation and speed of DC motors.<br> Motor
                            B: This terminal block will give the output for the second motor.<br> 5V linear Regulator: This will step down the supply voltage to 5V and will give the output at the 5V pin.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Controlling the DC Motors using the L298N Motor Driver:</h4>
                </button>
                    <div class="content">
                        <h5>The circuit diagram for connecting the L298N motor driver module with the Arduino is shown below. Make the connections as follows:-<br> L298N---------------Arduino---------------5 to 12V battery/Power Supply<br> ENA---------------Pin
                            11
                            <br> IN1---------------Pin 9<br> IN2---------------Pin 8<br> IN3---------------Pin 7<br> IN4---------------Pin 6<br> ENB---------------Pin 10<br> 12V ---------------------------------------5 to 12V power supply or battery<br>                            GND----------------------------------------GND Negative of power supply or battery<br> In last, connect the two dc motors at the two sides of L298N<br> For powering the L298N, I have used the 2 rechargeable batteries of 3.7V.<br><br>                            Then connect the Joystick module with the Arduino as follows:-<br> Joystick Module---------------Arduino<br> VCC---------------------------5V
                            <br> VER---------------------------A1
                            <br> HOR---------------------------A0
                            <br> GND---------------------------GND
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Example Code:</h4>
                </button>
                    <div class="content">
                        <h5>//Joystick Pins<br> int x_key = A0;<br> int y_key = A1;<br> int x_pos;<br> int y_pos;<br> //Motor Pins<br> int EN_A = 11; //Enable pin for first motor<br> int IN1 = 9; //control pin for first motor<br> int IN2 = 8; //control pin
                            for first motor<br> int IN3 = 7; //control pin for second motor<br> int IN4 = 6; //control pin for second motor<br> int EN_B = 10; //Enable pin for second motor<br> //Initializing variables to store data<br> int motor_speed;<br>                            int motor_speed1;<br> void setup ( ) {<br> Serial.begin (9600); //Starting the serial communication at 9600 baud rate<br> //Initializing the motor pins as output<br> pinMode(EN_A, OUTPUT);<br> pinMode(IN1, OUTPUT); <br> pinMode(IN2,
                            OUTPUT);
                            <br> pinMode(IN3, OUTPUT); <br> pinMode(IN4, OUTPUT);<br> pinMode(EN_B, OUTPUT);<br> //Initializng the joystick pins as input<br> pinMode (x_key, INPUT) ;<br> pinMode (y_key, INPUT) ;<br> }
                            <br> void loop () {<br> x_pos = analogRead (x_key) ; //Reading the horizontal movement value<br> y_pos = analogRead (y_key) ; //Reading the vertical movement value<br> if (x_pos
                            < 400){ //Rotating the left motor in clockwise direction<br>
                                motor_speed = map(x_pos, 400, 0, 0, 255); //Mapping the values to 0-255 to move the motor<br> digitalWrite(IN1, LOW);<br> digitalWrite(IN2, HIGH);<br> analogWrite(EN_A, motor_speed);<br> }
                                <br> else if (x_pos>400 && x_pos
                                < 600){ //Motors will not move when the joystick will be at center<br>
                                    digitalWrite(IN1, LOW);<br> digitalWrite(IN2, LOW);<br> }
                                    <br> else if (x_pos > 600){ //Rotating the left motor in anticlockwise direction<br> motor_speed = map(x_pos, 600, 1023, 0, 255);<br> digitalWrite(IN1, HIGH);<br> digitalWrite(IN2, LOW);<br> analogWrite(EN_A, motor_speed);<br>                                    }
                                    <br> if (y_pos
                                    < 400){ //Rotating the right motor in clockwise direction<br>
                                        motor_speed1 = map(y_pos, 400, 0, 0, 255);<br> digitalWrite(IN3, LOW);<br> digitalWrite(IN4, HIGH);<br> analogWrite(EN_B, motor_speed1);<br> }
                                        <br> else if (y_pos>400 && y_pos
                                        < 600){<br>
                                            digitalWrite(IN3, LOW);<br> digitalWrite(IN4, LOW);<br> }
                                            <br> else if (y_pos > 600){ //Rotating the right motor in anticlockwise direction<br> motor_speed1 = map(y_pos, 600, 1023, 0, 255);<br> digitalWrite(IN3, HIGH);<br> digitalWrite(IN4, LOW);<br> analogWrite(EN_B,
                                            motor_speed1);
                                            <br> }
                                            <br> }
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn114"><img class="image" src="breadboard.jpg"></button><br>Breadboard
            <div id="myModal114" class="modal">
                <div class="modal-content">
                    <span class="close114">&times;</span>
                    <img src="breadboards.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>A breadboard is a construction base for prototyping of electronics. Originally the word referred to a literal bread board, a polished piece of wood used for slicing bread. In the 1970s the solderless breadboard became available
                            and nowadays the term "breadboard" is commonly used to refer to these.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Uses of Breadboard:</h4>
                </button>
                    <div class="content">
                        <h5>A breadboard is used to make up temporary circuits for testing or to try out an idea. No soldering is required so it is easy to change connections and replace components. Parts are not damaged and can be re-used afterwards.<br>                            Almost all the Electronics Club website projects started life on a breadboard to check that the circuit worked as intended.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connections on Breadboard:</h4>
                </button>
                    <div class="content">
                        <h5>Breadboards have many tiny sockets (called 'holes') arranged on a 0.1" grid. The leads of most components can be pushed straight into the holes. ICs are inserted across the central gap with their notch or dot to the left.<br> Wire
                            links can be made with single-core plastic-coated wire of 0.6mm diameter (the standard size), this is known as 1/0.6mm wire. I suggest buying a pack with several colours to help identify connections, red for +Vs wires, black
                            for 0V, and so on.<br> Stranded wire is not suitable because it will crumple when pushed into a hole and it may damage the board if strands break off.<br>The top and bottom rows are linked horizontally all the way across as
                            shown by the red and black lines on the diagram. The power supply is connected to these rows, + at the top and 0V (zero volts) at the bottom.<br> I suggest using the upper row of the bottom pair for 0V, then you can use the
                            lower row for the negative supply with circuits requiring a dual supply (e.g. +9V, 0V, -9V).<br> The other holes are linked vertically in blocks of 5 with no link across the centre as shown by the blue lines on the diagram.
                            Notice how there are separate blocks of connections to each pin of ICs
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Types Of Breadboards:</h4>
                </button>
                    <div class="content">
                        <h5>1. Full+<br> 1) Holes in the top and bottom 4 rows<br> The breadboard has strips of metal which run underneath the board and connect the holes on the top of the board. The metal strips are laid out as shown below. Note that the
                            top and bottom 4 rows of holes in total are connected horizontally, marked with "+" and "-", while the remaining holes are connected vertically.<br>
                            <img src="Row.png" class="collapsible_image" alt="image is here"><br> Take this: in Figure 2, the cathode of the LED and that of the diode is connected.<br>
                            <img src="Led.png" class="collapsible_image" alt="image is here"><br> Thus, you can see the holes in the same row at the top and bottom are connected. The metal strips beneath connects VCC and GND. In a circuit, when you need
                            to connect GND of all the devices, you'll need them. As shown below, the cathode of all the LEDs are connected, and then hooked up to GND of the SunFounder Uno board.<br>
                            <img src="Fid3.png" class="collapsible_image" alt="image is here"><br> 2) Holes in the center section<br>
                            <img src="Breadboard.png" class="collapsible_image" alt="image is here"><br> As we can see in Figure 5, groups of holes (terminals) vertically numbered from 1 to 60 (3 more after 60) are connected respectively. For example,
                            in Figure 6, the anode of each LED is connected with a 220ohm resistor. Then the other pin of the resistor is hooked up to the control board.<br>
                            <img src="Ed fig6.png" class="collapsible_image" alt="image is here"><br> To conclude, there are 126 groups of 5 connected terminals on a breadboard. Usually connect the components and parts via the groups of terminals. In
                            an experiment, when many components are used, you may hook them to a breadboard, thus making the wiring easy, simple and clear.<br> Note: The internal structure of a full+ sized breadboard and a half+ one is the same; the only
                            difference lies in the length. As the name suggests, the half+ is half as long as the full+.<br>
                            <img src="Half.png" class="collapsible_image" alt="image is here"><br> 2. Full<br> A full sized breadboard is a little bit different from a full+ sized one. Plug a diode on the breadboard. You can see in Figure 8, the groups
                            of terminals in the left half of the long row are green; there is a division vertical line in the middle, and groups on its right side are grey. Therefore, each of the 4 long rows is segmented into two.<br>
                            <img src="Mianbap.png" class="collapsible_image" alt="image is here"><br> For example, in Figure 9, the cathode of the diode and that of the LED is not connected.<br>
                            <img src="Fsahd.png" class="collapsible_image" alt="image is here"><br> This is the only difference between a full sized breadboard and a full+ sized one. On a full sized breadboard, the holes of each group in the center sections
                            are also connected vertically.<br> 3. Half & Half+<br> The internal structure of a half sized breadboard is the same as that of a half+ sized one. The difference lies in their appearance: there are two red and blue lines on
                            a half+ sized breadboard, which a half sized one does not have.<br>
                            <img src="Gfgf.png" class="collapsible_image" alt="image is here"><br>
                            <img src="Half+d.png" class="collapsible_image" alt="image is here"><br> As mentioned before, the internal structure of a half (half +) sized breadboard is the same as a full (full+) sized one. So also holes of the top and
                            bottom 4 long rows on a half or half+ sized breadboard is connected.<br> 4. Mini<br> The internal structure of a mini sized breadboard is almost the same as a half sized one. Only it does not have the top and bottom 4 long
                            rows. All it contains is the groups of terminals, which are also less than those on a half sized one. So naturally it is much smaller sized – so it is called "mini".<br>
                            <img src="Mini.png" class="collapsible_image" alt="image is here"><br> 5. Tiny<br> The internal structure of a tiny sized breadboard is the same as a mini sized one. But tiny sized one is slightly longer; also there are numbers
                            and letters on it. As mentioned before, the 5 terminals of each group named from 1 to 20 are connected vertically. And horizontally, A to E and F to J represents holes on<br>
                            <img src="Tiny.png" class="collapsible_image" alt="image is here"><br> 6. BB-301:-<br> This kind of breadboard is a little different from the previous ones in appearance. There are one hole at each of its four corners – by
                            which you can fix it. As for the internal structure, it's almost the same as a half sized one. But on a BB-301 breadboard there are only two long rows at the top and bottom.<br>
                            <img src="BB-301.png" class="collapsible_image" alt="image is here"><br> In Figure 14, the cathode of the LED is hooked up with that of the diode, and its anode to a 220ohm resistor.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn115"><img class="image" src="9v battery.jpg"></button><br>9V battery
            <div id="myModal115" class="modal">
                <div class="modal-content">
                    <span class="close115">&times;</span>
                    <img src="battery.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The nine-volt battery, or 9-volt battery, is a common size of battery that was introduced for the early transistor radios. It has a rectangular prism shape with rounded edges and a polarized snap connector at the top. This type
                            is commonly used in walkie-talkies, clocks and smoke detectors.<br> The nine-volt battery format is commonly available in primary carbon-zinc and alkaline chemistry, in primary lithium iron disulfide, and in rechargeable form
                            in nickel-cadmium, nickel-metal hydride and lithium-ion.<br>Mercury-oxide batteries of this format, once common, have not been manufactured in many years due to their mercury content.<br>Designations for this format include
                            NEDA 1604 and IEC 6F22 (for zinc-carbon) or MN1604 6LR61 (for alkaline). The size, regardless of chemistry, is commonly designated PP3—a designation originally reserved solely for carbon-zinc, or in some countries, E or E-block.<br>                            Most nine-volt alkaline batteries are constructed of six individual 1.5 V LR61 cells enclosed in a wrapper.These cells are slightly smaller than LR8D425 AAAA cells and can be used in their place for some devices, even though
                            they are 3.5 mm shorter.<br>Carbon-zinc types are made with six flat cells in a stack, enclosed in a moisture-resistant wrapper to prevent drying. Primary lithium types are made with three cells in series.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Connectors:</h4>
                </button>
                    <div class="content">
                        <h5>The battery has both terminals in a snap connector on one end. The smaller circular (male) terminal is positive, and the larger hexagonal or octagonal (female) terminal is the negative contact. The connectors on the battery are
                            the same as on the load device; the smaller one connects to the larger one and vice versa.The same snap-style connector is used on other battery types in the Power Pack (PP) series. Battery polarization is normally obvious,
                            since mechanical connection is usually only possible in one configuration. A problem with this style of connector is that it is very easy to connect two batteries together in a short circuit, which quickly discharges both batteries,
                            generating heat and possibly a fire. Because of this hazard, nine-volt batteries should be kept in the original packaging until they are going to be used.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>The most common type of nine-volt battery is often called a 9-volt, although there are less common nine-volt batteries of different sizes. Codes for the usual size include PP3 (for size and voltage, any technology), 6LR61 (IEC
                            code for alkaline batteries), and in Japan 006P.[citation needed]<br> The PP3 size battery is 48.5 mm × 26.5 mm × 17.5 mm or 1.91 in × 1.04 in × 0.69 in. Both terminals are at one end and their centers are 0.5 inches (12.7
                            mm) apart.<br> Inside an alkaline or carbon-zinc 9-volt battery there are six cylindrical or flat cells connected in series. Some brands use welded tabs internally to attach to the cells, others press foil strips against the
                            ends of the cells.<br> Rechargeable nickel–cadmium (NiCd) and nickel–metal hydride (NiMH) batteries of nominal 9V rating have between six and eight 1.2 volt cells. Lithium ion versions typically use two cells (3.7–4.2 V nominal
                            each). There are also lithium polymer and low self-discharge NiMH versions.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Lithium:</h4>
                </button>
                    <div class="content">
                        <h5>Lithium 9-volt batteries are consumer-replaceable, disposable high-energy-density batteries. In the PP3 size they are typically rated at 0.8-1.2Ah (e.g., >1.2Ah @ 900 ohms to 5.4V @ 23 °C for one type),about twice the capacity
                            of alkaline batteries. Manufacturers claim "High energy density, up to 5x more than alkaline". Common applications for lithium nine-volt batteries are smoke and carbon monoxide (CO) alarms, and electronic parking meters.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Testing and charging:</h4>
                </button>
                    <div class="content">
                        <h5>Most battery voltage testers and chargers that can also test nine-volt need another snap clip to hold the battery, while cylindrical batteries often share a holder that may be adjustable in size.<br>Because of the proximity of
                            the positive and negative terminals at the top of the battery and relatively low current of most common batteries, one informal method of testing voltage is to place the two terminals across a tongue. A strong tingle would
                            indicate a battery with a strong charge, the absence, a discharged battery.<br>While there have been stories circulating of unfortunate outcomes, the process is rarely dangerous under normal circumstances, though it may be
                            unpleasant.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn116"><img class="image" src="water pump 5v.jpg"></button><br>Water Pump 5V 120L/H for Arduino and Raspberry
            <div id="myModal116" class="modal">
                <div class="modal-content">
                    <span class="close116">&times;</span>
                    <img src="summersible.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is a low cost mini submersible type water pump that works on 3-6V DC. It is extremely simple and easy to use.<br>Just immerse the pump in water, connect a suitable pipe to the outlet and power the motor with 3-6V to start
                            pumping water. Great for building science projects, fire-extinguishers, fire fighting robots, fountains, waterfalls, plant watering systems etc.<br> This motor is small, compact and light. It can be controlled from a micro
                            controller/Arduino using our DC Motor Drivers or one of our Relay Boards.<br>You may use our 5V SMPS Power Supply Adapter to run this pump. You may also use our 6V Solar Panel to run the pump with appropriate a 6V voltage regulator.<br>                            Note: Do not run the pump dry (without putting it in water) and do not use it to pump flamable liquids.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Operating DC Voltage: 2.5-6V<br> Maximum Water lift height: 40-110cm / 15.75"-43.4"<br> Flow rate: 80-120L/H<br> Outer Diameter of Water Outlet: 7.5mm / 0.3"<br> Inside Diameter of Water Outlet: 5mm / 0.2"<br> Pump Diameter: Approx.
                            24mm / 0.95"<br> Pump Length: Approx. 45mm / 1.8"<br> Pump Height: Approx. 30mm / 1.2"<br> Wire Length: ~13mm cm
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Applications:</h4>
                </button>
                    <div class="content">
                        <h5>Great for building science projects, fire-extinguishers, fire fighting robots, fountains, waterfalls, plant watering systems etc.<br> Controlled fountain water flow<br> Controlled Garden watering systems<br> Hydroponic Systems<br>                            Fresh water intake or exhaust systems for fish aquqriums
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn117"><img class="image" src="9vplug_LRG.jpg"></button><br>9 VDC 1000mA regulated switching power adapter
            <div id="myModal117" class="modal">
                <div class="modal-content">
                    <span class="close117">&times;</span>
                    <img src="adapter.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>This is a really nice power supply. It's a switching DC supply so its small and light and efficient. It is thin so it fits in power strips without blocking other outlets.The output is regulated so you'll get a steady 9V up to 1000mA
                            (1 Amp) of current draw.<br>5.5mm/2.1mm barrel jack, positive tip. This supply is designed to work anywhere in the world, 100V-240V AC wall power, you'll just need a low cost plug adapter.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn118"><img class="image" src="proto shield.jpg"></button><br>Adafruit Proto Shield for Arduino
            <div id="myModal118" class="modal">
                <div class="modal-content">
                    <span class="close118">&times;</span>
                    <img src="arduino proto shield.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Works with the Uno! This prototyping shield is the best out there (well, we think so, at least). It works with UNO, NG, Diecimila and Duemilanove Arduinos.<br>You can use it with a Leonardo but it will not break out the hardware
                            SPI pins (they're only on the ISP connector underneath) or the IOREF/SDA/SCL pins. However, the SDA/SCL pins on the Leonardo are also on digital #2 and #3 so you can still use them by connecting to #2 and #3.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>It has a nice standard 0.1"x0.1" prototying grid with big pads<br> A IC pattern for adding DIP ICs up to 20 pins<br> Power rails down the middle and sides<br> A reset button and an extra general use button<br> 2 3mm general use
                            LEDs, red and green, as well as 2 matching resistors<br> The ICSP header is up top if you like to upload to your Arduino using a programmer<br> A surface-mount chip area for up to 14 SOIC size parts<br> Compatible with either
                            tiny breadboards or 'standard' breadboards with the rails removed.<br> Every pin is brought out, including the new 3V and Reset header pins<br> 2 0.1uF capacitors on either side for extra power stability
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn119"><img class="image" src="data logger module.jpg"></button><br>Logging Recorder Shield Data Logger Module for Arduino
            <div id="myModal119" class="modal">
                <div class="modal-content">
                    <span class="close119">&times;</span>
                    <img src="logschemv1.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                        <h4>Descriptions:</h4>
                    </button>
                    <div class="content">
                        <h5>Here’s a handy Arduino shield we’ve had a lot of people looking for a dedicated and well-designed data logging shield. We worked hard to engineer an inexpensive but well-rounded design.<br>Not only is it easy to assemble and customize.
                            The Data Logger module Logging Shield data Recorder Shield also comes with great documentation and libraries.<br> SD card interface works with FAT16 or FAT32 formatted cards. 3.3v level shifter circuitry prevents damage to
                            your SD card. It also equips a Real-time clock (RTC) which keeps the time going even when the Arduino is unplugged. And, the most important the battery backup lasts for years. Cool!!!<br> Included libraries and example code
                            for both SD and RTC mean you can get going quickly Prototyping area for soldering connectors, circuitry or sensors.<br>The Onboard 3.3v regulator is both a reliable reference voltage and also reliably runs SD cards that require
                            a lot of power to run.
                        </h5>
                    </div>
                    <button class="collapsible">
                        <h4>Features:</h4>
                    </button>
                    <div class="content">
                        <h5>Works with Arduino UNO, Duemilanove, Diecimila, Leonardo or ADK/Mega R3 or higher. ADK/Mega R2 or lower are not supported.<br> A dedicated and well-designed data logging shield for Arduino.<br> It is easy to assemble and customize,
                            also equipped with extensive documentation and libraries.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn120"><img class="image" src="battery holder 9v.jpg"></button><br>9V Battery Holder with shell with switch
            <div id="myModal120" class="modal">
                <div class="modal-content">
                    <span class="close120">&times;</span>
                    <img src="battery holder.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>9V Battery Holder Box with Slide Switch and 2.1mm Plug for Arduino or CCTV.<br> This 9V battery holder allows your battery to snap in tight and holds it in place, which is great in situations where you don’t want the battery just
                            hanging.
                            <br>It also has three mounting holes so you can attach it securely to your enclosure. It is terminated with a standard 5.5 x 2.1 mm, center-positive barrel jack.<br> The holders are moulded in Delryn with corrosive resistant
                            nickel plated springs and studs. A PP3 battery holder moulded in black thermoplastic with DC JACK. Can be screwed to a base for the most secure mounting.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>9V Battery Box<br> On/Off Slide Switch<br> DC Power Plug 2.1mm x 5.5mm x 9.5mm<br> Shaft Length: 9.5mm
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn121"><img class="image" src="ftdi.jpg"></button><br>FTDI Serial TTL-232 USB Cable
            <div id="myModal121" class="modal">
                <div class="modal-content">
                    <span class="close121">&times;</span>
                    <img src="ftdiserial.png" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Just about all electronics use TTL serial for debugging, bootloading, programming, serial output, etc.<br>But it's rare for a computer to have a serial port anymore. This is a USB to TTL serial cable, with a FTDI FT232RL usb/serial
                            chip embedded in the head. It has a 6-pin socket at the end with 5V power and ground, as well as RX, TX, RTS and CTS at 3V logic levels.<br>These are perfect for use with a Boarduino, Meggy's, or other Arduino clones and derivatives,
                            and Fuzeboxen. Useful whenever you want to communicate with a TTL serial device, such as an XBee.<br> New! We now have a version with a translucent body and RX/TX LEDs! Now it's easier than ever to debug your setup or see data
                            transfer, the red and green LEDs will blink when data is transmitted/received by the FTDI chip. The version we have is the 3.3V. The data signals are at 3V and the power line provides 5V.<br>We suggest this for any product
                            that needs FTDI cables. Because the cable is 5V-logic compliant, you can use it with 3v or 5v logic just fine - no level shifting required!.<br> If you have a device that is running at 5V logic and requires 5V power, this cable
                            will work fine. If you want to tweak the voltages and signals a little, you should also check out the FTDI friend.<br> This cable is fully compatible with the TTL-232 cable from FTDI. You can download the drivers and the diagram
                            / spec sheet which has mechanical cable details.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>Cable Length: 3' / 914mm<br> Diameter: 5mm / 0.2"<br> Weight: 38g
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Datasheet:</h4>
                </button>
                    <div class="content">
                        <h5>Datasheet<a href="FT232_3.3V_with_LED.pdf">click here for datasheet</a>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn122"><img class="image" src="proto-screw-shield.jpg"></button><br>Proto Screw Shield
            <div id="myModal122" class="modal">
                <div class="modal-content">
                    <span class="close122">&times;</span>
                    <img src="proto screw shield.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The Proto Screw Shield is the ultimate breakout board for an Arduino. It combines a prototyping shield with a full set of 3.5 mm screw terminal blocks.<br>The proto shield part lets you build custom circuitry and then you can easily
                            & securely connect wires and sensors to the terminal blocks. Great for panel mounts, buttons, sensors, enclosures etc.<br> Proto Screw Shield is Pre-Assembled so that it can be directly screwed onto the thread posts. It is
                            reliable and convenient.<br> The Arduino Proto Screw Shield extends all pins of the Arduino out to 3.5mm pitch screw terminals. It also has a lot of the utility provided by Arduino Protoshield, including a large prototyping
                            space of both connected and unconnected 0.1″ spaced through-holes, a reset button, LED for D13 pin indicating.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino terminal to provide the IO, port connection.<br> 3.81 posts quality, reliable, convenient, durable.<br> Combined with the Proto Shield, the middle can be used as a prototype expansion board.<br> Double-sided PCB Prototyping
                            extended area vias connecting the front sides can be welded components.<br> The middle section can be placed small bread plate, convenient test extend
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Specifications:</h4>
                </button>
                    <div class="content">
                        <h5>Arduino R3 Pinout<br> 3.5mm Pitch Screw Terminals<br> Reset Button<br> Built-in LED
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn123"><img class="image" src="16-channel.jpg"></button><br>Servo Shield Arduino 16-Channel 12-bit PWM/Servo Shield
            <div id="myModal123" class="modal">
                <div class="modal-content">
                    <span class="close123">&times;</span>
                    <img src="adafruit 16 channel.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>You want to make a cool Arduino robot, maybe a hexapod walker, or maybe just a piece of art with a lot of moving parts. Or maybe you want to drive a lot of LEDs with precise PWM output.<br>Then you realize that the Arduino has
                            only a few PWM outputs, and maybe those outputs are conflicting with another shield! What now? You could give up OR you could just get our handy PWM and Servo driver shield.<br>It's just like our popular PWM/Servo Breakout
                            but now Arduino-ready and works with any Arduino that uses shields: Uno, Leo, Mega, ADK, its all good.<br> When we saw this chip, we quickly realized what an excellent add-on this would be. Using only two I2C pins, control
                            16 free-running PWM outputs! You can even stack up 62 shields to control up to 992 PWM outputs (which we would really like to see since it would be glorious and like 4 feet tall).<br>Because I2C is a shared bus you can also
                            connect other I2C devices and sensors to the SCL/SDA pins as long as their addresses don't conflict (this shield has address 0x40).<br>
                            <li>There's an I2C-controlled PWM driver with a built in clock. That means that, unlike the TLC5940 family, you do not need to continuously send it signal tying up your microcontroller, its completely free running!</li>
                            <li>It is 5V compliant, which means you can control it from a 3.3V Arduino and still safely drive up to 6V outputs (this is good for when you want to control white or blue LEDs with 3.4+ forward voltages)</li>
                            <li>6 address select pins so you can stack up to 62 of these on a single i2c bus. 12 out of 16 output pins can be accessed when stacked.</li>
                            <li>Adjustable frequency PWM up to about 1.6 KHz</li>
                            <li>12-bit resolution for each output - for servos, that means about 4us resolution at 60Hz update rate</li>
                            <li>Configurable push-pull or open-drain output</li>
                            </ul>
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Shield Connections:</h4>
                </button>
                    <div class="content">
                        <h5>Pins Used:-<br> The shield plugs in directly into any shield-compatible Arduino such as Duemilanove, Diecimila, UNO, Leonardo, Mega R3+, ADK R3+. The only pins required to run are the Ground, 5V and SDA + SCL I2C control pins.<br>                            For backwards compatibility with old Ardunos, SCL is connected to A5 and SDA is connected to A4. UNOs already have this connection on board. If you are using a Leonardo or Mega and want to use the A4/A5 pins, cut the traces
                            on the top of the board between A4 and A5 and the two pins next to them labeled SCL/SDA.<br> If you are using a Mega or ADK R2 or earlier, you will have to solder a wire from SCL to D21 and SDA to D20.<br><br> Connecting other
                            I2C devices:-<br> Since I2C is a 'shared bus' you can still connect other I2C devices to the SDA/SCL pins as long as they do not have a conflicting address. The default address for the shield is address 0x40<br><br> Powering
                            Servos / PWM:-<br> This shield has two power supplies. One is VCC - that is the 5V power from the Arduino, it is used to power the PWM chip and determines the I2C logic level and the PWM signal logic level. When this power
                            supply is working you will see a red LED. The red LED must be lit for the Arduino & shield to work! Plug in the Arduino to USB or a wall adapter to provide it.<br> To power servos you will need to also connect the V+ power
                            supply - this is the power supply for the servos. (If you are lighting up single LEDs you may not need this power supply.) This power supply should be 5 or 6VDC. You can connect this power through the blue terminal block. There
                            is reverse-polarity protection in case you hook up power backwards.<br> Nearly all servos are designed to run on about 5 or 6v. Keep in mind that a lot of servos moving at the same time (particularly large powerful ones) will
                            need a lot of current. Even micro servos will draw several hundred mA when moving. Some High-torque servos will draw more than 1A each under load.<br> Good power choices are:-<br> -5v 2A switching power supply (up to perhaps
                            4 servos)<br> -5v 10A switching power supply (up to perhaps 16 servos)<br> -4xAA Battery Holder - 6v with Alkaline cells. 4.8v with NiMH rechargeable cells, portable!<br> -4.8 or 6v Rechargeable RC battery packs from a hobby
                            store.
                            <br><br> Adding a Capacitor to the thru-hole capacitor slot:-<br> We have a spot on the PCB for soldering in an electrolytic capacitor. Based on your usage, you may or may not need a capacitor. If you are driving a lot of servos
                            from a power supply that dips a lot when the servos move, n * 100uF where n is the number of servos is a good place to start - eg 470uF or more for 5 servos.<br>Since its so dependent on servo current draw, the torque on each
                            motor, and what power supply, there is no "one magic capacitor value" we can suggest which is why we don't include a capacitor in the kit.<br><br> Connecting a Servo:-<br> Most servos come with a standard 3-pin female connector
                            that will plug directly into the headers on the Servo Driver. Be sure to align the plug with the ground wire (usually black or brown) with the bottom row and the signal wire (usually yellow or white) on the top.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>The I2C input, PWM output control 16 roads, steering gear can 16 roads.<br> The steering gear power independent V + input maximum 6 V.<br> Logic signals and logical power independent output for 3V to 5 V.<br> 40-1000 Hz frequency.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn124"><img class="image" src="wave shield.jpg"></button><br>Adafruit Wave Shield
            <div id="myModal124" class="modal">
                <div class="modal-content">
                    <span class="close124">&times;</span>
                    <img src="adafruti wave shield.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Adding quality audio to an electronic project is surprisingly difficult. Here is a shield for Arduino 328's that solves this problem. It can play up to 22KHz 12bit uncompressed audio files of any length. It's low cost, available
                            as an easy-to-make kit. It has an onboard DAC, filter and op-amp for high quality output.<br>Audio files are read off of an SD/MMC card, which are available at nearly any store. Volume can be controlled with the onboard thumbwheel
                            potentiometer.
                            <br> This shield is a kit, and comes with all parts you need to build it.<br> Arduino, SD card, tools, speaker and headphones are not included. It is fairly easy to construct and anyone with a successful soldering project under
                            their belt should be able to build it.<br> The shield comes with an Arduino library for easy use; simply drag uncompressed wave files onto the SD card and plug it in. Then use the library to play audio when buttons are pressed,
                            or when a sensor goes off, or when serial data is received, etc. Audio is played asynchronously as an interrupt, so the Arduino can perform tasks while the audio is playing.<br><br> -Can play any uncompressed 22KHz 16bit (on
                            a 12bit DAC), mono Wave (.wav) files of any size. While it isnt CD quality, it is certainly good enough to play music, have spoken word, or audio effects. Check out the demo video/audio at the webpage<br> -Output is mono, into
                            L and R channels, standard 3.5mm headphone jack and a connection for a speaker that is switched on when the headphones are unplugged<br> -Files are read off of a FAT16/FAT32-formatted SD/MMC card <br> -Included library and
                            examples makes playing audio easy<br> -Please note that the library is rather bulky, requiring 10K of flash and more than 1/2 K of RAM for buffering audio. It works fine using any ATmega328-based Arduino (Duemilanove, Uno or
                            compatible).
                            <br> -This shield is not Zero, Due, Mega or Leonardo compatible! (Only for use with '328-based Arduinos)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Uses:</h4>
                </button>
                    <div class="content">
                        <h5>-Make a portable audio player<br> -Use the AT&T text-to-speech site to make snippets of speech that you string together for a talking project, like..<br> -Talking temperature sensor<br> -Talking clock<br> -Interfaces for sight-impared
                            people
                            <br> -Doorbell that plays a cool tune<br> -Jukebox/music-box that plays a song when its opened, or a coin is inserted<br> -Security system that warns the intruder<br> -Audio looper for musical effects and performances<br> -Synthesizer
                            with different sounds<br> -Really freaky halloween props that scream<br> -Display (like a point-of-sale box) that you can plug into to hear the message
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Datasheet:</h4>
                </button>
                    <div class="content">
                        <h5>click here for datasheet:<a href="adafruit-wave-shield-audio-shield-for-arduino.pdf">datasheet</a>
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn125"><img class="image" src="raspberry pi usb cable.jpg"></button><br>Raspberry Pi USB Cable, Micro USB Power Charging Cable
            <div id="myModal125" class="modal">
                <div class="modal-content">
                    <span class="close125">&times;</span>
                    <img src="usb for raspberry pi.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Micro USB Cable for Raspberry Pi is the emerging standard for charging and transferring data. The data transfer bandwidth along with power output could be great for the raspberry pi. It could be used to not only power the pi but
                            as a way to display it as well in one port.<br> Imagine being able to keep your favorite Pi distro with you in your bag or pocket that you could load up on your laptop with you anywhere just by plugging it in with a single
                            cable.
                            <br>The software would be used to display it within windows/osx/Linux and you could use your computer’s peripherals within it. The way we picture it is in the way a virtual machine would work but without using your computer’s
                            resources.
                            <br> The possibilities are near endless and it makes it easier for first time users to tinker with. Education programs that utilize Pi’s could start students out this way to make it seem less intimidating and could even spring
                            up new uses for Pi users.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Features:</h4>
                </button>
                    <div class="content">
                        <h5>Tested for Compatibility with the Raspberry Pi<br> 26AWG (Up to 2A)<br> 1.8m Long<br> Colour: Black<br> Connector Type A: USB <br> Connector Type B: Micro USB
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn126"><img class="image" src="neopixel 40 rgb led.jpg"></button><br>NeoPixel Shield 40 RGB LED Pixel Matrix
            <div id="myModal126" class="modal">
                <div class="modal-content">
                    <span class="close126">&times;</span>
                    <img src="neopixel.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>Put on your sunglasses before putting this shield onto your 'duino - 40 eye-blistering RGB LEDs adorn the NeoPixel shield for a blast of configurable color. Arranged in a 5x8 matrix, each pixel is individually addressable. Only
                            one pin (Digital #6) is required to control all the LEDs. You can cut a trace and use nearly any other pin if you need some customization.<br> To make it easy to start, the LEDs are by default powered from the 5V onboard Arduino
                            supply. As long as you aren't lighting up all the pixels full power white that should be fine.<br>If you want to power the shield with an external power supply, solder in the included terminal block (pro-tip: put it on the
                            bottom of the board so it doesn't stick up) to wire in an external 4-6VDC power supply - that power supply will also power the Arduino and shield. If you want to use the terminal block to power the shield but keep the Arduino
                            itself on DC or USB power only, cut the center of the solder jumper to the right of the terminal block. There's a polarity protection FET on the external input in case you wire the power backwards (we would never do that, it
                            was, umm, a friend of ours, yeah that's it!)<br> If, say, you need MORE blinky, you can chain these together. For the second shield, connect the DIN connection to the first shield's DOUT. Also connect a ground pin together
                            and power with 5V. There you go! You can chain as many as you'd like although after 5 or more shields you may run low on RAM if you're using an UNO.<br> We include both stacking headers and plain headers. Use whichever you
                            prefer - there isn't a lot of space left over for the 'duino pin breakouts so if you want to wire up some other outputs or sensors the stacking headers are good. For a slim sturdy look, solder on the plain headers.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Technical Details:</h4>
                </button>
                    <div class="content">
                        <h5>Dimensions:53.36mm / 2.1" x 68.85mm / 2.7" x 3.22mm / 0.12"<br> Weight: 27.10g<br> May ship with either WS2812B or SK6812-based LEDs. They are the same functionality, color order and protocol
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn127"><img class="image" src="CNC-Shield-for-Arduino.jpg"></button><br>Arduino CNC shield (GRBL Compatible)
            <div id="myModal127" class="modal">
                <div class="modal-content">
                    <span class="close127">&times;</span>
                    <img src="Arduino-CNC-Shield-Scematics-V3.XX_.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>How do I run GRBL on Arduino?:</h4>
                </button>
                    <div class="content">
                        <h5>Open up the Arduino IDE and make sure your Arduino with Grbl is connected to your USB port. Select the Arduino's Serial Port in the Tools menu, as you would normally with an Arduino. Open up the 'Serial Window' in the Tools menu.
                            If you are using Grbl v0.9, make sure to change the baud rate from 9600 to 115200.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>What is CNC Shield v3?:</h4>
                </button>
                    <div class="content">
                        <h5>CNC Shield V3 for Arduino® The CNC Shield V3 for Arduino®, is an Arduino compatible board that turns your Arduino into a CNC controller. Using an opensource firmware it can control up to 4 Stepper motor using DRV8825 or A4988 stepper
                            motor driver making it easy to get your CNC projects up and running in a few hours.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>What does GRBL stand for?:</h4>
                </button>
                    <div class="content">
                        <h5>Grbl is a free, open source, high performance software for controlling the motion of machines that move, that make things, or that make things move, and will run on a straight Arduino. If the maker movement was an industry, Grbl
                            would be the industry standard. Most open source 3D printers have Grbl in their hearts.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>What is GRBL controller?:</h4>
                </button>
                    <div class="content">
                        <h5>Grbl Controller is software that is designed to send GCode to CNC machines, such as 3D milling machines. It isn't super smart, it just needs to give the user a nice way to get commands down to whatever controller they are using.
                            Version 3.0 is has been optimized for the Arduino to control Grbl shields.
                        </h5>
                    </div>
                </div>
            </div>
        </div>
        <div class="item"><button class="effe" id="myBtn128"><img class="image" src="raspberry pi cnc.jpg"></button><br>Raspberry Pi CNC
            <div id="myModal128" class="modal">
                <div class="modal-content">
                    <span class="close128">&times;</span>
                    <img src="pi cnc.jpg" class="collapsible_image" alt="image is here"><br>
                    <button class="collapsible">
                    <h4>Descriptions:</h4>
                </button>
                    <div class="content">
                        <h5>The Protoneer RPI CNC Board combines a real-time CNC controller (Micro-controller running GRBL) with a powerful credit card size computer - a Raspberry Pi! By connecting the two systems, the CNC board created an ecosystem where
                            the Raspberry Pi provides benefits such as: Processing power, connectivity (IOT) and a well supported community.<br> The board plugs directly into the Raspberry Pi General Purpose Input/Output pins, with the micro-controller
                            and Raspberry Pi communicating via serial. (/dev/ttyAMA0).
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Important Warnings:</h4>
                </button>
                    <div class="content">
                        <h5>None of the components should be powered while installing or configuring.<br> Do not power up the board with stepper drivers installed if they are not connected to stepper motors. The stepper drivers are current limiting and will
                            overheat if they are not connected.<br> Make sure to plug in the Stepper driver in the right way round. EN of each axis should align with the "Enable" pin of the stepper driver. (Some Chinese stepper drivers have the printed
                            pin names up side down.)
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Software (Firmware):</h4>
                </button>
                    <div class="content">
                        <h5>Uploading new firmware<br> Version 2.58+:-<br> As of this version firmware can directly be upload from the Raspberry Pi.<br><br> Upload procedure:-<br> The Raspberry Pi V4.00 image includes script to update the firmware on the
                            Raspberry Pi CNC HAt.<br><br> Upgrade Procedure:-<br> Firstly make sure no software is connected to the Hat's serial port.(A clean V4 image will start of in that state) (Only one app can connect at a time and if its being used
                            the firmware will not update.)<br> On the desktop there is a folder called "Update Firmware" that contains 3 shortcuts for changing the firmware<br> 1.GRBL 0.9<br> 2.GRBL 1.1<br> 3.Latest GRBL (Experimental):-<br> By double
                            clicking one , it will execute a script that uploads the firmware.<br> Before shipping each board we test the firmware and we use the same script to upload the initial firmware before automated testing starts.<br> The upload
                            script uses Python GPIO libs and sometimes does not upload the first time while the pins gets configured.(Bootloader timing issue that happens rarely) If so try a second time.<br><br> Older version:-<br> Firmware gets uploaded
                            from the Nano's usb port.<br><br> GRBL Firmware:-<br> GRBL is the magic that does the actual control of the CNC machines.
                        </h5>
                    </div>
                    <button class="collapsible">
                    <h4>Hardware:</h4>
                </button>
                    <div class="content">
                        <h5>Version 2.60:-<br> Added a Grove Connector to allow I2C connections directly to the Raspberry Pi.<br> Green Screw connectors changed from 3.5mm pitch to 3.81mm pitch.<br> Moved Stepper Drivers inline.<br><br> Version 2.58:-<br>                            Replaced the Arduino Nano with a embedded micro-controller(ATMEGA328 - Arduino UNO compatible)<br> Add reset circuitry to enable programming directly from the Raspberry Pi. ISP pins added and preloaded with the Opti-Boot bootloader.
                            This opens the door for other firmwares like Firmata.<br> Replaced clone jumpers with solder-able jumpers.<br> Later batches might have dip-switches instead of Jumper headers.<br> First Protoneer board to be mode on our Pick
                            and Place machine.<br><br> Version 2.51:-<br> Extra Stepper Drivers Socket that can clone one of the other Axes.<br> End-stop + Probe line noise filters. Allows end stops to work with normal un-shielded cable.<br> Breakout
                            pins allowing external Stepper drivers to be hooked up.<br><br> Version 2.11:-<br> Initial Version<br> 3-Axis (XYZ)<br> End Stop for each Axis (XYZ)<br> Variable Speed Spindle / Laser Intensity control (PWM Spindle pin and
                            Direction pin)<br> Coolant control pin. (Extra output pin)
                        </h5>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div align="center" class="icon_div">
        <a href="https://www.facebook.com/swapnil.dutta.988"><img class="favicon1" src="facebook.png"></a>
        <a href="https://twitter.com/SSonupatra?s=08"><img class="favicon1" src="twitter.png"></a>
        <a href="https://www.instagram.com/__swapnil99/"><img class="favicon1" src="instagram.png"></a>
        <a href="https://www.linkedin.com/in/s-sonu-patra-b2a64215b"><img class="favicon1" src="linkedin-logo.png"></a>
    </div>
    <div id="id1">
        <br>
        <h1 id="id2"><em>COMPANY DETAILS</em></h1>
        <br>
        <h1 id="id2"><u>Contact:</u>&nbsp;6372877656,7540866187</h1>
        <h1 id="id2">Email:&nbsp;<a href="mailto:s.sonupatra@gmail.com">s.sonupatra@gmail.com</a>,<br><a href="mailto:duttaswapnil69@gmail.com">duttaswapnil69@gmail.com</a></h1>
        <br>
        <h1 id="id2"><u>Address:</u> <br>Unit-9</Unit-9>,<br>Bhubaneswar,Odisha,India</h1>
        <h1 id="id2">Our helpline is open 24X7.</h1>
    </div>
    <script>
        function myFunction() {
            var x = document.getElementById("myTopnav");
            if (x.className === "topnav") {
                x.className += " responsive";
            } else {
                x.className = "topnav";
            }
        }
    </script>
    <script>
        var modal = document.getElementById("myModal");
        var btn = document.getElementById("myBtn");
        var span = document.getElementsByClassName("close")[0];
        btn.onclick = function() {
            modal.style.display = "block";
        }
        span.onclick = function() {
            modal.style.display = "none";
        }
        var modal1 = document.getElementById("myModal1");
        var btn1 = document.getElementById("myBtn1");
        var span1 = document.getElementsByClassName("close1")[0];
        span1.onclick = function() {
            modal1.style.display = "none";
        }
        btn1.onclick = function() {
            modal1.style.display = "block";
        }
        var modal2 = document.getElementById("myModal2");
        var btn2 = document.getElementById("myBtn2");
        var span2 = document.getElementsByClassName("close2")[0];
        btn2.onclick = function() {
            modal2.style.display = "block";
        }
        span2.onclick = function() {
            modal2.style.display = "none";
        }
        var modal3 = document.getElementById("myModal3");
        var btn3 = document.getElementById("myBtn3");
        var span3 = document.getElementsByClassName("close3")[0];
        btn3.onclick = function() {
            modal3.style.display = "block";
        }
        span3.onclick = function() {
            modal3.style.display = "none";
        }
        var modal4 = document.getElementById("myModal4");
        var btn4 = document.getElementById("myBtn4");
        var span4 = document.getElementsByClassName("close4")[0];
        btn4.onclick = function() {
            modal4.style.display = "block";
        }
        span4.onclick = function() {
            modal4.style.display = "none";
        }
        var modal5 = document.getElementById("myModal5");
        var btn5 = document.getElementById("myBtn5");
        var span5 = document.getElementsByClassName("close5")[0];
        btn5.onclick = function() {
            modal5.style.display = "block";
        }
        span5.onclick = function() {
            modal5.style.display = "none";
        }
        var modal6 = document.getElementById("myModal6");
        var btn6 = document.getElementById("myBtn6");
        var span6 = document.getElementsByClassName("close6")[0];
        btn6.onclick = function() {
            modal6.style.display = "block";
        }
        span6.onclick = function() {
            modal6.style.display = "none";
        }
        var modal7 = document.getElementById("myModal7");
        var btn7 = document.getElementById("myBtn7");
        var span7 = document.getElementsByClassName("close7")[0];
        btn7.onclick = function() {
            modal7.style.display = "block";
        }
        span7.onclick = function() {
            modal7.style.display = "none";
        }
        var modal8 = document.getElementById("myModal8");
        var btn8 = document.getElementById("myBtn8");
        var span8 = document.getElementsByClassName("close8")[0];
        btn8.onclick = function() {
            modal8.style.display = "block";
        }
        span8.onclick = function() {
            modal8.style.display = "none";
        }
        var modal9 = document.getElementById("myModal9");
        var btn9 = document.getElementById("myBtn9");
        var span9 = document.getElementsByClassName("close9")[0];
        btn9.onclick = function() {
            modal9.style.display = "block";
        }
        span9.onclick = function() {
            modal9.style.display = "none";
        }
        var modal10 = document.getElementById("myModal10");
        var btn10 = document.getElementById("myBtn10");
        var span10 = document.getElementsByClassName("close10")[0];
        btn10.onclick = function() {
            modal10.style.display = "block";
        }
        span10.onclick = function() {
            modal10.style.display = "none";
        }

        var modal11 = document.getElementById("myModal11");
        var btn11 = document.getElementById("myBtn11");
        var span11 = document.getElementsByClassName("close11")[0];
        span11.onclick = function() {
            modal11.style.display = "none";
        }
        btn11.onclick = function() {
            modal11.style.display = "block";
        }
        var modal12 = document.getElementById("myModal12");
        var btn12 = document.getElementById("myBtn12");
        var span12 = document.getElementsByClassName("close12")[0];
        btn12.onclick = function() {
            modal12.style.display = "block";
        }
        span12.onclick = function() {
            modal12.style.display = "none";
        }
        var modal13 = document.getElementById("myModal13");
        var btn13 = document.getElementById("myBtn13");
        var span13 = document.getElementsByClassName("close13")[0];
        btn13.onclick = function() {
            modal13.style.display = "block";
        }
        span13.onclick = function() {
            modal13.style.display = "none";
        }
        var modal14 = document.getElementById("myModal14");
        var btn14 = document.getElementById("myBtn14");
        var span14 = document.getElementsByClassName("close14")[0];
        btn14.onclick = function() {
            modal14.style.display = "block";
        }
        span14.onclick = function() {
            modal14.style.display = "none";
        }
        var modal15 = document.getElementById("myModal15");
        var btn15 = document.getElementById("myBtn15");
        var span15 = document.getElementsByClassName("close15")[0];
        btn15.onclick = function() {
            modal15.style.display = "block";
        }
        span15.onclick = function() {
            modal15.style.display = "none";
        }
        var modal16 = document.getElementById("myModal16");
        var btn16 = document.getElementById("myBtn16");
        var span16 = document.getElementsByClassName("close16")[0];
        btn16.onclick = function() {
            modal16.style.display = "block";
        }
        span16.onclick = function() {
            modal16.style.display = "none";
        }
        var modal17 = document.getElementById("myModal17");
        var btn17 = document.getElementById("myBtn17");
        var span17 = document.getElementsByClassName("close17")[0];
        btn17.onclick = function() {
            modal17.style.display = "block";
        }
        span17.onclick = function() {
            modal17.style.display = "none";
        }
        var modal18 = document.getElementById("myModal18");
        var btn18 = document.getElementById("myBtn18");
        var span18 = document.getElementsByClassName("close18")[0];
        btn18.onclick = function() {
            modal18.style.display = "block";
        }
        span18.onclick = function() {
            modal18.style.display = "none";
        }
        var modal19 = document.getElementById("myModal19");
        var btn19 = document.getElementById("myBtn19");
        var span19 = document.getElementsByClassName("close19")[0];
        btn19.onclick = function() {
            modal19.style.display = "block";
        }
        span19.onclick = function() {
            modal19.style.display = "none";
        }
        var modal20 = document.getElementById("myModal20");
        var btn20 = document.getElementById("myBtn20");
        var span20 = document.getElementsByClassName("close20")[0];
        btn20.onclick = function() {
            modal20.style.display = "block";
        }
        span20.onclick = function() {
            modal20.style.display = "none";
        }
        var modal21 = document.getElementById("myModal21");
        var btn21 = document.getElementById("myBtn21");
        var span21 = document.getElementsByClassName("close21")[0];
        span21.onclick = function() {
            modal21.style.display = "none";
        }
        btn21.onclick = function() {
            modal21.style.display = "block";
        }
        var modal22 = document.getElementById("myModal22");
        var btn22 = document.getElementById("myBtn22");
        var span22 = document.getElementsByClassName("close22")[0];
        btn22.onclick = function() {
            modal22.style.display = "block";
        }
        span22.onclick = function() {
            modal22.style.display = "none";
        }
        var modal23 = document.getElementById("myModal23");
        var btn23 = document.getElementById("myBtn23");
        var span23 = document.getElementsByClassName("close23")[0];
        btn23.onclick = function() {
            modal23.style.display = "block";
        }
        span23.onclick = function() {
            modal23.style.display = "none";
        }
        var modal24 = document.getElementById("myModal24");
        var btn24 = document.getElementById("myBtn24");
        var span24 = document.getElementsByClassName("close24")[0];
        btn24.onclick = function() {
            modal24.style.display = "block";
        }
        span24.onclick = function() {
            modal24.style.display = "none";
        }
        var modal25 = document.getElementById("myModal25");
        var btn25 = document.getElementById("myBtn25");
        var span25 = document.getElementsByClassName("close25")[0];
        btn25.onclick = function() {
            modal25.style.display = "block";
        }
        span25.onclick = function() {
            modal25.style.display = "none";
        }
        var modal26 = document.getElementById("myModal26");
        var btn26 = document.getElementById("myBtn26");
        var span26 = document.getElementsByClassName("close26")[0];
        btn26.onclick = function() {
            modal26.style.display = "block";
        }
        span26.onclick = function() {
            modal26.style.display = "none";
        }
        var modal27 = document.getElementById("myModal27");
        var btn27 = document.getElementById("myBtn27");
        var span27 = document.getElementsByClassName("close27")[0];
        btn27.onclick = function() {
            modal27.style.display = "block";
        }
        span27.onclick = function() {
            modal27.style.display = "none";
        }
        var modal28 = document.getElementById("myModal28");
        var btn28 = document.getElementById("myBtn28");
        var span28 = document.getElementsByClassName("close28")[0];
        btn28.onclick = function() {
            modal28.style.display = "block";
        }
        span28.onclick = function() {
            modal28.style.display = "none";
        }
        var modal29 = document.getElementById("myModal29");
        var btn29 = document.getElementById("myBtn29");
        var span29 = document.getElementsByClassName("close29")[0];
        btn29.onclick = function() {
            modal29.style.display = "block";
        }
        span29.onclick = function() {
            modal29.style.display = "none";
        }
        var modal30 = document.getElementById("myModal30");
        var btn30 = document.getElementById("myBtn30");
        var span30 = document.getElementsByClassName("close30")[0];
        btn30.onclick = function() {
            modal30.style.display = "block";
        }
        span30.onclick = function() {
            modal30.style.display = "none";
        }
        var modal31 = document.getElementById("myModal31");
        var btn31 = document.getElementById("myBtn31");
        var span31 = document.getElementsByClassName("close31")[0];
        span31.onclick = function() {
            modal31.style.display = "none";
        }
        btn31.onclick = function() {
            modal31.style.display = "block";
        }
        var modal32 = document.getElementById("myModal32");
        var btn32 = document.getElementById("myBtn32");
        var span32 = document.getElementsByClassName("close32")[0];
        btn32.onclick = function() {
            modal32.style.display = "block";
        }
        span32.onclick = function() {
            modal32.style.display = "none";
        }
        var modal33 = document.getElementById("myModal33");
        var btn33 = document.getElementById("myBtn33");
        var span33 = document.getElementsByClassName("close33")[0];
        btn33.onclick = function() {
            modal33.style.display = "block";
        }
        span33.onclick = function() {
            modal33.style.display = "none";
        }
        var modal34 = document.getElementById("myModal34");
        var btn34 = document.getElementById("myBtn34");
        var span34 = document.getElementsByClassName("close34")[0];
        btn34.onclick = function() {
            modal34.style.display = "block";
        }
        span34.onclick = function() {
            modal34.style.display = "none";
        }
        var modal35 = document.getElementById("myModal35");
        var btn35 = document.getElementById("myBtn35");
        var span35 = document.getElementsByClassName("close35")[0];
        btn35.onclick = function() {
            modal35.style.display = "block";
        }
        span35.onclick = function() {
            modal35.style.display = "none";
        }
        var modal36 = document.getElementById("myModal36");
        var btn36 = document.getElementById("myBtn36");
        var span36 = document.getElementsByClassName("close36")[0];
        btn36.onclick = function() {
            modal36.style.display = "block";
        }
        span36.onclick = function() {
            modal36.style.display = "none";
        }
        var modal37 = document.getElementById("myModal37");
        var btn37 = document.getElementById("myBtn37");
        var span37 = document.getElementsByClassName("close37")[0];
        btn37.onclick = function() {
            modal37.style.display = "block";
        }
        span37.onclick = function() {
            modal37.style.display = "none";
        }
        var modal38 = document.getElementById("myModal38");
        var btn38 = document.getElementById("myBtn38");
        var span38 = document.getElementsByClassName("close38")[0];
        btn38.onclick = function() {
            modal38.style.display = "block";
        }
        span38.onclick = function() {
            modal38.style.display = "none";
        }
        var modal39 = document.getElementById("myModal39");
        var btn39 = document.getElementById("myBtn39");
        var span39 = document.getElementsByClassName("close39")[0];
        btn39.onclick = function() {
            modal39.style.display = "block";
        }
        span39.onclick = function() {
            modal39.style.display = "none";
        }
        var modal40 = document.getElementById("myModal40");
        var btn40 = document.getElementById("myBtn40");
        var span40 = document.getElementsByClassName("close40")[0];
        btn40.onclick = function() {
            modal40.style.display = "block";
        }
        span40.onclick = function() {
            modal40.style.display = "none";
        }
        var modal41 = document.getElementById("myModal41");
        var btn41 = document.getElementById("myBtn41");
        var span41 = document.getElementsByClassName("close41")[0];
        span41.onclick = function() {
            modal41.style.display = "none";
        }
        btn41.onclick = function() {
            modal41.style.display = "block";
        }
        var modal42 = document.getElementById("myModal42");
        var btn42 = document.getElementById("myBtn42");
        var span42 = document.getElementsByClassName("close42")[0];
        btn42.onclick = function() {
            modal42.style.display = "block";
        }
        span42.onclick = function() {
            modal42.style.display = "none";
        }
        var modal43 = document.getElementById("myModal43");
        var btn43 = document.getElementById("myBtn43");
        var span43 = document.getElementsByClassName("close43")[0];
        btn43.onclick = function() {
            modal43.style.display = "block";
        }
        span43.onclick = function() {
            modal43.style.display = "none";
        }
        var modal44 = document.getElementById("myModal44");
        var btn44 = document.getElementById("myBtn44");
        var span44 = document.getElementsByClassName("close44")[0];
        btn44.onclick = function() {
            modal44.style.display = "block";
        }
        span44.onclick = function() {
            modal44.style.display = "none";
        }
        var modal45 = document.getElementById("myModal45");
        var btn45 = document.getElementById("myBtn45");
        var span45 = document.getElementsByClassName("close45")[0];
        btn45.onclick = function() {
            modal45.style.display = "block";
        }
        span45.onclick = function() {
            modal45.style.display = "none";
        }
        var modal46 = document.getElementById("myModal46");
        var btn46 = document.getElementById("myBtn46");
        var span46 = document.getElementsByClassName("close46")[0];
        btn46.onclick = function() {
            modal46.style.display = "block";
        }
        span46.onclick = function() {
            modal46.style.display = "none";
        }
        var modal47 = document.getElementById("myModal47");
        var btn47 = document.getElementById("myBtn47");
        var span47 = document.getElementsByClassName("close47")[0];
        btn47.onclick = function() {
            modal47.style.display = "block";
        }
        span47.onclick = function() {
            modal47.style.display = "none";
        }
        var modal48 = document.getElementById("myModal48");
        var btn48 = document.getElementById("myBtn48");
        var span48 = document.getElementsByClassName("close48")[0];
        btn48.onclick = function() {
            modal48.style.display = "block";
        }
        span48.onclick = function() {
            modal48.style.display = "none";
        }
        var modal49 = document.getElementById("myModal49");
        var btn49 = document.getElementById("myBtn49");
        var span49 = document.getElementsByClassName("close49")[0];
        btn49.onclick = function() {
            modal49.style.display = "block";
        }
        span49.onclick = function() {
            modal49.style.display = "none";
        }
        var modal50 = document.getElementById("myModal50");
        var btn50 = document.getElementById("myBtn50");
        var span50 = document.getElementsByClassName("close50")[0];
        btn50.onclick = function() {
            modal50.style.display = "block";
        }
        span50.onclick = function() {
            modal50.style.display = "none";
        }
        var modal51 = document.getElementById("myModal51");
        var btn51 = document.getElementById("myBtn51");
        var span51 = document.getElementsByClassName("close51")[0];
        span51.onclick = function() {
            modal51.style.display = "none";
        }
        btn51.onclick = function() {
            modal51.style.display = "block";
        }
        var modal52 = document.getElementById("myModal52");
        var btn52 = document.getElementById("myBtn52");
        var span52 = document.getElementsByClassName("close52")[0];
        btn52.onclick = function() {
            modal52.style.display = "block";
        }
        span52.onclick = function() {
            modal52.style.display = "none";
        }
        var modal53 = document.getElementById("myModal53");
        var btn53 = document.getElementById("myBtn53");
        var span53 = document.getElementsByClassName("close53")[0];
        btn53.onclick = function() {
            modal53.style.display = "block";
        }
        span53.onclick = function() {
            modal53.style.display = "none";
        }
        var modal54 = document.getElementById("myModal54");
        var btn54 = document.getElementById("myBtn54");
        var span54 = document.getElementsByClassName("close54")[0];
        btn54.onclick = function() {
            modal54.style.display = "block";
        }
        span54.onclick = function() {
            modal54.style.display = "none";
        }
        var modal55 = document.getElementById("myModal55");
        var btn55 = document.getElementById("myBtn55");
        var span55 = document.getElementsByClassName("close55")[0];
        btn55.onclick = function() {
            modal55.style.display = "block";
        }
        span55.onclick = function() {
            modal55.style.display = "none";
        }
        var modal56 = document.getElementById("myModal56");
        var btn56 = document.getElementById("myBtn56");
        var span56 = document.getElementsByClassName("close56")[0];
        btn56.onclick = function() {
            modal56.style.display = "block";
        }
        span56.onclick = function() {
            modal56.style.display = "none";
        }
        var modal57 = document.getElementById("myModal57");
        var btn57 = document.getElementById("myBtn57");
        var span57 = document.getElementsByClassName("close57")[0];
        btn57.onclick = function() {
            modal57.style.display = "block";
        }
        span57.onclick = function() {
            modal57.style.display = "none";
        }
        var modal58 = document.getElementById("myModal58");
        var btn58 = document.getElementById("myBtn58");
        var span58 = document.getElementsByClassName("close58")[0];
        btn58.onclick = function() {
            modal58.style.display = "block";
        }
        span58.onclick = function() {
            modal58.style.display = "none";
        }
        var modal59 = document.getElementById("myModal59");
        var btn59 = document.getElementById("myBtn59");
        var span59 = document.getElementsByClassName("close59")[0];
        btn59.onclick = function() {
            modal59.style.display = "block";
        }
        span59.onclick = function() {
            modal59.style.display = "none";
        }
        var modal60 = document.getElementById("myModal60");
        var btn60 = document.getElementById("myBtn60");
        var span60 = document.getElementsByClassName("close60")[0];
        btn60.onclick = function() {
            modal60.style.display = "block";
        }
        span60.onclick = function() {
            modal60.style.display = "none";
        }
        var modal61 = document.getElementById("myModal61");
        var btn61 = document.getElementById("myBtn61");
        var span61 = document.getElementsByClassName("close61")[0];
        span61.onclick = function() {
            modal61.style.display = "none";
        }
        btn61.onclick = function() {
            modal61.style.display = "block";
        }
        var modal62 = document.getElementById("myModal62");
        var btn62 = document.getElementById("myBtn62");
        var span62 = document.getElementsByClassName("close62")[0];
        btn62.onclick = function() {
            modal62.style.display = "block";
        }
        span62.onclick = function() {
            modal62.style.display = "none";
        }
        var modal63 = document.getElementById("myModal63");
        var btn63 = document.getElementById("myBtn63");
        var span63 = document.getElementsByClassName("close63")[0];
        btn63.onclick = function() {
            modal63.style.display = "block";
        }
        span63.onclick = function() {
            modal63.style.display = "none";
        }
        var modal64 = document.getElementById("myModal64");
        var btn64 = document.getElementById("myBtn64");
        var span64 = document.getElementsByClassName("close64")[0];
        btn64.onclick = function() {
            modal64.style.display = "block";
        }
        span64.onclick = function() {
            modal64.style.display = "none";
        }
        var modal65 = document.getElementById("myModal65");
        var btn65 = document.getElementById("myBtn65");
        var span65 = document.getElementsByClassName("close65")[0];
        btn65.onclick = function() {
            modal65.style.display = "block";
        }
        span65.onclick = function() {
            modal65.style.display = "none";
        }
        var modal66 = document.getElementById("myModal66");
        var btn66 = document.getElementById("myBtn66");
        var span66 = document.getElementsByClassName("close66")[0];
        btn66.onclick = function() {
            modal66.style.display = "block";
        }
        span66.onclick = function() {
            modal66.style.display = "none";
        }
        var modal67 = document.getElementById("myModal67");
        var btn67 = document.getElementById("myBtn67");
        var span67 = document.getElementsByClassName("close67")[0];
        btn67.onclick = function() {
            modal67.style.display = "block";
        }
        span67.onclick = function() {
            modal67.style.display = "none";
        }
        var modal68 = document.getElementById("myModal68");
        var btn68 = document.getElementById("myBtn68");
        var span68 = document.getElementsByClassName("close68")[0];
        btn68.onclick = function() {
            modal68.style.display = "block";
        }
        span68.onclick = function() {
            modal68.style.display = "none";
        }
        var modal69 = document.getElementById("myModal69");
        var btn69 = document.getElementById("myBtn69");
        var span69 = document.getElementsByClassName("close69")[0];
        btn69.onclick = function() {
            modal69.style.display = "block";
        }
        span69.onclick = function() {
            modal69.style.display = "none";
        }
        var modal70 = document.getElementById("myModal70");
        var btn70 = document.getElementById("myBtn70");
        var span70 = document.getElementsByClassName("close70")[0];
        btn70.onclick = function() {
            modal70.style.display = "block";
        }
        span70.onclick = function() {
            modal70.style.display = "none";
        }
        var modal71 = document.getElementById("myModal71");
        var btn71 = document.getElementById("myBtn71");
        var span71 = document.getElementsByClassName("close71")[0];
        span71.onclick = function() {
            modal71.style.display = "none";
        }
        btn71.onclick = function() {
            modal71.style.display = "block";
        }
        var modal72 = document.getElementById("myModal72");
        var btn72 = document.getElementById("myBtn72");
        var span72 = document.getElementsByClassName("close72")[0];
        btn72.onclick = function() {
            modal72.style.display = "block";
        }
        span72.onclick = function() {
            modal72.style.display = "none";
        }
        var modal73 = document.getElementById("myModal73");
        var btn73 = document.getElementById("myBtn73");
        var span73 = document.getElementsByClassName("close73")[0];
        btn73.onclick = function() {
            modal73.style.display = "block";
        }
        span73.onclick = function() {
            modal73.style.display = "none";
        }
        var modal74 = document.getElementById("myModal74");
        var btn74 = document.getElementById("myBtn74");
        var span74 = document.getElementsByClassName("close74")[0];
        btn74.onclick = function() {
            modal74.style.display = "block";
        }
        span74.onclick = function() {
            modal74.style.display = "none";
        }
        var modal75 = document.getElementById("myModal75");
        var btn75 = document.getElementById("myBtn75");
        var span75 = document.getElementsByClassName("close75")[0];
        btn75.onclick = function() {
            modal75.style.display = "block";
        }
        span75.onclick = function() {
            modal75.style.display = "none";
        }
        var modal76 = document.getElementById("myModal76");
        var btn76 = document.getElementById("myBtn76");
        var span76 = document.getElementsByClassName("close76")[0];
        btn76.onclick = function() {
            modal76.style.display = "block";
        }
        span76.onclick = function() {
            modal76.style.display = "none";
        }
        var modal77 = document.getElementById("myModal77");
        var btn77 = document.getElementById("myBtn77");
        var span77 = document.getElementsByClassName("close77")[0];
        btn77.onclick = function() {
            modal77.style.display = "block";
        }
        span77.onclick = function() {
            modal77.style.display = "none";
        }
        var modal78 = document.getElementById("myModal78");
        var btn78 = document.getElementById("myBtn78");
        var span78 = document.getElementsByClassName("close78")[0];
        btn78.onclick = function() {
            modal78.style.display = "block";
        }
        span78.onclick = function() {
            modal78.style.display = "none";
        }
        var modal79 = document.getElementById("myModal79");
        var btn79 = document.getElementById("myBtn79");
        var span79 = document.getElementsByClassName("close79")[0];
        btn79.onclick = function() {
            modal79.style.display = "block";
        }
        span79.onclick = function() {
            modal79.style.display = "none";
        }
        var modal80 = document.getElementById("myModal80");
        var btn80 = document.getElementById("myBtn80");
        var span80 = document.getElementsByClassName("close80")[0];
        btn80.onclick = function() {
            modal80.style.display = "block";
        }
        span80.onclick = function() {
            modal80.style.display = "none";
        }
        var modal81 = document.getElementById("myModal81");
        var btn81 = document.getElementById("myBtn81");
        var span81 = document.getElementsByClassName("close81")[0];
        span81.onclick = function() {
            modal81.style.display = "none";
        }
        btn81.onclick = function() {
            modal81.style.display = "block";
        }
        var modal82 = document.getElementById("myModal82");
        var btn82 = document.getElementById("myBtn82");
        var span82 = document.getElementsByClassName("close82")[0];
        btn82.onclick = function() {
            modal82.style.display = "block";
        }
        span82.onclick = function() {
            modal82.style.display = "none";
        }
        var modal83 = document.getElementById("myModal83");
        var btn83 = document.getElementById("myBtn83");
        var span83 = document.getElementsByClassName("close83")[0];
        btn83.onclick = function() {
            modal83.style.display = "block";
        }
        span83.onclick = function() {
            modal83.style.display = "none";
        }
        var modal84 = document.getElementById("myModal84");
        var btn84 = document.getElementById("myBtn84");
        var span84 = document.getElementsByClassName("close84")[0];
        btn84.onclick = function() {
            modal84.style.display = "block";
        }
        span84.onclick = function() {
            modal84.style.display = "none";
        }
        var modal85 = document.getElementById("myModal85");
        var btn85 = document.getElementById("myBtn85");
        var span85 = document.getElementsByClassName("close85")[0];
        btn85.onclick = function() {
            modal85.style.display = "block";
        }
        span85.onclick = function() {
            modal85.style.display = "none";
        }
        var modal86 = document.getElementById("myModal86");
        var btn86 = document.getElementById("myBtn86");
        var span86 = document.getElementsByClassName("close86")[0];
        btn86.onclick = function() {
            modal86.style.display = "block";
        }
        span86.onclick = function() {
            modal86.style.display = "none";
        }
        var modal87 = document.getElementById("myModal87");
        var btn87 = document.getElementById("myBtn87");
        var span87 = document.getElementsByClassName("close87")[0];
        btn87.onclick = function() {
            modal87.style.display = "block";
        }
        span87.onclick = function() {
            modal87.style.display = "none";
        }
        var modal88 = document.getElementById("myModal88");
        var btn88 = document.getElementById("myBtn88");
        var span88 = document.getElementsByClassName("close88")[0];
        btn88.onclick = function() {
            modal88.style.display = "block";
        }
        span88.onclick = function() {
            modal88.style.display = "none";
        }
        var modal89 = document.getElementById("myModal89");
        var btn89 = document.getElementById("myBtn89");
        var span89 = document.getElementsByClassName("close89")[0];
        btn89.onclick = function() {
            modal89.style.display = "block";
        }
        span89.onclick = function() {
            modal89.style.display = "none";
        }
        var modal90 = document.getElementById("myModal90");
        var btn90 = document.getElementById("myBtn90");
        var span90 = document.getElementsByClassName("close90")[0];
        btn90.onclick = function() {
            modal90.style.display = "block";
        }
        span90.onclick = function() {
            modal90.style.display = "none";
        }
        var modal91 = document.getElementById("myModal91");
        var btn91 = document.getElementById("myBtn91");
        var span91 = document.getElementsByClassName("close91")[0];
        span91.onclick = function() {
            modal91.style.display = "none";
        }
        btn91.onclick = function() {
            modal91.style.display = "block";
        }
        var modal92 = document.getElementById("myModal92");
        var btn92 = document.getElementById("myBtn92");
        var span92 = document.getElementsByClassName("close92")[0];
        btn92.onclick = function() {
            modal92.style.display = "block";
        }
        span92.onclick = function() {
            modal92.style.display = "none";
        }
        var modal93 = document.getElementById("myModal93");
        var btn93 = document.getElementById("myBtn93");
        var span93 = document.getElementsByClassName("close93")[0];
        btn93.onclick = function() {
            modal93.style.display = "block";
        }
        span93.onclick = function() {
            modal93.style.display = "none";
        }
        var modal94 = document.getElementById("myModal94");
        var btn94 = document.getElementById("myBtn94");
        var span94 = document.getElementsByClassName("close94")[0];
        btn94.onclick = function() {
            modal94.style.display = "block";
        }
        span94.onclick = function() {
            modal94.style.display = "none";
        }
        var modal95 = document.getElementById("myModal95");
        var btn95 = document.getElementById("myBtn95");
        var span95 = document.getElementsByClassName("close95")[0];
        btn95.onclick = function() {
            modal95.style.display = "block";
        }
        span95.onclick = function() {
            modal95.style.display = "none";
        }
        var modal96 = document.getElementById("myModal96");
        var btn96 = document.getElementById("myBtn96");
        var span96 = document.getElementsByClassName("close96")[0];
        btn96.onclick = function() {
            modal96.style.display = "block";
        }
        span96.onclick = function() {
            modal96.style.display = "none";
        }
        var modal97 = document.getElementById("myModal97");
        var btn97 = document.getElementById("myBtn97");
        var span97 = document.getElementsByClassName("close97")[0];
        btn97.onclick = function() {
            modal97.style.display = "block";
        }
        span97.onclick = function() {
            modal97.style.display = "none";
        }
        var modal98 = document.getElementById("myModal98");
        var btn98 = document.getElementById("myBtn98");
        var span98 = document.getElementsByClassName("close98")[0];
        btn98.onclick = function() {
            modal98.style.display = "block";
        }
        span98.onclick = function() {
            modal98.style.display = "none";
        }
        var modal99 = document.getElementById("myModal99");
        var btn99 = document.getElementById("myBtn99");
        var span99 = document.getElementsByClassName("close99")[0];
        btn99.onclick = function() {
            modal99.style.display = "block";
        }
        span99.onclick = function() {
            modal99.style.display = "none";
        }
        var modal100 = document.getElementById("myModal100");
        var btn100 = document.getElementById("myBtn100");
        var span100 = document.getElementsByClassName("close100")[0];
        btn100.onclick = function() {
            modal100.style.display = "block";
        }
        span100.onclick = function() {
            modal100.style.display = "none";
        }
        var modal101 = document.getElementById("myModal101");
        var btn101 = document.getElementById("myBtn101");
        var span101 = document.getElementsByClassName("close101")[0];
        span101.onclick = function() {
            modal101.style.display = "none";
        }
        btn101.onclick = function() {
            modal101.style.display = "block";
        }
        var modal102 = document.getElementById("myModal102");
        var btn102 = document.getElementById("myBtn102");
        var span102 = document.getElementsByClassName("close102")[0];
        btn102.onclick = function() {
            modal102.style.display = "block";
        }
        span102.onclick = function() {
            modal102.style.display = "none";
        }
        var modal103 = document.getElementById("myModal103");
        var btn103 = document.getElementById("myBtn103");
        var span103 = document.getElementsByClassName("close103")[0];
        btn103.onclick = function() {
            modal103.style.display = "block";
        }
        span103.onclick = function() {
            modal103.style.display = "none";
        }
        var modal104 = document.getElementById("myModal104");
        var btn104 = document.getElementById("myBtn104");
        var span104 = document.getElementsByClassName("close104")[0];
        btn104.onclick = function() {
            modal104.style.display = "block";
        }
        span104.onclick = function() {
            modal104.style.display = "none";
        }
        var modal105 = document.getElementById("myModal105");
        var btn105 = document.getElementById("myBtn105");
        var span105 = document.getElementsByClassName("close105")[0];
        btn105.onclick = function() {
            modal105.style.display = "block";
        }
        span105.onclick = function() {
            modal105.style.display = "none";
        }
        var modal106 = document.getElementById("myModal106");
        var btn106 = document.getElementById("myBtn106");
        var span106 = document.getElementsByClassName("close106")[0];
        btn106.onclick = function() {
            modal106.style.display = "block";
        }
        span106.onclick = function() {
            modal106.style.display = "none";
        }
        var modal107 = document.getElementById("myModal107");
        var btn107 = document.getElementById("myBtn107");
        var span107 = document.getElementsByClassName("close107")[0];
        btn107.onclick = function() {
            modal107.style.display = "block";
        }
        span107.onclick = function() {
            modal107.style.display = "none";
        }
        var modal108 = document.getElementById("myModal108");
        var btn108 = document.getElementById("myBtn108");
        var span108 = document.getElementsByClassName("close108")[0];
        btn108.onclick = function() {
            modal108.style.display = "block";
        }
        span108.onclick = function() {
            modal108.style.display = "none";
        }
        var modal109 = document.getElementById("myModal109");
        var btn109 = document.getElementById("myBtn109");
        var span109 = document.getElementsByClassName("close109")[0];
        btn109.onclick = function() {
            modal109.style.display = "block";
        }
        span109.onclick = function() {
            modal109.style.display = "none";
        }
        var modal110 = document.getElementById("myModal110");
        var btn110 = document.getElementById("myBtn110");
        var span110 = document.getElementsByClassName("close110")[0];
        btn110.onclick = function() {
            modal110.style.display = "block";
        }
        span110.onclick = function() {
            modal110.style.display = "none";
        }
        var modal111 = document.getElementById("myModal111");
        var btn111 = document.getElementById("myBtn111");
        var span111 = document.getElementsByClassName("close111")[0];
        span111.onclick = function() {
            modal111.style.display = "none";
        }
        btn111.onclick = function() {
            modal111.style.display = "block";
        }
        var modal112 = document.getElementById("myModal112");
        var btn112 = document.getElementById("myBtn112");
        var span112 = document.getElementsByClassName("close112")[0];
        btn112.onclick = function() {
            modal112.style.display = "block";
        }
        span112.onclick = function() {
            modal112.style.display = "none";
        }
        var modal113 = document.getElementById("myModal113");
        var btn113 = document.getElementById("myBtn113");
        var span113 = document.getElementsByClassName("close113")[0];
        btn113.onclick = function() {
            modal113.style.display = "block";
        }
        span113.onclick = function() {
            modal113.style.display = "none";
        }
        var modal114 = document.getElementById("myModal114");
        var btn114 = document.getElementById("myBtn114");
        var span114 = document.getElementsByClassName("close114")[0];
        btn114.onclick = function() {
            modal114.style.display = "block";
        }
        span114.onclick = function() {
            modal114.style.display = "none";
        }
        var modal115 = document.getElementById("myModal115");
        var btn115 = document.getElementById("myBtn115");
        var span115 = document.getElementsByClassName("close115")[0];
        btn115.onclick = function() {
            modal115.style.display = "block";
        }
        span115.onclick = function() {
            modal115.style.display = "none";
        }
        var modal116 = document.getElementById("myModal116");
        var btn116 = document.getElementById("myBtn116");
        var span116 = document.getElementsByClassName("close116")[0];
        btn116.onclick = function() {
            modal116.style.display = "block";
        }
        span116.onclick = function() {
            modal116.style.display = "none";
        }
        var modal117 = document.getElementById("myModal117");
        var btn117 = document.getElementById("myBtn117");
        var span117 = document.getElementsByClassName("close117")[0];
        btn117.onclick = function() {
            modal117.style.display = "block";
        }
        span117.onclick = function() {
            modal117.style.display = "none";
        }
        var modal118 = document.getElementById("myModal118");
        var btn118 = document.getElementById("myBtn118");
        var span118 = document.getElementsByClassName("close118")[0];
        btn118.onclick = function() {
            modal118.style.display = "block";
        }
        span118.onclick = function() {
            modal118.style.display = "none";
        }
        var modal119 = document.getElementById("myModal119");
        var btn119 = document.getElementById("myBtn119");
        var span119 = document.getElementsByClassName("close119")[0];
        btn119.onclick = function() {
            modal119.style.display = "block";
        }
        span119.onclick = function() {
            modal119.style.display = "none";
        }
        var modal120 = document.getElementById("myModal120");
        var btn120 = document.getElementById("myBtn120");
        var span120 = document.getElementsByClassName("close120")[0];
        btn120.onclick = function() {
            modal120.style.display = "block";
        }
        span120.onclick = function() {
            modal120.style.display = "none";
        }
        var modal121 = document.getElementById("myModal121");
        var btn121 = document.getElementById("myBtn121");
        var span121 = document.getElementsByClassName("close121")[0];
        span121.onclick = function() {
            modal121.style.display = "none";
        }
        btn121.onclick = function() {
            modal121.style.display = "block";
        }
        var modal122 = document.getElementById("myModal122");
        var btn122 = document.getElementById("myBtn122");
        var span122 = document.getElementsByClassName("close122")[0];
        btn122.onclick = function() {
            modal122.style.display = "block";
        }
        span122.onclick = function() {
            modal122.style.display = "none";
        }
        var modal123 = document.getElementById("myModal123");
        var btn123 = document.getElementById("myBtn123");
        var span123 = document.getElementsByClassName("close123")[0];
        btn123.onclick = function() {
            modal123.style.display = "block";
        }
        span123.onclick = function() {
            modal123.style.display = "none";
        }
        var modal124 = document.getElementById("myModal124");
        var btn124 = document.getElementById("myBtn124");
        var span124 = document.getElementsByClassName("close124")[0];
        btn124.onclick = function() {
            modal124.style.display = "block";
        }
        span124.onclick = function() {
            modal124.style.display = "none";
        }
        var modal125 = document.getElementById("myModal125");
        var btn125 = document.getElementById("myBtn125");
        var span125 = document.getElementsByClassName("close125")[0];
        btn125.onclick = function() {
            modal125.style.display = "block";
        }
        span125.onclick = function() {
            modal125.style.display = "none";
        }
        var modal126 = document.getElementById("myModal126");
        var btn126 = document.getElementById("myBtn126");
        var span126 = document.getElementsByClassName("close126")[0];
        btn126.onclick = function() {
            modal126.style.display = "block";
        }
        span126.onclick = function() {
            modal126.style.display = "none";
        }
        var modal127 = document.getElementById("myModal127");
        var btn127 = document.getElementById("myBtn127");
        var span127 = document.getElementsByClassName("close127")[0];
        btn127.onclick = function() {
            modal127.style.display = "block";
        }
        span127.onclick = function() {
            modal127.style.display = "none";
        }
        var modal128 = document.getElementById("myModal128");
        var btn128 = document.getElementById("myBtn128");
        var span128 = document.getElementsByClassName("close128")[0];
        btn128.onclick = function() {
            modal128.style.display = "block";
        }
        span128.onclick = function() {
            modal128.style.display = "none";
        }
        var modal129 = document.getElementById("myModal129");
        var btn129 = document.getElementById("myBtn129");
        var span129 = document.getElementsByClassName("close129")[0];
        btn129.onclick = function() {
            modal129.style.display = "block";
        }
        span129.onclick = function() {
            modal129.style.display = "none";
        }
        var modal130 = document.getElementById("myModal130");
        var btn130 = document.getElementById("myBtn130");
        var span130 = document.getElementsByClassName("close130")[0];
        btn130.onclick = function() {
            modal130.style.display = "block";
        }
        span130.onclick = function() {
            modal130.style.display = "none";
        }
        var modal131 = document.getElementById("myModal131");
        var btn131 = document.getElementById("myBtn131");
        var span131 = document.getElementsByClassName("close131")[0];
        btn131.onclick = function() {
            modal131.style.display = "block";
        }
        span131.onclick = function() {
            modal131.style.display = "none";
        }
        var modal132 = document.getElementById("myModal132");
        var btn132 = document.getElementById("myBtn132");
        var span132 = document.getElementsByClassName("close132")[0];
        btn132.onclick = function() {
            modal132.style.display = "block";
        }
        span132.onclick = function() {
            modal132.style.display = "none";
        }
        var modal133 = document.getElementById("myModal133");
        var btn133 = document.getElementById("myBtn133");
        var span133 = document.getElementsByClassName("close133")[0];
        btn133.onclick = function() {
            modal133.style.display = "block";
        }
        span133.onclick = function() {
            modal133.style.display = "none";
        }
        var modal134 = document.getElementById("myModal134");
        var btn134 = document.getElementById("myBtn134");
        var span134 = document.getElementsByClassName("close134")[0];
        btn134.onclick = function() {
            modal134.style.display = "block";
        }
        span134.onclick = function() {
            modal134.style.display = "none";
        }
        var modal135 = document.getElementById("myModal135");
        var btn135 = document.getElementById("myBtn135");
        var span135 = document.getElementsByClassName("close135")[0];
        btn135.onclick = function() {
            modal135.style.display = "block";
        }
        span135.onclick = function() {
            modal135.style.display = "none";
        }
        var modal136 = document.getElementById("myModal136");
        var btn136 = document.getElementById("myBtn136");
        var span136 = document.getElementsByClassName("close136")[0];
        btn136.onclick = function() {
            modal136.style.display = "block";
        }
        span136.onclick = function() {
            modal136.style.display = "none";
        }
    </script>
    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        }
    </script>
</body>

</html>